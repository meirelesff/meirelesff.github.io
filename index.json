[{"authors":["admin"],"categories":null,"content":"I am a Postdoctoral Fellow at the Institute of Social and Political Studies (IESP-UERJ), where I study and teach comparative politics and political methodology. I am also a Research Associate at the Center for Legislative Studies (CEL-UFMG) and was previously a visiting scholar at the Department of Government of the University of Essex.\nMy research centers on the consequences of political institutions on policy-making and welfare in presidential countries. In my recent work, I investigate how the separation of powers and fiscal decentralization explain how parties reap benefits from joining government coalitions in Brazil. In my spare time, I also develop open-source software for social research. In particular, I have been working mostly on tools to facilitate access to Brazilian public data – that often comes in unfriendly, poorly documented formats – to a broader public.\nOn this website, you can find details about my research. You might also download some of the materials I use to teach data science and R programming. A copy of my CV is available here.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"https://fmeireles.com/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"author","summary":"I am a Postdoctoral Fellow at the Institute of Social and Political Studies (IESP-UERJ), where I study and teach comparative politics and political methodology. I am also a Research Associate at the Center for Legislative Studies (CEL-UFMG) and was previously a visiting scholar at the Department of Government of the University of Essex.\nMy research centers on the consequences of political institutions on policy-making and welfare in presidential countries. In my recent work, I investigate how the separation of powers and fiscal decentralization explain how parties reap benefits from joining government coalitions in Brazil.","tags":null,"title":"Fernando Meireles","type":"author"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"67258d08367eedc8373d83fde4bbe64f","permalink":"https://fmeireles.com/blog/posts/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/posts/","section":"blog","summary":"","tags":null,"title":"Blog","type":"blog"},{"authors":["Fernando Meireles"],"categories":null,"content":"","date":1546308000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546308000,"objectID":"2159c05ea92aeaadb83cb600c3a850bd","permalink":"https://fmeireles.com/publication/carreiras-camara-deputados/","publishdate":"2018-12-31T23:00:00-03:00","relpermalink":"/publication/carreiras-camara-deputados/","section":"publication","summary":"Este artigo investiga o efeito das eleições sobre as carreiras dos candidatos a deputado federal no Brasil. Com um desenho de regressão descontínua, mostro que os resultados de uma única eleição têm impactos substantivos: obter um mandato na Câmara causa um aumento de cerca de 25 pontos percentuais a mais na chance de um político obter o mesmo cargo novamente quatro anos depois, efeito que permanece positivo por até doze anos após a eleição inicial. Candidatos derrotados, ao contrário, passam a ambicionar mais cargos eletivos nos municípios, mas não têm maiores chances de obtê-los; além disso, estes têm probabilidade muito maior de se retirarem da arena eleitoral. Nesse sentido, o artigo contribui ao mostrar que mesmo os resultados de uma única eleição afetam as perspectivas de carreira dos políticos brasileiros, alçando uns à política em nível nacional e, outros, ao âmbito local e à aposentadoria.","tags":[],"title":"Carreiras políticas na Câmara dos Deputados: Uma análise quase-experimental","type":"publication"},{"authors":["Royce Carroll","Fernando Meireles"],"categories":null,"content":"","date":1546308000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546308000,"objectID":"a7a866ffbe5977fd8ffb4c4b875878ea","permalink":"https://fmeireles.com/publication/legislative-representation-brazil/","publishdate":"2018-12-31T23:00:00-03:00","relpermalink":"/publication/legislative-representation-brazil/","section":"publication","summary":"How well do legislative elites represent voters? Here, we examine voter-elite congruence in the multi-level context of Brazil’s federal system. We extend recent work on congruence by including an unprecedented amount of elite survey data from 12 Brazilian states into a unified study of voter-elite relationships. We exploit the fact that these surveys include questions asking respondents to place major Brazilian parties and figures and themselves in a left-right ideological scale to estimate deputies and respondents’ ideal points in a common scale using Bayesian Aldrich-McKelvey scaling. We show that even in the fragmented Brazilian party system, there is a high degree of overall congruence between voters and politicians’ ideological positions, particularly with regard to state deputies. However, we find that this is less clearly the case between the major parties and their supporters, with the major right-wing parties tend deviating substantially from their voters. In our dyadic analysis, which allows us to consider the characteristics of specific deputies and voters, we find that higher educated and especially higher income deputies are among those least congruent with voters.","tags":[],"title":"Legislative Representation in a Multilevel System: The Case of Brazil","type":"publication"},{"authors":["Fernando Meireles"],"categories":null,"content":"","date":1546308000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546308000,"objectID":"d8d1320416aece0e4a69f6b9b1ec8247","permalink":"https://fmeireles.com/publication/alinhamento-partidario-demanda/","publishdate":"2018-12-31T23:00:00-03:00","relpermalink":"/publication/alinhamento-partidario-demanda/","section":"publication","summary":"This article analyzes how subnational governments request transfers from the federal government in Brazil. Using microdata on applications for discretionary transfers from the Brazilian federal government to municipalities between 2009 and 2016 and a regression discontinuity design (RDD), I show that mayors affiliated with the president’s party demand substantially more resources than opposition mayors, meaning that the partisan alignment is an important channel to request transfers. On the other hand, the effect varies among mayors from other coalition parties. Thus, the results show that partisan alignment between different levels of government is a key factor in explaining the requests for discretionary resources in Brazil","tags":[],"title":"Partisan alignment and requests for federal transfers in Brazil","type":"publication"},{"authors":["Fernando Meireles","Denisson Silva"],"categories":null,"content":"","date":1546308000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546308000,"objectID":"2d7c571d2a857d2a26a05515bd451ba2","permalink":"https://fmeireles.com/publication/livro-r-cientistas-politicos/","publishdate":"2018-12-31T23:00:00-03:00","relpermalink":"/publication/livro-r-cientistas-politicos/","section":"publication","summary":"Nosso objetivo ao oferecer um novo livro é cobrir a demanda acadêmica mais recente por R para a pesquisa científica na área de Ciência Política e similares.","tags":[],"title":"Usando R: Um Guia Para Cientistas Políticos","type":"publication"},{"authors":["Fernando Meireles"],"categories":["rstats","deflatebr"],"content":" Deflacionar séries é pré-requisito em qualquer análise sobre o valor do dinheiro ao longo do tempo. E embora não seja algo complexo, isso envolve várias etapas que consomem tempo, todas sujeitas a erro humano: obter dados históricos de algum índice de preços; compatibilizar as datas da série nominal que se quer corrigir com a série do índice de preços; calcular o ajuste; refazer o processo caso seja necessário usar outro índice de preços. Em suma, deflacionar séries acaba sempre tomando mais tempo do que deveria.\nPara realizar essa tarefa de uma forma mais rápida e replicável, usando cinco dos índices de preços mais populares no Brasil, criei um pacote para R: o deflateBR. A partir de uma série de reais nominais, ele obtém as séries de índices de preços atualizadas diretamente da API do IPEA e, em segundos, retorna os valores corrigidos – usando a metodologia adotada pelo Banco Central. Segue um breve descrição do pacote.\nComo funciona o deflateBR? O deflateBR automatiza três processos para deflacionar uma série. Primeiro, ele extrai dados de um dos seguintes índices de preços da API do IPEA: IPCA e INPC, desenvolvidos pelo IBGE; e IGP-M, IGP-DI e IPC, desenvolvidos pela FGV. Segundo, ele compatibiliza as datas mensais desses índices com as datas dos valores nominais da série. Feito isso, enfim, ele deflaciona e retorna os valores corrigidos.\nA função principal do pacote, deflate, requer apenas três argumentos: um vetor numérico de valores nominais; um vetor com as datas nominais; e uma data de referência no formato MM/AAAA. Um exemplo usando o IPCA:\n# Carrega o pacote library(deflateBR) # Deflaciona 100 reais de janeiro de 2000 deflate(nominal_values = 100, nominal_dates = as.Date(\u0026quot;2000-01-01\u0026quot;), real_date = \u0026quot;01/2018\u0026quot;)  ## ## Downloading necessary data from IPEA's API ## ... ## [1] 310.3893  Por padrão, a função deflate esse índice. Podemos alterar isso com outro argumento chamado index.\ndeflate(100, as.Date(\u0026quot;2000-01-01\u0026quot;), \u0026quot;01/2018\u0026quot;, index = \u0026quot;igpm\u0026quot;)  ## ## Downloading necessary data from IPEA's API ## ... ## [1] 372.1672  Passando o valor igpm para o argumento, a função usa o IGP-M como indexador. Os demais indexadores possíveis são: ipc para o IPC; igpdi para o IGP-DI; inpc para o INPC. Para sabermos 100 reais de janeiro de 1995 valeriam hoje segundo esse último, bastaria usar:\ndeflate(100, as.Date(\u0026quot;1995-01-01\u0026quot;), \u0026quot;01/2018\u0026quot;, \u0026quot;inpc\u0026quot;)  ## ## Downloading necessary data from IPEA's API ## ... ## [1] 491.0543  Deflacionando séries maiores Mais útil do que corrigir um único valor é corrigir séries inteiras, com várias quantias em reais nominais associadas a algum período específico. Para mostrar como a função deflate faz isso, podemos criar os seguinte data.frame:\ndados \u0026lt;- data.frame(reais = seq(1, 5), datas = seq.Date(from = as.Date(\u0026quot;2001-01-01\u0026quot;), by = \u0026quot;month\u0026quot;, length.out = 5), stringsAsFactors = FALSE )  Feito isso, temos agora dados fictícios, com valores de 1 a 5 observados desde janeiro até maio de 2001. Suponha que queremos deflacionar esses valores para janeiro de 2017 usando o IPC da FGV. Como fazer isso? Apenas mudando o jeito de passar as informações necessárias para a função deflate:\ndeflate(dados$reais, dados$datas, \u0026quot;01/2017\u0026quot;, \u0026quot;ipc\u0026quot;)  ## ## Downloading necessary data from IPEA's API ## ... ## [1] 2.759569 5.484001 8.193400 10.863809 13.464326  Combinando o deflateBR com o tidyverse Para quem usa o conjunto de pacotes contidos no tidyverse, a função deflate pode ser usada dentro de mutate() ou similares. Adaptando o exemplo anterior:\nlibrary(tidyverse) dados %\u0026gt;% mutate(reais_deflacionados = deflate(reais, datas, \u0026quot;01/2017\u0026quot;, \u0026quot;ipc\u0026quot;))  ## ## Downloading necessary data from IPEA's API ## ... ## reais datas reais_deflacionados ## 1 1 2001-01-01 2.759569 ## 2 2 2001-02-01 5.484001 ## 3 3 2001-03-01 8.193400 ## 4 4 2001-04-01 10.863809 ## 5 5 2001-05-01 13.464326  Outras funções Para facilitar o uso de cada um dos cinco índices de preços, também incluí no pacote deflateBR cinco funções auxiliares. Em vez de usar a função deflate com o argumento index = \u0026quot;ipca\u0026quot; para deflacionar pelo IPCA, é possível fazer isso:\nipca(dados$reais, dados$datas, \u0026quot;01/2017\u0026quot;)  ## ## Downloading necessary data from IPEA's API ## ... ## [1] 2.847600 5.662908 8.455458 11.231286 13.958171  Ou, para usar o IGP-DI, o seguinte:\nigpdi(dados$reais, dados$datas, \u0026quot;01/2017\u0026quot;)  ## ## Downloading necessary data from IPEA's API ## ... ## [1] 3.385977 6.738949 10.074312 13.325380 16.471004  Por fim, o pacote deflateBR também contém uma função simples, chamada inflation, para identificar a variação percentual na inflação entre dois períodos. Se quisermos saber qual foi a taxa de inflação em 2017 segundo o IPCA, por exemplo, basta rodar:\ninflation(\u0026quot;01/2017\u0026quot;, \u0026quot;12/2017\u0026quot;, \u0026quot;ipca\u0026quot;)  ## ## Downloading necessary data from IPEA's API ## ... ## [1] 2.947421  Como o resultado está em percentual, podemos dizer que a taxa de inflação em 2017, medida pelo IPCA, foi de 2.95%, conforme também reportado oficialmente pelo IBGE.\nExemplo de aplicação 1: o valor do salário mínimo Deflacionar séries é útil para ver como o poder de compra de salários ou outros variam ao longo do tempo. O salário mínimo, por exemplo, cresceu ou não acima da inflação? É possível responder a essa pergunta ajustando os salários nominais em cada período específico com um índice de preços, como o IPCA. Fazendo isso com o pacote deflateBR, podemos ver que o mínimo realmente cresceu acima da inflação desde 1995.\nExemplo de aplicação 2: o valor de bolsas de pós-graduação Um bom exemplo de categoria que não teve aumento de renda acima da inflação de 1995 a 2018 foram pós-graduandos que recebem bolsas de estudos da Capes. Fixadas há anos nos mesmos patamares – R$ 2200 para Doutorado, R$ 1500 para Mestrado –, a inflação não reposta se reflete em perda de poder de compra da categoria.[1] Como dá pra ver, o valor dos benefícios, hoje, praticamente voltaram aos patamares do início do primeiro governo Lula.\nValidade Como já dito, o deflateBR usa a fórmula convencional para corrigir valores nominais pela inflação: multiplicá-lo pela razão entre o índice de preços no período de referência e no período observado, assim como a calculadora disponibilizada pelo Banco Central. Os resultados do pacote e desse serviço, por essa razão, são iguais.[2]\nComo instalar Para instalar a versão disponível no CRAN do pacote, basta executar o seguinte códido:\ninstall.packages(\u0026quot;deflateBR\u0026quot;)  Final Como procurei mostrar, o pacote deflateBR faz rapidamente, e de forma replicável, correções de valores nominais pela inflação. De qualquer forma, por ser ainda a primeira versão dele, certamente existem várias coisas por implementar ou melhorar. Para quem quiser sugerir melhorias como essas ou outras, o código do pacote está disponível no GitHub. Críticas e sugestões, como sempre, são bem-vindos.\n Os dados sobre os períodos de ajustes nas bolsas foram retirados daqui.\n Em todos os testes que realizei, os resultados sempre foram praticamente idênticos – com algumas diferenças na terceira e, raramente, na segunda casa decimal, provavelmente por conta de algum arredondamento realizado pela ferramenta online do BC.\n  ","date":1538265600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1538265600,"objectID":"7945034df2fdba2de7c27a0148be88d2","permalink":"https://fmeireles.com/blog/rstats/deflacionar-series-no-r-deflatebr/","publishdate":"2018-09-30T00:00:00Z","relpermalink":"/blog/rstats/deflacionar-series-no-r-deflatebr/","section":"post","summary":"Deflacionar séries é pré-requisito em qualquer análise sobre o valor do dinheiro ao longo do tempo. E embora não seja algo complexo, isso envolve várias etapas que consomem tempo, todas sujeitas a erro humano: obter dados históricos de algum índice de preços; compatibilizar as datas da série nominal que se quer corrigir com a série do índice de preços; calcular o ajuste; refazer o processo caso seja necessário usar outro índice de preços.","tags":[],"title":"Deflacionando séries com o deflateBR","type":"post"},{"authors":["Fernando Meireles"],"categories":null,"content":"","date":1530414000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1530414000,"objectID":"5e2ba1aab06a522203fc6de1d00e5dfa","permalink":"https://fmeireles.com/publication/distributive-politics-cabinet/","publishdate":"2018-07-01T00:00:00-03:00","relpermalink":"/publication/distributive-politics-cabinet/","section":"publication","summary":"Studies on distributive politics show that presidents direct more discretionary resources to aligned local governments for electoral gains. In this paper, I argue that ministers have influence to pursue the same strategy, using their ministries’ resources to reward local governments ruled by copartisans. The results of two natural experiments in Brazil, a typical case of coalitional presidentialism, corroborate my argument.","tags":[],"title":"The Distributive Politics of Cabinet Ministers","type":"publication"},{"authors":["Fernando Meireles"],"categories":["rstats","genderbr"],"content":" Para quem trabalha com bases de dados públicas, não é incomum encontrar o seguinte problema: ter disponível em alguma coluna o nome de várias pessoas, mas não a informação sobre o sexo delas. Para lidar com esse problema, há alguns meses desenvolvi um pacote para R, o genderBR, que oferece um método simples para resolvê-lo: usando dados do Censo de 2010 do IBGE, ele inferie o sexo de uma pessoa a partir de seu nome próprio (como descrito em maiores detalhes aqui). Comparado à tarefa manual de classificar sexo a partir desses nomes, o método não só é infinitamente mais rápido, mas também evita erros de imputação, tornando replicável qualquer pesquisa que o use.\nApesar da utilidade do pacote para resolver esse problema, ele fazia isso com algumas limitações. A principal delas é a de tempo gasto na tarefa, às vezes na casa de horas ou dias. Basicamente, isso ocorre por causa da forma com que a principal função do pacote, get_gender, faz predições: para cada nome solicitado, ela envia uma requisição ao serviço online de nomes do IBGE (daqui para frente, API), recebe as informações necessárias e, com base nelas, calcula a probabilidade desse nome pertencer a um a homem ou a uma mulher. Como esse processo consome cerca de 0.1 segundos, as consequências são inevitáveis: para 10 mil nomes, a função pode facilmente rodar por mais de 15 horas.\nA partir da recém lançada versão do pacote, contudo, isso deixou de ser um problema. Aproveitando que o IBGE divulgou a base de dados que alimenta a API do serviço de nomes, agora o genderBR dispõe internamente dessas informações. Especificamente, a função get_gender ganhou um argumento opcional, internal, que permite escolher entre usar os dados internos do pacote (internal = TRUE, que agora é o padrão) ou requisitar os dados da API (internal = FALSE). Optando pelo primeiro, o processo de predizer nomes consome poucos segundos – e isso mesmo em bases com milhares ou milhões de nomes próprios.[1]\nComo usar o genderBR O primeiro passo para usar o genderBR é simples: com o R aberto, só é necessário executar install.packages(\u0026quot;genderBR\u0026quot;) para instalá-lo. Feito isso, predizer sexo a partir de nomes próprios é uma questão de chamar a função get_gender:\n# Carrega o pacote library(genderBR) # Prediz o sexo de oito nomes nomes \u0026lt;- c(\u0026quot;Guilherme\u0026quot;, \u0026quot;Maria\u0026quot;, \u0026quot;Ana\u0026quot;, \u0026quot;Arnaldo\u0026quot;, \u0026quot;Martha\u0026quot;, \u0026quot;Carlos\u0026quot;, \u0026quot;Almir\u0026quot;, \u0026quot;Cida\u0026quot;) get_gender(nomes)  ## [1] \u0026quot;Male\u0026quot; \u0026quot;Female\u0026quot; \u0026quot;Female\u0026quot; \u0026quot;Male\u0026quot; \u0026quot;Female\u0026quot; \u0026quot;Male\u0026quot; \u0026quot;Male\u0026quot; \u0026quot;Female\u0026quot;  Mais útil que isso, é possível predizer o sexo de nomes contidos numa base de dados, adicionando o resultado dessa predição numa nova variável. Exemplo:\nbase \u0026lt;- data.frame(nome = c(\u0026quot;Ana Maria\u0026quot;, \u0026quot;Roberto Silva\u0026quot;, \u0026quot;Marcia Campos\u0026quot;), idade = c(25, 42, 33), grupo = c(\u0026quot;A\u0026quot;, \u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;) ) base$sexo \u0026lt;- get_gender(base$nome) base  ## nome idade grupo sexo ## 1 Ana Maria 25 A Female ## 2 Roberto Silva 42 A Male ## 3 Marcia Campos 33 B Female  Nos dois casos, as predições usam os dados internos ao pacote. Para desabilitar essa opção, fazendo requisições diretamente à API do IBGE, basta declarar como falso o argumento internal: get_gender(nomes, internal = FALSE). Como mostro na sequência, entretanto, usar essa opção consome muito mais tempo.\nO desempenho da nova versão do genderBR Quão rápido é predizer o sexo usando os dados internos do pacote genderBR? A título de ilustração, podemos comparar o tempo gasto para predizer o sexo daqueles 8 nomes do primeiro exemplo usando a API do IBGE, i.e. internal = FALSE, e os dados internos do pacote, internal = TRUE. Repeti essa operação 100 vezes com cada método, registrando o tempo gasto para concluir a predição em cada uma. Resultado: com os dados internos, o pacote leva cerca de 0.06 segundos para concluir a predição dos 8 nomes, em média; já usando a API do IBGE, o tempo necessário gira em torno de 1.4 segundos. Em outras palavras, o novo método adicionado ao pacote é cerca de 23 vezes mais rápido nesse exemplo.\nNa verdade, usar os dados internos é ainda mais rápido se levarmos em conta as pausas entre requisições, aplicadas pela função get_gender quando o número de nomes a serem consultados na API do IBGE excede 100. Além disso, os ganhos em escala do método interno são imensos porque ele consome quase o mesmo tempo para predizer o sexo de 100, 1000, ou 10000 nomes. Isso, de novo, não acontece ao usar a opção internal = FALSE para extrair dados da API do IBGE.\nEm resumo, predizer sexo a partir de nomes próprios com o genderBR ficou extremamente mais rápido.\nExemplo: sexo de autores de teses de Doutorado no Brasil Para exemplificar os usos do pacote genderBR, classifiquei o sexo de autores(as) de todas as 221990 teses de Doutorado defendidas no Brasil entre 1987 e 2016. Esses dados vêm do Banco de Teses e Dissertações da Capes, disponíveis no novo portal de dados abertos da instituição – onde também estão outros sobre a composição dos programas de pós-graduação no país, ou sobre a produção acadêmica de doscentes e discentes, por exemplo.\nO importante a notar é que a Capes disponibiliza apenas informações sobre instituição, área de avaliação e nome dos autores das teses defendidas no período, mas não o sexo de quem as defendeu.[2] É aí que entra o genderBR: usando os dados internos do pacote, predizer o sexo para todos os nomes na base leva menos de 5 segundos. Com essa informação, podemos criar um gráfico como esse.\nO gráfico acima ilustra bem o trabalho do genderBR: ele classificou a imensa maioria dos nomes como pertencendo a homens ou mulheres (96% do total). Ainda assim, como os dados disponibilizados pelo IBGE incluem apenas nomes com mais de 20 ocorrências no país, alguns na base da Capes, cerca de 3% deles, foram classificados como Desconhecido, o que indica que não encontraram correspondência. Em outros casos, nomes classificados podem ser tanto de homens quanto de mulheres – como Ariel, Darci, Noá e Elir, por exemplo –, dificultando a tarefa de atribuir sexo (os Unissex do gráfico). De qualquer forma, como é possível ver, ambos os casos são residuais.\nVoltando ao gráfico, dá para notar que mulheres defenderam cerca de metade das teses registradas no banco da Capes no período. Entretanto, como o número de defesas era pequeno até os anos 2000 – em 1987, por exemplo, apenas 939 teses defendidas foram registradas, e mesmo em 2000 esse número ainda era de apenas 5344 –, acompanhar o crescimento absoluto, ano a ano, dessa série dificulta detectar tendências. Por essa razão, podemos focar apenas na percentagem de teses defendidas por mulheres, excluindo da base pessoas com sexo classificado como Desconhecido ou Unissex.\nA tendência geral, agora, é clara: com o passar do tempo, mulheres aumentaram sua participação na defesa de teses no Brasil.\nDefesas de tese por grandes áreas O mesmo padrão, entretanto, certamente varia entre áreas: pode ser que mulheres defendam mais teses em algumas grandes áreas da Capes, menos em outras. Como o Banco de Teses contém variáveis indicando essas grandes áreas, verificar isso é relativamente simples.\nPor um lado, mulheres defendem mais teses no Brasil, ao menos nos últimos anos. Por outro lado, é possível ver que essa participação é desigual entre grandes áreas da Capes: mulheres defendem mais teses nas Ciências Biológicas, nas Humanas e nas Letras; homens, entretanto, estão sobrerrepresentados nas áreas de Engenharia e Exatas. O gradual aumento no número de mulheres defendendo teses não ocorreu nessas duas últimas.\nDefesas de tese por área de avaliação Enquanto que classificar o sexo de autores(as) de teses por grande área revela um cenário detalhado da participação de mulheres, é possível ir além com os dados da Capes. Em especial, podemos usar a classificação por área de avaliação, que é usada para classificar os programas de pós-graduação no país. Aqui, vou fazer isso para algumas dessas: para a Ciência Política, separadamente, e em algumas outras, mais próximas dessa. Os resultados, também aqui, mostram que mulheres participam mais na produção e defesa de teses em algumas áreas; já em outras, inclusa a Ciência Política, a presença delas fica aquém – às vezes muito aquém – da de homens.\nFinal Classificar por sexo autores(as) de teses no Brasil é apenas uma das utilidades do genderBR. Usando as mesmas fontes de dados, na verdade, é possível investigar as causas da variação na participação de homens e mulheres na produção de teses; mapear a distribuição de docentes e discentes por sexo em todos os programas de pós-graduação; ou, ainda, aplicar o mesmo método para classificar qualquer outro tipo de produção por sexo do(a) autor(a). Isso tudo, note-se, apenas com os dados da Capes, o que está longe de esgotar todas as aplicações possíveis do pacote.\nA mensagem mais geral desse texto, entretanto, é outra: com a nova atualização, usar o genderBR para predizer sexo a partir de nomes próprios ficou muito mais rápido. Como o exemplo anterior indica, isso pode ser feito em poucos segundos mesmo em bases de dados grandes; quando os nomes próprios estão formatados de diferentes maneiras; e levando em conta diferenças no uso de nomes por sexo entre estados (ver aqui) – nesse caso, usando a API do IBGE. Como já discuti no texto da versão anterior do pacote, as predições do genderBR, além disso, são bastante precisas: nos testes que realizei, o método prediz o sexo a partir de um nome de forma correta mais de 99% das vezes, além de produzir poucos missings, como no caso do exemplo anterior. Tudo somado, o genderBR não só é incomparavelmente mais rápido do que classificar manualmente sexo a partir de nomes, mas também mais recomendado para evitar erros de imputação e contribuir para a replicabilidade de qualquer pesquisa que o use.\nDados e cógido Os dados e o código usados nesse posto podem ser encontrados aqui. Como o pacote genderBR é open source, o que significa que qualquer um pode consultar ou trabalhar em cima do seu código, disponível no GitHub. Críticas e sugestões são bem-vindos.\n A única ressalva, aqui, é que esse método só está disponível quando outro argumento, state, não é declarado. Com isso, apenas pela API do IBGE é possível obter predições considerando variação entre estados.\n Os dados do Banco de Teses e Dissertações da Capes têm muitos problemas, como missings, campos preenchidos de forma incorreta, incosistência de classificação em alguns anos, entre outros. Como meu objetivo é apenas exemplificar o pacote, fiz uma limpeza superficial na base. Os dados e o código usados nesse post, de qualquer forma, podem ser encontrados aqui.\n  ","date":1524096000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1524096000,"objectID":"d9d06b60fd31ab77a7f83551c49c2796","permalink":"https://fmeireles.com/blog/rstats/predizendo-sexo-nomes-proprios-genderbr/","publishdate":"2018-04-19T00:00:00Z","relpermalink":"/blog/rstats/predizendo-sexo-nomes-proprios-genderbr/","section":"post","summary":"Para quem trabalha com bases de dados públicas, não é incomum encontrar o seguinte problema: ter disponível em alguma coluna o nome de várias pessoas, mas não a informação sobre o sexo delas. Para lidar com esse problema, há alguns meses desenvolvi um pacote para R, o genderBR, que oferece um método simples para resolvê-lo: usando dados do Censo de 2010 do IBGE, ele inferie o sexo de uma pessoa a partir de seu nome próprio (como descrito em maiores detalhes aqui).","tags":[],"title":"Predizendo sexo a partir de nomes próprios com o genderBR","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","genderbr"],"content":" Várias questões importantes nas Ciências Sociais estão ligadas ao sexo das pessoas. Se quisermos saber se mulheres recebem menores salários, se estão sub-representadas na política, se sofrem mais com as violências urbana e doméstica, entre outros, precisamos identificar o sexo das pessoas que investigamos. Entretanto, esse dado nem sempre é fácil de obter: vários bancos usados para responder às perguntas acima não contêm informações sobre o sexo das pessoas estudadas \u0026ndash; embora alguns destes contenham outras que podem ser usada para inferir seus sexos.\nO pacote genderBR para o R, que acabou de ser publicado no CRAN, serve para isso: ele usa uma informação relativamente simples de obter \u0026ndash; nome próprio \u0026ndash; e, a partir dela, prediz o sexo de uma pessoa com dados do Censo de 2010 realizado pelo IBGE. Se o nome João, por exemplo, é usado majoritariamente por individuos do sexo masculino no Brasil, temos alguma confiança em dizer que outro brasileiro qualquer com o mesmo nome provavelmente também seja do sexo masculino. Entre outras vantagens, este método é replicável, baseado em dados públicos e, o que é mais importante, muito mais rápido do que qualquer classificação manual de sexos a partir de nomes próprios. O passo-a-passo a seguir exemplifica isso.\nComo instalar Como o pacote genderBR está no CRAN e, portanto, pode ser instalado diretamente pelo R com:\ninstall.packages(\u0026quot;genderBR\u0026quot;)  Ou, para versões beta do pacote, ele pode ser instalado com devtools:\nif(!require(\u0026quot;devtools\u0026quot;)) install.packages(\u0026quot;devtools\u0026quot;) devtools::install_github(\u0026quot;meirelesff/genderBR\u0026quot;)  Feito isso, para usar o pacote, basta carregá-lo:\nlibrary(genderBR)  Como usar O pacote genderBR possui uma função principal, get_gender, que prediz o sexo de uma pessoa baseado no seu primeiro nome (com ou sem letras maiúsculas, acentos e sobrenomes), como no exemplo abaixo:\nget_gender(\u0026quot;maria\u0026quot;)  ## [1] \u0026quot;Female\u0026quot;  get_gender(\u0026quot;MARIA\u0026quot;)  ## [1] \u0026quot;Female\u0026quot;  get_gender(\u0026quot;Maria da Silva Conceição\u0026quot;)  ## [1] \u0026quot;Female\u0026quot;  A função funciona igualmente com um vetor de nomes:\nget_gender(c(\u0026quot;isabel\u0026quot;, \u0026quot;marta\u0026quot;, \u0026quot;silvia\u0026quot;, \u0026quot;rodrigo\u0026quot;, \u0026quot;roberto\u0026quot;, \u0026quot;thiago\u0026quot;))  ## [1] \u0026quot;Female\u0026quot; \u0026quot;Female\u0026quot; \u0026quot;Female\u0026quot; \u0026quot;Male\u0026quot; \u0026quot;Male\u0026quot; \u0026quot;Male\u0026quot;  Resumidamente, esta chamada envia uma requisição GET a API do Censo 2010 (que pode demorar a responder), calcula a proporção de mulheres que possuem o nome passado e, então, faz uma predição baseado num ponto de corte: por padrão, se mais de 0.9 das pessoas com o nome passado são do sexo feminino, segundo o Censo de 2010, a função prediz o sexo deste nome como Female; se mais 0.9 das pessoas com esse nome forem do sexo masculino, a predição será Male; por fim, nomes com proporções menores que 0.9 ou não encontrados na base do IBGE são classificados como missing (e.g., NA) Exemplos:\n# Male get_gender(\u0026quot;joao\u0026quot;)  ## [1] \u0026quot;Male\u0026quot;  # NA get_gender(\u0026quot;muriel\u0026quot;)  ## [1] NA  # NA get_gender(\u0026quot;ashdfjg\u0026quot;)  ## [1] NA  É possível modificar a proporção usada para classificar corretamente um nome. Por exemplo, podemos considerar como do sexo masculino apenas pessoas cujo primeiro nome seja usado por 0.95 (95%) de pessoas identificadas como do sexo masculino pelo IBGE:\nget_gender(\u0026quot;augusto\u0026quot;, threshold = 0.95)  ## [1] \u0026quot;Male\u0026quot;  Além deste resulto básico, a função get_gender também permite saber a proporção de mulheres que usam um dado primeiro nome no país \u0026ndash; com isto, é possível usar qualquer outra medida para predizer o sexo de uma pessoa. No exemplo abaixo, percebe-se que a probabilidade de alguém com o nome Muriel ser do sexo feminino no universo de entrevistados do Censo de 2010 é igual a 43%.\nget_gender(\u0026quot;muriel\u0026quot;, prob = TRUE)  ## [1] 0.4303515  Por fim, podemos obter os resultados por estado \u0026ndash; partido da ideia de que o uso de um dado nome próprio entre sexos pode variar de região para região. Um bom exemplo é o do político goiano Iris Rezende, casado com sua xará Iris de Araújo.\n# Probabilidade do nome Iris ser usado por uma mulher em SP get_gender(\u0026quot;iris\u0026quot;, prob = TRUE, state = \u0026quot;SP\u0026quot;)  ## [1] 0.9491027  # Probabilidade do nome Iris ser usado por uma mulher em GO get_gender(\u0026quot;iris\u0026quot;, prob = TRUE, state = \u0026quot;GO\u0026quot;)  ## [1] 0.5  Como o exemplo acima mostra, o nome Iris é muito mais comum para pessoas do sexo masculino em Goiás do que em São Paulo.\nOutras funções Além da função get_gender, o pacote genderBR possui outras duas funções que podem ser úteis em algumas situações. A primeira delas, get_states, serve para retornar um data.frame com o nome, a sigla e o código do IBGE de todos os estados brasileiros, o que pode ajudar nas consultas à função get_gender.\nJá a segunda função, map_gender, serve para mapear os usos de um nome qualquer entre todos os estados do Brasil:\nmap_gender(\u0026quot;mario\u0026quot;, gender = \u0026quot;f\u0026quot;)  ## # A tibble: 19 x 6 ## nome uf freq populacao sexo prop ## * \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; ## 1 Amazonas 13 60 3483985 f 1.72 ## 2 Piauí 22 30 3118360 f 0.96 ## 3 Rio de Janeiro 33 140 15989929 f 0.88 ## 4 Rio Grande do Norte 24 23 3168027 f 0.73 ## 5 São Paulo 35 293 41262199 f 0.71 ## 6 Ceará 23 56 8452381 f 0.66 ## 7 Santa Catarina 42 41 6248436 f 0.66 ## 8 Mato Grosso 51 19 3035122 f 0.63 ## 9 Pernambuco 26 54 8796448 f 0.61 ## 10 Maranhão 21 40 6574789 f 0.61 ## 11 Pará 15 46 7581051 f 0.61 ## 12 Espírito Santo 32 21 3514952 f 0.60 ## 13 Bahia 29 84 14016906 f 0.60 ## 14 Alagoas 27 17 3120494 f 0.54 ## 15 Paraíba 25 20 3766528 f 0.53 ## 16 Paraná 41 55 10444526 f 0.53 ## 17 Rio Grande do Sul 43 48 10693929 f 0.45 ## 18 Minas Gerais 31 79 19597330 f 0.40 ## 19 Goiás 52 20 6003788 f 0.33  Nela, basta passar as letras f, para Female, ou m, para Male, e a função retorna o total de pessoas em cada estado com o nome fornecido, além do total de usos daquele nome no sexo indicado.\nAvaliando as predições O método é confiável? Depois de ter feitos alguns testes, a precisão média do método sempre foi maior que 95%, sem sinal de viés. Aqui, vou exemplificar isso com um exemplo simples: os dados de candidaturas do TSE (extraídos com o electionsBR).\nBasicamente, candidatos a cargos eletivos no Brasil reportam seus sexos no formulário de registro de suas candidaturas, informação que, posteriormente, é disponibilizada pelo TSE. Apesar de possíveis erros de mensuração \u0026ndash; afinal, estes dados são auto-reportados e, como tal, estão sujeitos até mesmo a erros de imputação \u0026ndash;, o genderBR faz um bom trabalho de classificar o sexo dos 104122 candidatos a cargos federais nas cinco eleições entre 1998 e 2014, como mostra a tabela abaixo.\n   Sexo declarado Sexo predito N %     Male Female 410 0.5%   Male Male 79485 95.5%   Male Unissex 1121 1.3%   Male Unknown 2201 2.6%   Female Female 19796 94.7%   Female Male 106 0.5%   Female Unissex 348 1.7%   Female Unknown 655 3.1%    Especificamente, o método classificou 99.5% das observações corretamente (desconsiderando os missings, que são mostrados aqui como Unissex, quando a proporção de usos do nome pelo sexo feminino ou masculino é menor que 0.9, ou Unknown, quando o nome não foi encontrado na base do TSE), e apenas 2.74% ficaram como missing. No geral, portanto, o método funciona.\n","date":1504569600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1504569600,"objectID":"08f8bead4e0605e66cbfbfade09d1a6d","permalink":"https://fmeireles.com/blog/rstats/genderbr-predizer-sexo/","publishdate":"2017-09-05T00:00:00Z","relpermalink":"/blog/rstats/genderbr-predizer-sexo/","section":"post","summary":"Várias questões importantes nas Ciências Sociais estão ligadas ao sexo das pessoas. Se quisermos saber se mulheres recebem menores salários, se estão sub-representadas na política, se sofrem mais com as violências urbana e doméstica, entre outros, precisamos identificar o sexo das pessoas que investigamos. Entretanto, esse dado nem sempre é fácil de obter: vários bancos usados para responder às perguntas acima não contêm informações sobre o sexo das pessoas estudadas \u0026ndash; embora alguns destes contenham outras que podem ser usada para inferir seus sexos.","tags":[],"title":"genderBR: predizendo sexo a partir de nomes próprios","type":"post"},{"authors":["Fernando Meireles","Luciana Andrade"],"categories":null,"content":"","date":1504234800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1504234800,"objectID":"796ba525c1355a793494a294a36d8692","permalink":"https://fmeireles.com/publication/magnitude-eleitoral-mulheres/","publishdate":"2017-09-01T00:00:00-03:00","relpermalink":"/publication/magnitude-eleitoral-mulheres/","section":"publication","summary":"É argumento corrente na literatura sobre representação política de mulheres que sistemas mais proporcionais aumentam as chances de mulheres serem eleitas. O objetivo deste artigo é testar esta hipótese usando dados dos municípios brasileiros. Explorando uma regra estabelecida pelo Tribunal Superior Eleitoral em 2004 e 2008, que fixou o número de vereadores de cada município de acordo com o número de habitantes, utilizamos regressão descontínua (RD) para estimar o efeito causal de uma cadeira a mais na representação política de mulheres nas câmaras municipais. Nossos resultados mostram que este efeito é substantivo: onde havia uma cadeira adicional, quase 40% mais mulheres foram eleitas, e a probabilidade de um município eleger ao menos uma mulher aumentou em cerca de 20 pontos percentuais. Por outro lado, a explicação deste fenômeno contraria as hipóteses da literatura: especificamente, mostramos que uma cadeira a mais aumentou apenas o número de candidatos homens concorrendo, o que fragmentou suas votações e os deixou com desempenhos eleitorais piores. Deste modo, mesmo não tendo suas votações afetadas pelo número de cadeiras, mais mulheres acabaram eleitas.","tags":[],"title":"Magnitude eleitoral e representação de mulheres nos municípios brasileiros","type":"publication"},{"authors":["Fernando Meireles"],"categories":["rstats","electionsBR"],"content":" O pacote do R para baixar e limpar dados eleitorais do TSE criado pelo Denisson Silva, Beatriz Costa e eu, o electionsBR, acaba de ganhar uma grande atualização, já disponível no CRAN: para a versão 0.3.0[1]. Para quem não o conhece, basicamente ele automatiza o trabalho de baixar, deszipar, tratar e limpar dados eleitorais brasileiros diretamente do Repositório de Dados Eleitorais do TSE \u0026ndash; tudo acompanhado de extensa documentação baseada em informações oficiais. Em outras palavras, com ele é possível extrair quase todos os dados públicos de resultados eleitorais, apuração, partidos, coligações, candidaturas, de perfil dos eleitores, entre outros, diretamente pelo R, e isto em pouquíssimo tempo.\nNesta nova versão, estendemos as funcionalidades do pacote em vários pontos, mas sem comprometer a forma com que ele já funcionava. Segue, em forma de lista, as novidades do pacote.\nVelocidade O electionsBR já era extremamente rápido (em poucos segundos ele é capaz de baixar e processar centenas de milhares de informações do website do TSE), especialmente comparado à tarefa manual de baixar separadamente os arquivos do TSE, tratar e limpar cada um para, enfim, unir todos numa base única.\nNessa versão, melhoramos esse desempenho ainda mais: alteramos internamente as formas de leitura e união dos arquivos por meio das funções fread e rbindlist do pacote data.table. Com isso, o pacote ficou cerca de 6x mais rápido do que já era.\nResultados por estado Anteriormente, só era possível pegar dados eleitorais para todo o Brasil com o pacote \u0026ndash; o que significa que, caso desejássemos ter resultados apenas para um ou mais estados, teríamos que extrair dados do país todo para, aí sim, filtrar as informações.\nAgora, a maioria das funções possui um argumento opcional chamado uf, que serve para indicar estados para os quais queremos dados \u0026ndash; e isto de forma eficiente, sem ter de processar informações dos demais estados. Para pegar dados sobre as candidaturas (nome, sexo, partido, número de urna, profissão, entre outros, dos[as] candidatos[as]) nas eleições federais de 2010 apenas em Minas Gerais, por exemplo, podemos fazer isso:\n# Instala a nova versão do pacote # (é preciso descomentar a linha abaixo) # install.packages(\u0026quot;electionsBR\u0026quot;) # Carrega o pacote library(electionsBR) # Pega dados de candidaturas em 2010 apenas para Minas Gerais mg2010 \u0026lt;- candidate_fed(2010, uf = \u0026quot;MG\u0026quot;) # Um panorama dos dados mg2010  ## # A tibble: 1,789 × 43 ## DATA_GERACAO HORA_GERACAO ANO_ELEICAO NUM_TURNO DESCRICAO_ELEICAO ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010 ## 2 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010 ## 3 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010 ## 4 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010 ## 5 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010 ## 6 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010 ## 7 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010 ## 8 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010 ## 9 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010 ## 10 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010 ## # ... with 1,779 more rows, and 38 more variables: SIGLA_UF \u0026lt;chr\u0026gt;, ## # SIGLA_UE \u0026lt;chr\u0026gt;, DESCRICAO_UE \u0026lt;chr\u0026gt;, CODIGO_CARGO \u0026lt;chr\u0026gt;, ## # DESCRICAO_CARGO \u0026lt;chr\u0026gt;, NOME_CANDIDATO \u0026lt;chr\u0026gt;, ## # SEQUENCIAL_CANDIDATO \u0026lt;chr\u0026gt;, NUMERO_CANDIDATO \u0026lt;chr\u0026gt;, ## # CPF_CANDIDATO \u0026lt;chr\u0026gt;, NOME_URNA_CANDIDATO \u0026lt;chr\u0026gt;, ## # COD_SITUACAO_CANDIDATURA \u0026lt;chr\u0026gt;, DES_SITUACAO_CANDIDATURA \u0026lt;chr\u0026gt;, ## # NUMERO_PARTIDO \u0026lt;chr\u0026gt;, SIGLA_PARTIDO \u0026lt;chr\u0026gt;, NOME_PARTIDO \u0026lt;chr\u0026gt;, ## # CODIGO_LEGENDA \u0026lt;chr\u0026gt;, SIGLA_LEGENDA \u0026lt;chr\u0026gt;, COMPOSICAO_LEGENDA \u0026lt;chr\u0026gt;, ## # NOME_COLIGACAO \u0026lt;chr\u0026gt;, CODIGO_OCUPACAO \u0026lt;chr\u0026gt;, DESCRICAO_OCUPACAO \u0026lt;chr\u0026gt;, ## # DATA_NASCIMENTO \u0026lt;chr\u0026gt;, NUM_TITULO_ELEITORAL_CANDIDATO \u0026lt;chr\u0026gt;, ## # IDADE_DATA_ELEICAO \u0026lt;chr\u0026gt;, CODIGO_SEXO \u0026lt;chr\u0026gt;, DESCRICAO_SEXO \u0026lt;chr\u0026gt;, ## # COD_GRAU_INSTRUCAO \u0026lt;chr\u0026gt;, DESCRICAO_GRAU_INSTRUCAO \u0026lt;chr\u0026gt;, ## # CODIGO_ESTADO_CIVIL \u0026lt;chr\u0026gt;, DESCRICAO_ESTADO_CIVIL \u0026lt;chr\u0026gt;, ## # CODIGO_NACIONALIDADE \u0026lt;chr\u0026gt;, DESCRICAO_NACIONALIDADE \u0026lt;chr\u0026gt;, ## # SIGLA_UF_NASCIMENTO \u0026lt;chr\u0026gt;, CODIGO_MUNICIPIO_NASCIMENTO \u0026lt;chr\u0026gt;, ## # NOME_MUNICIPIO_NASCIMENTO \u0026lt;chr\u0026gt;, DESPESA_MAX_CAMPANHA \u0026lt;chr\u0026gt;, ## # COD_SIT_TOT_TURNO \u0026lt;chr\u0026gt;, DESC_SIT_TOT_TURNO \u0026lt;chr\u0026gt;  Também é possível pegar dados de mais de um estado por vez passando um vetor para a função:\n# Pega dados de estados da região sul sul \u0026lt;- candidate_fed(2010, uf = c(\u0026quot;RS\u0026quot;, \u0026quot;SC\u0026quot;, \u0026quot;PR\u0026quot;))  As siglas dos estados podem ser passadas em maiúsculo, minúsculo ou combinação dos dois: MG, mg, Mg ou mG são todos inputs igualmente válidos.\nPercentual de votos Para além das funções que o pacote já tinha (ver aqui uma descrição de todas as funções disponíveis), incluímos quatro funções para facilitar a extração de resultados eleitorais, que já retornam o percentual de votos válidos (nominais e de legenda somados) de cada partido nas eleições presidenciais, para o Senado e para a Câmara Federal agregados por estado ou por município. Estas funções são, respectivamente:\n president_mun_vote, para votação percentual nas eleições presidenciais no segundo turno por município; president_state_vote, para votação percentual nas eleições presidenciais no segundo turno por estado; legislative_mun_vote, para votação percentual nas eleições legislativas federais (Senado e Câmara) por município; legislative_state_vote, para votação percentual nas eleições legislativas federais (Senado e Câmara) por município.  No caso das eleições legislativas, as funções aceitam um argumento opcional, house indicando a casa a ser analisada, se Senado ou Câmara (senate ou chamber).\nPor exemplo, o código abaixo pega os resultados presidenciais do segundo turno de 2014 por estado:\npres \u0026lt;- president_state_vote(2010)  E o abaixo pega o total de votos percentuais de cada partido na disputa para a Câmara Federal em 2010, por estado:\ncam \u0026lt;- legislative_state_vote(2010, house = \u0026quot;chamber\u0026quot;)  Vagas em disputa Também acrescentamos uma função para coletar dados sobre o número de cadeira para cada cargo em disputa (seats_fed, para eleições federais, e seats_local, para eleições municipais). Para saber quantas vagas nas Câmara municipais estavam disponíveis em cada município em 2016, por exemplo, use:\nvagas \u0026lt;- seats_local(2016)  Exportar dados para Stata e SPSS Para quem não usa, ou não tem tanta familiaridade com o R, incluímos uma opção para exportar os dados pegos pelas funções do pacote para arquivos .dta e .sav, que podem ser analisados pelo Stata e pelo SPSS, respectivamente. O argumento opcional para fazer isso é o export, que, por padrão, é igual a FALSE. Para exportar os resultados das funções, é só passar ele para TRUE:\n# Resultados eleitorais federais de 2010, agregados por zona eleitoral df \u0026lt;- vote_mun_zone_fed(2010, export = TRUE) # Resultados eleitorais municipais de 2012, agregados por zona eleitoral df2 \u0026lt;- vote_mun_zone_local(2012, export = TRUE)  Siglas de estados e partidos Para consultar uma lista de siglas de estados e partidos, que pode ser útil para filtrar resultados, use:\n# Sigla dos estados brasileiros uf_br()  ## [1] \u0026quot;AC\u0026quot; \u0026quot;AL\u0026quot; \u0026quot;AM\u0026quot; \u0026quot;AP\u0026quot; \u0026quot;BA\u0026quot; \u0026quot;CE\u0026quot; \u0026quot;DF\u0026quot; \u0026quot;ES\u0026quot; \u0026quot;GO\u0026quot; \u0026quot;MA\u0026quot; \u0026quot;MG\u0026quot; \u0026quot;MS\u0026quot; \u0026quot;MT\u0026quot; \u0026quot;PA\u0026quot; ## [15] \u0026quot;PB\u0026quot; \u0026quot;PE\u0026quot; \u0026quot;PI\u0026quot; \u0026quot;PR\u0026quot; \u0026quot;RJ\u0026quot; \u0026quot;RN\u0026quot; \u0026quot;RO\u0026quot; \u0026quot;RR\u0026quot; \u0026quot;RS\u0026quot; \u0026quot;SC\u0026quot; \u0026quot;SE\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;TO\u0026quot;  # Sigla dos partidos que disputaram a eleicao de 2016 parties_br()  ## [1] \u0026quot;PPS\u0026quot; \u0026quot;PSB\u0026quot; \u0026quot;PSOL\u0026quot; \u0026quot;PP\u0026quot; \u0026quot;PSL\u0026quot; \u0026quot;PR\u0026quot; \u0026quot;PSDB\u0026quot; ## [8] \u0026quot;PDT\u0026quot; \u0026quot;PSDC\u0026quot; \u0026quot;PHS\u0026quot; \u0026quot;PT\u0026quot; \u0026quot;PROS\u0026quot; \u0026quot;PTC\u0026quot; \u0026quot;PSC\u0026quot; ## [15] \u0026quot;PC do B\u0026quot; \u0026quot;PRB\u0026quot; \u0026quot;PMDB\u0026quot; \u0026quot;DEM\u0026quot; \u0026quot;PMB\u0026quot; \u0026quot;PTB\u0026quot; \u0026quot;PEN\u0026quot; ## [22] \u0026quot;PTN\u0026quot; \u0026quot;SD\u0026quot; \u0026quot;PMN\u0026quot; \u0026quot;PT do B\u0026quot; \u0026quot;PSD\u0026quot; \u0026quot;PV\u0026quot; \u0026quot;PRP\u0026quot; ## [29] \u0026quot;REDE\u0026quot; \u0026quot;PPL\u0026quot; \u0026quot;PRTB\u0026quot; \u0026quot;PSTU\u0026quot; \u0026quot;PCB\u0026quot; \u0026quot;PCO\u0026quot; \u0026quot;NOVO\u0026quot;  Tutoriais Para quem deseja ver um tutorial mais completo do funcionamento do electionsBR, adicionamos uma vignette ao pacote, que pode ser visto em:\n http://electionsbr.com/articles/index.html  Na mesma página, também existem outros tutoriais sobre em inglês e em português.\nWebsite Por fim, em vez de ter toda a documentação espalhada por aí, reunimos tudo num único website, que agora é também o site oficial do projeto.\n http://electionsbr.com  [1] Para instalar a nova versão, basta abrir o R e executar no console o seguinte código: install.packages(\u0026quot;electionsBR\u0026quot;).\n","date":1496880000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1496880000,"objectID":"9519854d8b6af5857ff5dc0f868789d4","permalink":"https://fmeireles.com/blog/rstats/electionsbr-versao-0.3.0/","publishdate":"2017-06-08T00:00:00Z","relpermalink":"/blog/rstats/electionsbr-versao-0.3.0/","section":"post","summary":"O pacote do R para baixar e limpar dados eleitorais do TSE criado pelo Denisson Silva, Beatriz Costa e eu, o electionsBR, acaba de ganhar uma grande atualização, já disponível no CRAN: para a versão 0.3.0[1]. Para quem não o conhece, basicamente ele automatiza o trabalho de baixar, deszipar, tratar e limpar dados eleitorais brasileiros diretamente do Repositório de Dados Eleitorais do TSE \u0026ndash; tudo acompanhado de extensa documentação baseada em informações oficiais.","tags":[],"title":"electionsBR: versão 0.3.0","type":"post"},{"authors":["Fernando Meireles","Denisson Silva","Filipe Correa"],"categories":null,"content":"","date":1493607600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1493607600,"objectID":"3b43a4d218d16162927477f5609a8955","permalink":"https://fmeireles.com/publication/monte-carlo-ciencia-politica/","publishdate":"2017-05-01T00:00:00-03:00","relpermalink":"/publication/monte-carlo-ciencia-politica/","section":"publication","summary":"Ensinar como mecanismos causais ou modelos estatísticos funcionam nem sempre é algo simples, especialmente quando estes não podem ser facilmente exemplificados. O objetivo deste artigo é mostrar como Simulações de Monte Carlo (SMC) podem ser usadas para superar dificuldades como estas. Após fazermos uma breve introdução ao método, mostramos como utilizá-lo, a fim de ilustrar fenômenos de difícil mensuração ou conceitos abstratos; além disso, também mostramos como ele pode ser empregado para explicar intuitivamente a influência das violações de pressupostos sobre os resultados de alguns modelos estatísticos frequentemente utilizados na Ciência Política. Por fim, oferecemos um passo a passo para reproduzir nossos exemplos utilizando o software R, além de um simples aplicativo virtual (Shiny app) com estes exemplos, de modo a ser adaptado para uso em sala de aula.","tags":[],"title":"Simulações de Monte Carlo no Ensino de Ciência Política","type":"publication"},{"authors":["Fernando Meireles"],"categories":["rstats","electionsbr"],"content":" Obter dados eleitorais no Brasil nunca foi uma tarefa das mais fáceis. Quem já precisou fazer isso provavelmente sabe o tamanho do problema: baixar diversos arquivos, deszipá-los, abrir um a um os arquivos brutos, limpar e arrumar os dados, juntar tudo, exportar, e por aí vai. Foi com isso na cabeça que o Denisson, a Beatriz e eu lançamos, nos idos de agosto, o electionsBR - um pacote para baixar e limpar estes dados automaticamente, direto do Repositório de Dados Eleitorais do TSE. Passado algum tempo, e depois dos diversos feedbacks que recebemos, lançamos agora uma nova versão do electionsBR, já disponível no CRAN[1]: a 0.2.0.\nResumidamente, além de todas as funcionalidades existentes na versão anterior (era possível baixar quase todos os dados disponíveis do TSE e armazená-los em objetos na memória no R em segundos; para saber mais sobre a versão anterior, clique aqui), ampliamos a cobertura dela com diversos reparos e acréscimos. Destes, três se destacam:\n Novas funções - Incluímos duas novas funções, voter_affiliation e voter_profile, que coletam e limpam dados de filiação e de perfil demográfico dos(as) eleitores(as), respectivamente. Com elas, é possível saber, por exemplo, quantos(as) filiados(as) um partido possui em cada estado; nome, sexo, data de filiação e situação cadastral destes(as) filiados(as); o número de eleitores(as) registrados(as) em cada eleição desde 1998; além do sexo, faixa etária e grau de escolaridade dos(as) votantes. No R, basta digitar ?voter_affiliation, ou ?voter_profile, para acessar a documentação completa destas funções.\n Controle de acentos - Seguindo uma sugestão dada pelo Robert McDonnel, adicionamos um argumento chamado ascii em todas as funções. Basicamente, este remove acentos das informações do TSE - o que pode ser útil para computadores que não têm suporte para acentos latinos ou evitar erros em algumas operações com strings (comparar nomes, por exemplo). Para remover acentos, só é necessário usar ascii = TRUE.\n Inclusão das eleições de 2016 - Agora também é possível obter os dados eleitorais das eleições municipais de 2016 pelo pacote (esta atualização, na verdade, já havia sido feito na versão beta, disponível no GitHub, por boa sugestão do Guilherme Duarte). Todas as funções que coletam dados de eleições municipais (como candidate_local ou legend_local, por exemplo) aceitam esta opção: o usuário precisa apenas passar 2016 para o argumento year destas funções (e.g., legend_local(year = 2016)).\n  Tudo isto para que o electionsBR dê mais opções ao usuário: qual dado eleitoral ele quer (agora, sim, o pacote cobre quase todos os dados); como ele quer as informações (com ou sem acentos) e para qual período (incluso as eleições de 2016).\nOutras novidades Além destas três melhorias, também alteramos outros aspectos do electionsBR. Em primeiro lugar, corrigimos alguns problemas no código da versão anterior que geravam erros. Em segundo lugar, e em parte por causa dessas correções, também tivemos de modificar a documentação técnica do pacote para registrar as alterações feitas; nesta nova versão, portanto, mais detalhes passaram a ser abordados na documentação oficial do pacote (disponível neste link). Por fim, removemos algumas funções internas (i.e. menos confusão para os usuários) e deixamos todas as funções externas mais flexíveis (é possível, por exemplo, customizar o encoding dos dados do TSE; para isso, basta definir o argumento, como enconding = \u0026quot;UTF-8\u0026quot;, ou enconding = \u0026quot;windows-1252\u0026quot;).\nApesar destas mudanças, contudo, o funcionamento do pacote permanece o mesmo. Para baixar dados eleitorais, tanto com a versão anterior quanto com essa, só é necessário carregar o pacote numa sessão do R e chamar a função desejada. Um mini-exemplo:\n# Instala a nova versao do electionsBR install.packages(\u0026quot;electionsBR\u0026quot;) # Carrega o pacote library(\u0026quot;electionsBR\u0026quot;) # Baixa dados de filiacao individuais do PT no estado de Sao Paulo x \u0026lt;- voter_affiliation(party = \u0026quot;PT\u0026quot;, uf = \u0026quot;SP\u0026quot;) # Baixa os mesmos dados, agora sem acentos nas informacoes textuais x \u0026lt;- voter_affiliation(party = \u0026quot;PT\u0026quot;, uf = \u0026quot;SP\u0026quot;, ascii = TRUE) # Baixa dados de filiacao individuais do PT e do PSDB nos estados de Minas Gerais e Bahia x \u0026lt;- voter_affiliation(party = c(\u0026quot;PT\u0026quot;, \u0026quot;PSDB\u0026quot;), uf = c(\u0026quot;MG\u0026quot;, \u0026quot;BA\u0026quot;))  O electionsBR Para quem descobriu o pacote agora e/ou quer saber mais, segue abaixo uma lista de outros exemplos e tutoriais de como usá-lo:\n electionsBR: o que é e como usar;\n Coletando e analisando dados de apuração eleitoral;\n Exportando dados eleitorais para o Stata;\n Criando mapas eleitorais;\n electionsBR: R Functions to Download and Clean Brazilian Electoral Data, (paper acadêmico do pacote, para quem precisa de uma referência mais detalhada).\n  Para publicações que usam o pacote, esta última fonte, o paper, pode ser citada. É possível obter a referência dela, tanto em texto já formatado quanto em BibTeX, pela função citation. Exemplo:\n# Gera a informacao bibliografica para citar o electionsBR citation(\u0026quot;electionsBR\u0026quot;)  ## ## To cite electionsBR in publications, please use: ## ## Meireles, F.; Silva, D.; Costa, B. (2016). electionsBR: R ## functions to download and clean Brazilian electoral data. ## Federal University of Minas Gerais (UFMG). Belo Horizonte, ## Brazil. http://fmeireles.com/files/electionsbr.pdf ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {electionsBR: {R} Functions to Download and Clean {B}razilian Electoral Data}, ## author = {Fernando Meireles and Denisson Silva and Beatriz Costa}, ## organization = {Federal University of Minas Gerais (UFMG)}, ## address = {Belo Horizonte, Brazil}, ## year = {2016}, ## url = {http://fmeireles.com/files/electionsbr.pdf}, ## }  Notas finais Como não poderia deixar de ser num projeto como este, nos beneficiamos muito da ajuda de diversas pessoas para fazer esta atualização. Em especial, nossos colegas do Centro de Estudos Legislativos Suzana Alves, Haína Coelho, Felipe Lima, Leonardo Ev, Lucas Gelape, Bruno Arcas, e também Bruno Reis e Carlos Ranulfo; e os já mencionados Guilherme e Robert, além do Daniel Falbel, Sillas Gonzaga e Flávio Barros (estes, pelo github) contribuíram com críticas e sugestões e, por isto, estamos indefinidamente em débito com todos(as).\n[1] CRAN, ou Comprehensive R Archive Network, é um repositório oficial de pacotes para o R.\n","date":1481587200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1481587200,"objectID":"5837dfd4506791abf43d26c82637da9b","permalink":"https://fmeireles.com/blog/rstats/electionsbr-uma-nova-versao/","publishdate":"2016-12-13T00:00:00Z","relpermalink":"/blog/rstats/electionsbr-uma-nova-versao/","section":"post","summary":"Obter dados eleitorais no Brasil nunca foi uma tarefa das mais fáceis. Quem já precisou fazer isso provavelmente sabe o tamanho do problema: baixar diversos arquivos, deszipá-los, abrir um a um os arquivos brutos, limpar e arrumar os dados, juntar tudo, exportar, e por aí vai. Foi com isso na cabeça que o Denisson, a Beatriz e eu lançamos, nos idos de agosto, o electionsBR - um pacote para baixar e limpar estes dados automaticamente, direto do Repositório de Dados Eleitorais do TSE.","tags":[],"title":"electionsBR: uma nova versão (0.2.0)","type":"post"},{"authors":["Fernando Meireles"],"categories":["politica","eleicoes"],"content":"Apesar das invariáveis críticas que os institutos de pesquisa recebem toda eleição (vide aqui, por exemplo)[1], neste segundo turno o desempenho deles, \u0026ndash; ao menos o de alguns deles \u0026ndash;, não deixou a desejar.\nComo já havia postado no Twitter, o instituto Ibope, por exemplo, acertou, dentro da margem de erro (os 3 ou 4 tradicionais pontos para mais ou para menos), os resultados em 15 das 18 capitais onde realizou pesquisa entre os dias 25 e 28 de outubro. Nos três casos onde chutou a bola fora, os erros foram pequenos \u0026ndash; caso de Porto Alegre, Florianópolis e Maceió. Apenas em uma capital, Aracaju, o Ibope errou o resultado da eleição, onde a previsão era de que o candidato do PSB, Valadares Filho, ficaria na frente de Edvaldo Nogueira, do PC do B, por 2% de votos válidos. Como a previsão já era de resultado apertado, e o instituto acertou o resultado dentro da margem, este é um caso residual entre as capitais pesquisadas.\nDois outros casos ilustram o desempenho dos institutos de pesquisa \u0026ndash; agora incluindo Datafolha, Paraná Eleitoral e CP2. Os gráficos abaixo mostram o retrospecto de todas as pesquisas feitas no segundo turno no Rio de Janeiro, onde Crivella (PRB) enfretou o Freixo (PSOL), e em Belo Horizonte, onde Leite (PSDB) competiu contra Kalil (PHS), por estes institutos. Nos gráficos, cada ponto é a percentagem de intenção de votos (incluindo, portanto, não-válidos) de cada candidato estimada por cada pesquisa (em outras palavras, cada data de pesquisa, no eixo X, representa uma pesquisa eleitoral); a curva (ou linha) representa a tendência geral destas pesquisas, estimadas via LOESS; e as áreas mais claras ao redor das curvas representam os intervalos de confiança de 95%.\nDuas coisas merecem comentários em relação a esses dados:\n Tendências são mais importantes do que resultados exatos: as intenções de votos dos quatro candidatos variaram ao longo do segundo turno; no caso de BH, o resultado inclusive se inverte no meio da campanha. Como consequência, tentar estimar o resultado final de uma eleição dias antes dela se encerrar poderia nos levar a cometer erros grotescos. Por outro lado, ao examinarmos a evolução da intenção de votos de cada candidato, temos um quadro mais claro da dinâmica das campanhas. Por exemplo, Freixo teve menos tempo de TV e recursos no primeiro turno no Rio, mas, como é possível verificar, seu desempenho oscilou pouco no período todo, ressalva feita à pequena tendência de crescimento no final do segundo turno. Só por isso, já teríamos bons indicíos de que não teríamos grandes reviravoltas ali, já que nos 30 dias anteriores isto não ocorreu. Ao contrário, em BH a ultrapassagem de Kalil em meados de outubro já indicava um movimento maior, constante, e foi inclusive comentado na mídia como um cenário mais incerto.\n Não se pode tomar o resultado de uma única pesquisa como indicativo do resultado final das eleições. Institutos de pesquisa fazem amostras diferentes, aplicam questionários em períodos e locais diferentes, usando metodologias e pessoal diferentes, e, apenas por isso, variações aleatórias (ruídos no meio do sinal que as pesquisas tentam detectar) são esperadas. Observando o gráfico de Belo Horizonte, isto fica evidente: algumas pesquisas, às vezes realizadas pouquíssimos dias antes ou depois de outras, são destoantes; e, o que é ainda mais problemático, quando dois candidatos aparecem muito próximos, como os dois concorrentes em BH, é difícil distinguir quem está na frente (caso também de Aracaju). Nestes casos, dois institutos diferentes podem atribuir a vitória a candidatos diferentes \u0026ndash; mesmo que não exista má fé por parte deles. Cautela, enfim, é sempre necessária ao se projetar os resultados de uma eleiçao com base em pesquisas eleitorais.\n  De resto, cabe notar que pesquisas eleitorais, com todos os seus defeitos, são extremamente úteis. Quando bem interpretadas e tomadas em conjunto, podem nos dizer com bastante grau de certeza os resultados de uma eleição \u0026ndash; vide o retrospecto do 538, nos EUA.\n[1] Eu mesmo já critiquei, e ainda tenho ressalvas contra, as pesquisas eleitorais brasileiras por conta do uso de amostra por quotas. Um bom resumo do sistema, e uma crítica às margens de erro que os intitutos calculam para elas, pode ser visto aqui.\n","date":1477872000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1477872000,"objectID":"35f289aef978886fee3e78bebbc69941","permalink":"https://fmeireles.com/blog/politica/o-desempenho-das-pesquisas-eleitorais-nas-eleicoes-de-2016/","publishdate":"2016-10-31T00:00:00Z","relpermalink":"/blog/politica/o-desempenho-das-pesquisas-eleitorais-nas-eleicoes-de-2016/","section":"post","summary":"Apesar das invariáveis críticas que os institutos de pesquisa recebem toda eleição (vide aqui, por exemplo)[1], neste segundo turno o desempenho deles, \u0026ndash; ao menos o de alguns deles \u0026ndash;, não deixou a desejar.\nComo já havia postado no Twitter, o instituto Ibope, por exemplo, acertou, dentro da margem de erro (os 3 ou 4 tradicionais pontos para mais ou para menos), os resultados em 15 das 18 capitais onde realizou pesquisa entre os dias 25 e 28 de outubro.","tags":[],"title":"Desempenho das pesquisas eleitorais no segundo turno","type":"post"},{"authors":["Fernando Meireles"],"categories":["politica","abstencao","eleicoes"],"content":"Aproveitando os dados do TSE-RS, que divulgou uma lista completa dos municípios que passaram pelo recadastramento biométrico até esse ano, resolvi investigar se a biometria realmente afetou as taxas de abstenção nestas eleições.\nO gráfico abaixo ilustra essa diferença entre municípios que passaram ou não pelo recadastramento. Como dá pra ver, a taxa de abstenção média nos municípios que passaram a usar o sistema de biometria cai visivelmente depois de 2014 no Rio Grande do Sul (quando a maior parte dos municípios fez o cadastramento).\nQuando removemos os efeitos temporais e entre casos via um modelo de regressão com efeitos fixos, este efeito fica ainda mais nítido:\nEspecificamente, o efeito estimado é de cerca de 4.5% (estimado com um modelo diff-in-diff), o que significa que, na média, a taxa de abstenção no estado estava inflada em quase 50% (ela foi de cerca de 10% em 2012 na média dos municípios, embora Porto Alegre e região tenham tido abstenção maior). Em outras palavras, removendo os eleitores fantasmas, a abstenção caiu quase pela metade.\n","date":1475798400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1475798400,"objectID":"06c6b58130b85b95e98f2587cca0d965","permalink":"https://fmeireles.com/blog/politica/desatualizacao-nas-bases-do-tse-abstencao-eleitoral/","publishdate":"2016-10-07T00:00:00Z","relpermalink":"/blog/politica/desatualizacao-nas-bases-do-tse-abstencao-eleitoral/","section":"post","summary":"Aproveitando os dados do TSE-RS, que divulgou uma lista completa dos municípios que passaram pelo recadastramento biométrico até esse ano, resolvi investigar se a biometria realmente afetou as taxas de abstenção nestas eleições.\nO gráfico abaixo ilustra essa diferença entre municípios que passaram ou não pelo recadastramento. Como dá pra ver, a taxa de abstenção média nos municípios que passaram a usar o sistema de biometria cai visivelmente depois de 2014 no Rio Grande do Sul (quando a maior parte dos municípios fez o cadastramento).","tags":[],"title":"Desatualização nas bases do TSE e abstenção eleitoral","type":"post"},{"authors":["Fernando Meireles"],"categories":["graficos","metodologia"],"content":"O método pode ser acessado aqui. O funcionamento dele é simples: ele fornece padrões de cores (i.e., paletas) que são visualmente distinguíveis e esteticamente atraentes, além de permitir que se escolham padrões perceptíveis para daltônicos e para impressão em preto e branco. Tudo isso numa interface amigável e intuitiva.\nPara saber mais sobre o método (que é científico - o que não é o mesmo que dizer que é infalível) utilizado para selecionar os padrões, clique aqui.\n","date":1473984000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1473984000,"objectID":"8515fb4f67817708e511a57618643458","permalink":"https://fmeireles.com/blog/graficos/como-escolher-cores-para-graficos-cientificamente/","publishdate":"2016-09-16T00:00:00Z","relpermalink":"/blog/graficos/como-escolher-cores-para-graficos-cientificamente/","section":"post","summary":"O método pode ser acessado aqui. O funcionamento dele é simples: ele fornece padrões de cores (i.e., paletas) que são visualmente distinguíveis e esteticamente atraentes, além de permitir que se escolham padrões perceptíveis para daltônicos e para impressão em preto e branco. Tudo isso numa interface amigável e intuitiva.\nPara saber mais sobre o método (que é científico - o que não é o mesmo que dizer que é infalível) utilizado para selecionar os padrões, clique aqui.","tags":[],"title":"Como escolher cores para gráficos cientificamente","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","metodologia"],"content":" Uma das coisas que dá dor de cabeça a usuários do Stata que migram para o R é a estimação de modelos estatísticos. Como o Stata já oferece, de forma simples, diversos modelos e opções para alterar as suas especificações, a migração para o R pode ser frustrante neste aspecto: muitas coisas simples no Stata, como incluir erros-padrão robustos ou efeitos fixos, geralmente demandam mais linhas de código (e chamada a vários pacotes) no R.\nNeste post, vou iniciar um pequeno guia para estimar regressões logísticas no R. O procedimento básico é bastante simples, como se poderá ver, mas alguns detalhes, como converter os coeficientes para razão de chance, envolvem algumas manhas adicionais.\nEstimando modelos logísticos: explorando dados do Titanic Antes de começar, precisamos de alguns dados para rodar um modelo logístico. Para isto, vou utilizar dados sobre os sobreviventes do Titanic, onde a variável de interesse (que usaremos como variável dependente nos modelos) é binária (ter sobrevivido, 1, ou não, 0). Esta base pode ser baixada aqui (meus tutoriais de como carregar dados no R, aqui e aqui), mas também podemos armazená-la num objeto diretamente no R via:\n# Salva a base de dados sobre os sobreviventes do Titanic titanic \u0026lt;- read.table(\u0026quot;http://web.univ-ubs.fr/lmam/blanche/data-titanic.txt\u0026quot;, sep = \u0026quot;,\u0026quot;, header = T)  Feito isto, podemos explorar um pouco a base. Em particular, ela possui 891 observações e 12 variáveis, que são:\nnames(titanic)  ## [1] \u0026quot;PassengerId\u0026quot; \u0026quot;Survived\u0026quot; \u0026quot;Pclass\u0026quot; \u0026quot;Name\u0026quot; \u0026quot;Sex\u0026quot; ## [6] \u0026quot;Age\u0026quot; \u0026quot;SibSp\u0026quot; \u0026quot;Parch\u0026quot; \u0026quot;Ticket\u0026quot; \u0026quot;Fare\u0026quot; ## [11] \u0026quot;Cabin\u0026quot; \u0026quot;Embarked\u0026quot;  O que mais nos interessa aqui é a variável binária Survived, que assume o valor de 1 para passageiros sobreviventes, e 0 para os não sobreviventes. Outras variáveis podem nos ajudar a explicá-la, como o sexo dos passageiros. Com alguns gráficos simples, podemos ter uma noção da relação entre estas duas variáveis:\n# Primeiro, carregamos o pacote ggplot2 (para gerar os graficos) library(ggplot2) # Geramos um grafico de barras para visualizar o numero de sobreviventes e nao sobreviventes ggplot(titanic, aes(x = as.factor(Survived))) + geom_bar() + theme_light() + labs(title = \u0026quot;Titanic\u0026quot;, x = \u0026quot;Sobreviventes\u0026quot;, y = \u0026quot;Frequência\u0026quot;)  # Por fim, cruzamos a variavel sexo com a variavel sobreviventes ggplot(titanic, aes(x = as.factor(Survived), fill = Sex)) + geom_bar() + theme_light() + labs(title = \u0026quot;Titanic\u0026quot;, x = \u0026quot;Sobreviventes\u0026quot;, y = \u0026quot;Frequência\u0026quot;)  O que podemos concluir? Que a maior parte dos passageiros do Titanic, infelizmente, não sobreviveu ao acidente, e que, dos que sobreviveram, a maioria é do sexo feminino. Estimando uma regressão logística, podemos investigar esta relação mais detidamente.\nEstimando modelos logísticos: a função glm do R Para estimar essa regressão logística, uso a função glm, que já vem no R, especificamente no pacote stats. A função aceita vários argumentos, mas os principais que usaremos são três: a fórmula, o link (o que usaremos é o logístico, mas a função também aceita outros) e os dados usados (no caso, da base dos sobreviventes do Titanic, que já carregamos). Exemplo:\n# Estima um modelo logistico com a funcao glm modelo \u0026lt;- glm(Survived ~ Sex, family = \u0026quot;binomial\u0026quot;, data = titanic)  Explicando o código acima, fizemos o seguinte. Primeiro, passamos a fórmula que queremos estimar, com a variável Survived (sobreviventes) como dependente (Y) sendo explicada (o ~ indica que tudo após isto é variável independente) pela variávei Sex (sexo dos passageiros). Segundo, explicitamos o link (family = \u0026quot;binomial\u0026quot;). Por fim, passamos os nossos dados (data = titanic).\nPara visualizarmos o resultado deste modelo, apenas precisamos usar a função summary:\n# Acessa os resultados do modelo logistico summary(modelo)  ## ## Call: ## glm(formula = Survived ~ Sex, family = \u0026quot;binomial\u0026quot;, data = titanic) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.6462 -0.6471 -0.6471 0.7725 1.8256 ## ## Coefficients: ## Estimate Std. Error z value Pr(\u0026gt;|z|) ## (Intercept) 1.0566 0.1290 8.191 2.58e-16 *** ## Sexmale -2.5137 0.1672 -15.036 \u0026lt; 2e-16 *** ## --- ## Signif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 1186.7 on 890 degrees of freedom ## Residual deviance: 917.8 on 889 degrees of freedom ## AIC: 921.8 ## ## Number of Fisher Scoring iterations: 4  Como já havíamos visto, a probabilidade de passageiros homens terem sobrevivido é menor do que a de passageiras mulheres (aqui há um bom tutorial de como interpretar os resultados de modelos logísticos). Mas, da forma como é reportado, este coeficiente (Sexmale, que retorna a probabilidade, em log odds, de um homem ter sobrevivido em relação a uma mulher) é difícil de ser interpretado. Uma forma mais simples é por meio de razão de chance.\nTendo salvo o modelo, podemos calcular as razões de chance de forma fácil usando a função exp, que serve para exponenciar um número:\n# Converte os coeficientes do modelo de log odds para razao de chance exp(modelo$coefficients)  ## (Intercept) Sexmale ## 2.87654321 0.08096732  Agora, podemos interpretar os resultado de forma mais direta: para cada mulher que se salvou no Titanic, 0.08 homens se salvaram (ou, de forma mais intuitiva, 100 mulheres para cada 8 homens; o artigo da Wikipedia sobre razão de chance é um bom guia para interpretar essas razões de chance).\n","date":1473379200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1473379200,"objectID":"d8f2aa5d24c6729e600f431b061ac5b4","permalink":"https://fmeireles.com/blog/rstats/estimando-regressoes-logisticas-no-r-com-razao-de-chance/","publishdate":"2016-09-09T00:00:00Z","relpermalink":"/blog/rstats/estimando-regressoes-logisticas-no-r-com-razao-de-chance/","section":"post","summary":"Uma das coisas que dá dor de cabeça a usuários do Stata que migram para o R é a estimação de modelos estatísticos. Como o Stata já oferece, de forma simples, diversos modelos e opções para alterar as suas especificações, a migração para o R pode ser frustrante neste aspecto: muitas coisas simples no Stata, como incluir erros-padrão robustos ou efeitos fixos, geralmente demandam mais linhas de código (e chamada a vários pacotes) no R.","tags":[],"title":"Estimando regressões logísticas no R (com razão de chance)","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","electionsbr"],"content":"Semana passada, o Denisson, a Bia e eu lançamos o electionsBR, um pacote no R para baixar e limpas dados eleitorais do repositório do TSE. Como explicamos, o pacote contém diversas funções que facilitam a obtenção destes dados, além de tornar um processo imensamente mais rápido. Mas, como algumas mensagens que recebemos de lá pra cá indicaram, algumas (talvez muitas) pessoas usam o Stata para rodar suas análises e, por isso, não se beneficiariam do pacote.\nNeste post, farei um pequeno tutorial de como baixar e exportar estes dados do R para o Stata. Não é necessário muito conhecimento de R para segui-lo. Na verdade, o procedimento é tão simples que pode ser resumido em três etapas:\n Carregar os pacotes necessários: a primeira coisa a fazer é instalar e carregar o pacote electionsBR no R, que contêm as funções para baixar os dados do TSE. Para isto, basta apenas digitar no console:  # Instala o pacote electionsBR (se ja foi instalado, esta etapa pode ser pulada) install.packages(\u0026quot;electionsBR\u0026quot;)   Carregar e baixar os dados necessários: agora, precisamos carregar o pacote e apenas utilizar a função desejada. Por exemplo, podemos baixar todos os dados sobre as coligações eleitorais e partidos que concorreram nas eleições de 2010 com o seguinte código:  # Carrega o pacote electionsBR library(electionsBR) # Baixa os dados sobre as legendas da eleicao de 2010 dados \u0026lt;- legend_fed(2010)   Exportanto os dados: por fim, exportamos os dados com o pacote foreign, disponível por padrão no R (ao menos nas distribuições do R Project, que é também a mais utilizada):  # Carrega o pacote foreign library(foreign) # Exporta os dados baixados do TSE (objeto 'dados') para o Stada write.dta(dados, file = \u0026quot;dados.dta\u0026quot;)  Feito isto, os dados baixados estarão disponíveis no diretório de trabalho do R (é possível vê-lo digitando no console getwd()), especificamente no arquivo \u0026ldquo;dados.dta\u0026rdquo;. É possível usar outro nome de arquivo para salvá-lo \u0026ndash; desde que seja mantida a extensão no final (.dta). Exemplos:\n# Este nome de arquivo e' valido write.dta(dados, file = \u0026quot;outro_nome.dta\u0026quot;) # Este nome de arquivo nao e' write.dta(dados, file = \u0026quot;outro_nome\u0026quot;)  (Na verdade, é até possível exportar um data.frame para o Stata sem usar a extensão .dta no nome do arquivo; o problema é que o arquivo não será associado ao Stata e, portanto, não será possível abri-lo com dois cliques simultâneos).\nEm resumo, mesmo com um conhecimento quase zero de R, é fácil usar o pacote electionsBR para pegar dados do TSE e exportá-los para o Stata (ou para outros softwares) \u0026ndash; e, o que não é menos importante, de forma rápida e eficiente.\n","date":1471824000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1471824000,"objectID":"c761eb19dc28cafc911ffe02991fffb1","permalink":"https://fmeireles.com/blog/rstats/electionsbr-exportanto-dados-eleitorais-do-r-para-o-stata-spss/","publishdate":"2016-08-22T00:00:00Z","relpermalink":"/blog/rstats/electionsbr-exportanto-dados-eleitorais-do-r-para-o-stata-spss/","section":"post","summary":"Semana passada, o Denisson, a Bia e eu lançamos o electionsBR, um pacote no R para baixar e limpas dados eleitorais do repositório do TSE. Como explicamos, o pacote contém diversas funções que facilitam a obtenção destes dados, além de tornar um processo imensamente mais rápido. Mas, como algumas mensagens que recebemos de lá pra cá indicaram, algumas (talvez muitas) pessoas usam o Stata para rodar suas análises e, por isso, não se beneficiariam do pacote.","tags":[],"title":"electionsBR: Exportando dados eleitorais do R para o Stata","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","electionsbr"],"content":" Usando o nosso pacote no R para baixar e limpar dados eleitorais do TSE, desenvolvimento conjuntamente pelo Denisson Silva, Beatriz Costa e eu, vou mostrar aqui como é possível obter e analisar os resultados de apuração das eleições para a Câmara dos Deputados desde 1998 (o período disponível, por causa de limitações nos dados do TSE, vai de 98 a 2014 \u0026ndash; mas pretendemos expandir ele no futuro) desagregados por município/zona eleitoral.\nBaixando os dados de apuração das eleições federais Como o pacote está no CRAN, a primeira coisa que precisamos fazer é instalá-lo via console:\n# Instala o pacote electionsBR via CRAN install.packages(\u0026quot;electionsBR\u0026quot;)  Também é possível baixar as versões pre-release do pacote via GitHub (o que permite acessar as modificações que vamos fazendo nele antes delas irem para o CRAN):\n# Instala o pacote electionsBR via GitHub if (!require(\u0026quot;devtools\u0026quot;)) install.packages(\u0026quot;devtools\u0026quot;) devtools::install_github(\u0026quot;silvadenisson/electionsBR\u0026quot;)  Feito isto, o pacote pode ser carregado com library:\n# Carrega o pacote electionsBR library(electionsBR)  Os dados sobre a apuração (i.e. votos válidos, nulos, brancos, etc.) podem ser acessados pela função details_mun_zone_fed() (ou details_mun_zone_local, para as eleições municipais). O primeiro passo para analisar a votação nas eleições da Câmara, portanto, é extrair os dados para 1998, 2002, 2006, 2010 e 2014:\n# Extrai os dados das eleicoes federais de 1998 a 2014 e1998 \u0026lt;- details_mun_zone_fed(1998) e2002 \u0026lt;- details_mun_zone_fed(2002) e2006 \u0026lt;- details_mun_zone_fed(2006) e2010 \u0026lt;- details_mun_zone_fed(2010) e2014 \u0026lt;- details_mun_zone_fed(2014)  Ainda é possível reduzir este código via lapply (com a desvantagem de que, se em algum momento o servidor do TSE tiver problemas, o código para de executar; ao coletar os dados por eleição, é possível lidar melhor com erros):\n# Cria um vetor armazenando os anos anos \u0026lt;- seq(1998, 2014, by = 4) # Baixa os dados com lapply e details_mun_zone_fed dados \u0026lt;- lapply(anos, details_mun_zone_fed)  ## Processing the data...Done.Processing the data...Done.Processing the data...Done.Processing the data...Done.Processing the data...Done.  Para unir as bases, uma maneira fácil é por meio da função bind_rows() do pacote dplyr (uma pequena introdução a ele pode ser vista aqui):\n# Carrega o pacote dplyr if (!require(\u0026quot;dplyr\u0026quot;)) install.packages(\u0026quot;dplyr\u0026quot;) library(dplyr) # Une as bases (se foram baixadas separadamente, descomente a linha abaixo) # dados \u0026lt;- bind_rows(list(e1998, e2002, e2006, e2010, e2014)) # Une as bases (se foram baixadas separadamente, comente a linha abaixo) dados \u0026lt;- bind_rows(dados)  Feito isso (em poucos segundos!), a base final deve ficar com 196723 observações, algo que seria difícil de organizar manualmente ou em planilhas de excel. Só é necessário agora filtrar as observações para ficar apenas com as referentes às eleições da Câmara (excluindo, portanto, eleições para as assembleias estaduais, senado, etc.):\n# Filtra os dados dados \u0026lt;- dados[dados$DESCRICAO_CARGO == \u0026quot;DEPUTADO FEDERAL\u0026quot;,]  Analisando os dados Tendo todos estes dados já na memória do R, é possível analisá-los. Para fazer isto, utilizo o pacote ggplot2 para gerar alguns gráficos. O primeiro deles é para examinar a relação entre a quantidade de comparecimentos vs. quantidade de abstenções \u0026ndash; obviamente, os dois têm de ser negativamente relacionados:\n# Carrega o pacote ggplot2 if (!require(\u0026quot;ggplot2\u0026quot;)) install.packages(\u0026quot;ggplot2\u0026quot;) library(ggplot2) ggplot(dados, aes(x = QTD_ABSTENCOES, y = QTD_COMPARECIMENTO)) + geom_point() + theme_bw() + labs(title = \u0026quot;Abstenções vs. Comparecimento\u0026quot;, y = \u0026quot;Comparecimento\u0026quot;, x = \u0026quot;Abstenções\u0026quot;)  O que obtemos é justamente o contrário. Mas por quê? Porque o gráfico está captando o total de eleitores \u0026ndash; é necessário transformar comparecimentos e abstenções em percentuais do total de eleitores aptos a votar. Podemos fazer isto da seguinte forma:\nggplot(dados, aes(x = I(QTD_ABSTENCOES / QTD_APTOS), y = I(QTD_COMPARECIMENTO / QTD_APTOS))) + geom_point() + theme_bw() + labs(title = \u0026quot;Abstenções vs. Comparecimento\u0026quot;, y = \u0026quot;% Comparecimento\u0026quot;, x = \u0026quot;% Abstenções\u0026quot;)  Agora obtemos o resultado esperado, uma relação perfeita entre comparecimento e abstenções. Com um código um pouco diferente (é preciso remover missings e converter a variável ANO_ELEICAO para factor), também podemos investigar a média de abstenções durante o período:\nfilter(dados, !is.na(ANO_ELEICAO)) %\u0026gt;% mutate(ANO_ELEICAO = factor(ANO_ELEICAO)) %\u0026gt;% ggplot(aes(y = I(QTD_ABSTENCOES / QTD_APTOS), x = ANO_ELEICAO)) + geom_bar(stat = \u0026quot;summary\u0026quot;, fun.y = \u0026quot;mean\u0026quot;) + theme_bw() + labs(title = \u0026quot;Média de abstenções nas eleições para a Câmara\u0026quot;, y = \u0026quot;% Abstenção\u0026quot;, x = \u0026quot;Ano\u0026quot;)  É possível ver que, após a eleição de 98, a média de abstenções cai, mas se mantém mais ou menos constante depois disso. Como a média sofre influência de outliers, podemos refazer o mesmo gráfico para visualizar a mediana das abstenções:\nfilter(dados, !is.na(ANO_ELEICAO)) %\u0026gt;% mutate(ANO_ELEICAO = factor(ANO_ELEICAO), PERC_ABST = QTD_ABSTENCOES / QTD_APTOS) %\u0026gt;% ggplot(aes(y = PERC_ABST, x = ANO_ELEICAO)) + geom_bar(stat = \u0026quot;summary\u0026quot;, fun.y = \u0026quot;median\u0026quot;) + theme_bw() + labs(title = \u0026quot;Mediana de abstenções nas eleições para a Câmara\u0026quot;, y = \u0026quot;% Abstenção\u0026quot;, x = \u0026quot;Ano\u0026quot;)  Por fim, podemos investigar a distribução destas abstenções por eleição para obter uma informação mais detalhada:\nfilter(dados, !is.na(ANO_ELEICAO)) %\u0026gt;% mutate(ANO_ELEICAO = factor(ANO_ELEICAO), PERC_ABST = QTD_ABSTENCOES / QTD_APTOS) %\u0026gt;% ggplot(aes(x = PERC_ABST)) + geom_histogram() + facet_wrap(~ ANO_ELEICAO) + theme_bw() + labs(title = \u0026quot;Distribuição de abstenções nas eleições para a Câmara\u0026quot;, y = \u0026quot;Freqência\u0026quot;, x = \u0026quot;% Abstenção\u0026quot;)  O que corrobora os gráficos anteriores: a distribuição das abstenções em 98 estava mais dispersa do que nas eleições seguintes.\nNotas finais Este é apenas um dois possíveis tipos de análises que é possível fazer com a ajuda do pacote electionsBR. Como deve ter ficado claro, ele simplifica enormemente a tarefa de obter dados eleitorais, além de já os deixar prontos para uso. Mesmo assim, ainda é possível que alguns dos dados do TSE não possam ser tão simplemente analisados. A formação de alguns campos varia ao longo do tempo (a data de nascimento dos candidatos, por exemplo, era preenchida como \u0026ldquo;13/10/1976\u0026rdquo; em anos anteriores, mas também já foi preenchida como \u0026ldquo;13-10-76\u0026rdquo;), algumas variáveis são acrescentadas e, constantemente, outras são atualizadas pelo TSE. Por estas e outras razões, o pacote electionsBR ainda é um trabalho em aberto, que pode melhorar com a contribuição de outras pessoas.\n","date":1471564800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1471564800,"objectID":"8728ac9ca79e1f6cf572b615ad017201","permalink":"https://fmeireles.com/blog/rstats/electionsbr-analisando-a-apuracao-das-eleicoes-para-a-camara-dos-deputados/","publishdate":"2016-08-19T00:00:00Z","relpermalink":"/blog/rstats/electionsbr-analisando-a-apuracao-das-eleicoes-para-a-camara-dos-deputados/","section":"post","summary":"Usando o nosso pacote no R para baixar e limpar dados eleitorais do TSE, desenvolvimento conjuntamente pelo Denisson Silva, Beatriz Costa e eu, vou mostrar aqui como é possível obter e analisar os resultados de apuração das eleições para a Câmara dos Deputados desde 1998 (o período disponível, por causa de limitações nos dados do TSE, vai de 98 a 2014 \u0026ndash; mas pretendemos expandir ele no futuro) desagregados por município/zona eleitoral.","tags":[],"title":"electionsBR: analisando a apuração das eleições para a Câmara dos Deputados","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","electionsbr"],"content":" Nosso pacote para baixar e limpar dados eleitorais do website do TSE, desenvolvido conjuntamente por Denisson Silva, Beatriz Costa e eu, foi publicado no Comprehensive R Archive Network (CRAN): o electionsBR. Basicamente, ele contém uma série de funções para extrair e limpar a maioria dos dados disponíveis no Repositório de Dados Eleitorais do TSE, deixando-os prontos para uso.\nO electionsBR vem para facilitar a vida de quem trabalha ou precisa consultar estes dados do TSE de duas formas. Primeiro, ele fornece um conjunto de funções para baixar a maioria dos dados do TSE, que são então armazenados diretamente num objeto na memória do R \u0026ndash; sem a necessidade de abrir o website do TSE, deszipar, ler e limpar cada um dos arquivos individuais. Segundo, ele faz isso em poucos segundos e, além disso, já lida com os principais problemas nas bases do TSE: como é notório entre os usuários do Repositório, os arquivos do TSE frequentemente vêm com problemas de enconding (i.e. acentos tornam-se caracteres inelegíveis), incompatibilidade entre arquivos (i.e. mais ou menos variáveis, células vazias) e informações mal formatadas (i.e. variáveis numéricas contêm caracteres não-numéricos).Com ele, portanto, é possível baixar rapidamente, e sem problemas, os principais dados eleitorais do TSE.\nUsando o pacote Apenas duas coisas são necessárias para usar o pacote: uma versão do R superior a 2.1 (\u0026gt;= 2.1) e conexão com a internet. Para instalar a versão estável dele no CRAN, basta digitar no console:\ninstall.packages(\u0026quot;electionsBR\u0026quot;)  Também é possível instalar as versões pré-release direto do GitHub (onde também está disponível uma pequena introdução ao pacote, em inglês):\nif (!require(\u0026quot;devtools\u0026quot;)) install.packages(\u0026quot;devtools\u0026quot;) devtools::install_github(\u0026quot;silvadenisson/electionsBR\u0026quot;)  O pacote electionsBR possui dez funções básicas para baixar cinco tipos de dados diferentes. São elas:\n candidate_fed(): baixa dados sobre as candidaturas individuais nas eleições federais. candidate_local(): baixa dados sobre as candidaturas individuais nas eleições municipais. details_mun_zone_fed(): baixa dados sobre os detalhes de apuração desagregados por município/zona eleitoral das eleições federais. details_mun_zone_fed(): baixa dados sobre os detalhes de apuração desagregados por município/zona eleitoral das eleições municipais. legend_fed(): baixa dados sobre as legendas que concorreram nas eleições federais. legend_local(): baixa dados sobre as legendas que concorreram nas eleições locais. party_mun_zone_fed(): baixa dados sobre o desempenho das legendas desagregados por município/zona eleitoral nas eleições federais. party_mun_zone_local(): baixa dados sobre o desempenho das legendas desagregados por município/zona eleitoral nas eleições locais. vote_mun_zone_fed(): baixa dados sobre os resultados eleitorais desagregados por município/zona eleitoral nas eleições federais. vote_mun_zone_locais(): baixa dados sobre os resultados eleitorais desagregados por município/zona eleitoral nas eleições locais.  Para baixar os dados sobre os candidatos que disputaram as eleições nacionais de 2002, por exemplo, basta executar o seguinte código:\n# Carrega o pacote library(electionsBR) # Baixa os dados dados \u0026lt;- candidate_fed(year = 2002)  ## Processing the data...Done  Todas as funções funcionam da mesma forma: o único argumento que deve ser preenchido pelo usuário é o ano do pleito (year), que deve ser introduzido como integer (e.g., 2002, 2006, 1996). O objeto resultante é um data.frame que contém diversas variáveis (para uma descrição detalhada de cada uma, ver a documentação do pacote no CRAN).\nAlgumas notas finais É importante ressaltar que este pacote é resultado de alguns projetos de pesquisa em andamento no Centro de Estudos Legislativos (CEL), do qual o Denisson, a Bia e eu fazemos parte. Ao ter de repetir diversas vezes a tarefa de baixar, descompactar, abrir e unir todas as bases do TSE, achamos uma boa ideia criar este pacote para facilitar a nossa vida. Mas, como efeito final, também possibilitamos que outras pessoas consultem os mesmos dados facilmente.\nComo esta é a primeira versão estável do pacote, críticas e sugestões para melhorá-lo são bem-vindas.\n","date":1471478400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1471478400,"objectID":"96ba45dfb1f7bb2716c728ca8b3a3705","permalink":"https://fmeireles.com/blog/rstats/electionsbr-um-pacote-para-baixar-dados-eleitorais-do-tse/","publishdate":"2016-08-18T00:00:00Z","relpermalink":"/blog/rstats/electionsbr-um-pacote-para-baixar-dados-eleitorais-do-tse/","section":"post","summary":"Nosso pacote para baixar e limpar dados eleitorais do website do TSE, desenvolvido conjuntamente por Denisson Silva, Beatriz Costa e eu, foi publicado no Comprehensive R Archive Network (CRAN): o electionsBR. Basicamente, ele contém uma série de funções para extrair e limpar a maioria dos dados disponíveis no Repositório de Dados Eleitorais do TSE, deixando-os prontos para uso.\nO electionsBR vem para facilitar a vida de quem trabalha ou precisa consultar estes dados do TSE de duas formas.","tags":[],"title":"electionsBR: um pacote no R para baixar e limpar dados eleitorais do TSE","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","politica","dilma"],"content":" Num post anterior, fiz uma análise dos tweets da Presidenta Dilma Rousseff. Neste aqui, aproveitei os dados já coletados para fazer algo diferente, que já estava querendo fazer há tempos: uma análise de sentimentos. Basicamente, esta técnica serve para avaliar um determinado texto, dando a ele uma nota numa escala que vai de negativo a positivo, triste a feliz, etc. No caso, vou fazer isto utilizando a API do cognitive services da Microsoft, que possui um algoritimo próprio para classificar os textos numa escala que vai de 0, mais negativo, a 1, mais positivo (assim como outros métodos, ele classifica cada palavra num texto e, então, computa um score para a frase ou trecho; para uma análise sobre a potencialidade do método, ver aqui).\nAnalisando os sentimentos dos tweets da Dilma Como mostro naquele post anterior, podemos concluir três coisas em relação aos tweets da @dilmabr publicados desde 2015: (1) ela passou a tuítar mais após o seu afastamento (mas já tuitou mais no passado); (2) seus tweets passaram a receber mais retweets e favoritadas após o afastamento; e, (3), os tweets que mencionam o termo \u0026ldquo;golpe\u0026rdquo; são mais influentes do que a média deste outro grupo (tweets pós-afastamento sem o termo \u0026ldquo;golpe\u0026rdquo;).\nCom uma análise de sentimentos destes tweets, podemos descobrir outras coisas: como o tom das postagens da Presidenta variaram ao longo do tempo? Seus tweets mais recentes possuem conteúdo mais negativo (críticas, mostras de ressentimento, etc.) ou mais positivos (expressões de felicidade, elogios, etc.)? Para responder estas perguntas, apliquei o algoritimo do cognitive services em cada um dos tweets 1859 da Dilma e salvei seus scores (aqui há um bom tutorial sobre como usar o serviço da Microsoft no R, com o pacote mscstexta4r). Feito isto, podemos plotar os resultados (cada ponto cinza indica um tweet, o eixo y indica o score do tweet naquela escala que vai de 0, mais negativo, a 1, mais positivo e, enfim, a linha azul é uma curva loess):\nDuas coisas chamam a atenção logo de cara. A primeira delas é o fato de que, após o seu afastamento (maio de 2016, linha tracejada), o sentimento geral dos tweets da Dilma tornam-se mais negativos, como mostra o declínio da linha azul (o que até faz sentido). Exemplos disto:\n## Tweet = Fico triste de não assistir à festa \u0026quot;ao vivo e a cores\u0026quot;. Mas estarei acompanhando, torcendo pelo Brasil. / Score = 0 ## Tweet = O golpe consiste em 2 coisas: estancar a sangria, impedir q as investigações da #LavaJato chegasse até eles. O meu gov não interromperia. / Score = 0.2127647  O que contrasta com alguns tweets anteriores:\n## Tweet = Viva a mulher brasileira! Viva o povo brasileiro. Viva o Brasil! #DilmaDaMulher / Score = 1 ## Tweet = (...) valeu a pena lutar pela liberdade, valeu a pena lutar pela democracia! Este País está + forte do q nunca. / Score = 1  Durante todo o restante do período, os tweets da Presidenta oscilavam pouco em seus tons, ficando, na média, um pouco acima de 0.5 na escala de sentimentos. A caída repentina após o afastamento, portanto, indica que o tom geral dos tweets da Presidenta mudaram (embora não dê pra saber, apenas visualmente, se a média destes tweets é significativamente diferente dos demais).\nJá a segunda coisa que merece destaque é a retomada do tom positivos nos últimos tweets Como dá pra ver, após a queda, a linha azul volta a subir bastante (superando, inclusive, períodos anteriores). Mas o que ela tem dito? Coisas como estas:\n## Tweet = As mulheres têm se destacado nesses Jogos, o que nos enche de orgulho e alegria. #Rio2016 / Score = 0.9818006 ## Tweet = Obrigada, @BernieSanders! Dilma agradece solidariedade do senador democrata norte-americano: https://t.co/jtPVdAouaA / Score = 1 ## Tweet = O Brasil está orgulhoso, @RafaelaSilvaa. Estamos emocionados com sua conquista. Você é o máximo! Parabéns! #Rio2016 / Score = 1  Como se pode ver, o tom triste e combativo dos tweets mais negativos contrasta com estes, que são dedicados a agradecer pessoas e exaltar conquistas.\n","date":1471132800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1471132800,"objectID":"884f6bca73e36253aec75df21d9a3f10","permalink":"https://fmeireles.com/blog/rstats/analise-de-sentimentos-dos-tweets-da-dilma/","publishdate":"2016-08-14T00:00:00Z","relpermalink":"/blog/rstats/analise-de-sentimentos-dos-tweets-da-dilma/","section":"post","summary":"Num post anterior, fiz uma análise dos tweets da Presidenta Dilma Rousseff. Neste aqui, aproveitei os dados já coletados para fazer algo diferente, que já estava querendo fazer há tempos: uma análise de sentimentos. Basicamente, esta técnica serve para avaliar um determinado texto, dando a ele uma nota numa escala que vai de negativo a positivo, triste a feliz, etc. No caso, vou fazer isto utilizando a API do cognitive services da Microsoft, que possui um algoritimo próprio para classificar os textos numa escala que vai de 0, mais negativo, a 1, mais positivo (assim como outros métodos, ele classifica cada palavra num texto e, então, computa um score para a frase ou trecho; para uma análise sobre a potencialidade do método, ver aqui).","tags":[],"title":"Uma análise de sentimentos dos tweets da Dilma Rousseff","type":"post"},{"authors":["Fernando Meireles"],"categories":["politica","impeachment","dilma"],"content":" Desde o ínicio do impeachment da agora Presidente afastada, Dilma Rousseff (PT), acadêmicos e articulistas discutem se este processo se encaixa na categoria de golpe de estado. Críticos do governo e membros da oposição defendem que, conceitualmente, golpe de estado envolveria deposição à força da ou do presidente (i.e., por golpe militar), o que não é o caso aqui. Por outro lado, esta definição está longe de ser consensual: outras definições são consistentes com a ausência de participação militar. No caso da queda do então Presidente do Paraguai, Fernando Lugo, o mesmo foi frequentemente alegado, embora, também ali, seja difícil explicar como que um processo tão rápido possa ter seguido dentro da normalidade democrática.\nOutra questão neste debate, entretanto, não é muito analisada: rotular o processo de impedimento da Presidenta Dilma como golpe é uma boa estratégia? Para analisar isto, resolvi aproveitar o pacote twitteR, no R, para fazer uma análise de todos os tweets dela desde outubro de 2014 para responder esta pergunta. Como o twitter é reconhecidamente uma ferramenta importante de comunicação (a Dilma, além disso, tem quase 5 milhões de seguidores), este é um bom exercício para investigar o retorno desta estratégia.\nOs dados que usei, com todos os tweets da Presidenta, podem ser baixados neste link. Com eles, é possível replicar o código que usei abaixo para fazer a análise (também é necessário ter instalado alguns pacotes, como o ggplot2, pra gerar gráficos, e o dplyr, pra manipular os dados).\nA Presidenta Dilma ficou mais ativa no Twitter nos últimos meses? Depois de sua posse em 2010, Dilma Rousseff acabou abandonando o Twitter, rede social onde foi bastante ativa durante as eleições. Entre indas e vindas, logo após ter sido afastada da Presidência, entretanto, o perfil dilmabr voltou a ser usado com mais frequência. E, segundo a revista Época, seu novo uso para a ferramente tem sido divulgar sua defesa no processo de impeachment.\nA primeira coisa que resolvi investigar foi justamente isto: se a Presidenta teria ficado mais ativa no Twitter após o seu afastamento. Para começar, primeiro carrego os pacotes e os dados necessários no R.\nlibrary(lubridate) # Para manipular datas library(ggplot2) # Para gerar graficos library(tidyr) # Para manipular os dados library(dplyr) # Para manipular os dados library(tm) # Para fazer text mining nos tweets load(\u0026quot;dilma_tw.Rda\u0026quot;)  A base tem 16 variáveis e 1859 observações (significando que, desde 2010, o perfil @dilmabr tuítou 1859 vezes). A questão que precisamos analisar, agora, é verificar a frequência com que a Presidenta tem tuítado. Agregando seus tweets por mês, podemos visualizar isto:\ndilma_tw$data_mes \u0026lt;- floor_date(dilma_tw$created, \u0026quot;month\u0026quot;) dilma_tw %\u0026gt;% count(data_mes) %\u0026gt;% ggplot(aes(x = data_mes, y = n)) + geom_line() + geom_vline(xintercept = as.numeric(as.POSIXct(\u0026quot;2016-05-01\u0026quot;)), linetype = 2) + theme_bw() + labs(title = \u0026quot;Atividade da Dilma no Twitter\u0026quot;, x = \u0026quot;Ano-Mês\u0026quot;, y = \u0026quot;Número de tweets\u0026quot;)  O gráfico mostra que a pró-atividade da Presidenta no twitter é ambígua. É verdade que ela passou a tuítar mais nos últimos dois meses (a linha pontilhada indica o mês de maio de 2016), mas em outros períodos ela utilizava a ferramente muito mais, especialmente nos meses anteriores às eleições de 2014. Mesmo assim, pode ser que, mesmo não tuitando com tanta frequência, seus tweets mais recentes estejam atingindo um público maior (recebendo mais retweets ou sendo mais favoritados pelos usuários, o que indicaria que eles estariam tendo maior engajamento com os seus conteúdos). Podemos ver isso agregando as retuítadas e os favoritos também por mês:\ndilma_tw %\u0026gt;% group_by(data_mes) %\u0026gt;% summarise(Reteets = sum(retweetCount), Favoritos = sum(favoriteCount)) %\u0026gt;% gather(key = Ação, value = N, Reteets:Favoritos) %\u0026gt;% ggplot(aes(x = data_mes, y = N / 1000, color = Ação)) + geom_line() + geom_vline(xintercept = as.numeric(as.POSIXct(\u0026quot;2016-05-01\u0026quot;)), linetype = 2) + theme_bw() + labs(title = \u0026quot;RTs e Favs dos tweets da Dilma\u0026quot;, x =\u0026quot;Ano-Mês\u0026quot;, y = \u0026quot;RTs e Fav (em milhares)\u0026quot;)  O padrão parece seguir o anterior: a Presidenta vem tendo maior influência no twitter após seu afastamento, mas já teve mais que isso no passado. O problema é que estas simples medidas escondem uma informação importante: mesmo tuitando menos, pode ser que seus tweets atuais sejam relativamente mais influentes. Suponhamos, por exemplo, que todo tweet da @dilmabr tenha sempre 100 retweets; caso ela tuíte muito num mês, este gerará mais retweets no agregado. Como essa influência depende do número de tweets (quem tuíta mais pode receber mais retweets e favoritos), portanto, uma medida melhor de influência pode ser obtida calculando a média de retweets e favoritos por tweet num mês, i.e. retweets / total de tweets e favoritos / total de tweets. É possível ver este gráfico abaixo:\ndilma_tw %\u0026gt;% group_by(data_mes) %\u0026gt;% summarise(Retweets_por_tuite = sum(retweetCount) / n(), Favoritos_por_tuite = sum(favoriteCount) / n()) %\u0026gt;% gather(key = Ação, value = N, Retweets_por_tuite:Favoritos_por_tuite) %\u0026gt;% ggplot(aes(x = data_mes, y = N, color = Ação)) + geom_line() + geom_vline(xintercept = as.numeric(as.POSIXct(\u0026quot;2016-05-01\u0026quot;)), linetype = 2) + theme_bw() + labs(title = \u0026quot;RTs e Favs por tweet da Dilma\u0026quot;, x = \u0026quot;Ano-Mês\u0026quot;, y = \u0026quot;RTs e Fav por tweet\u0026quot;)  Agora é que as coisas mudam de figura: mesmo tendo tuítado relativamente menos do que em outras épocas, os tweets mais recentes da Presidenta são mais influentes, isto é, eles obtêm mais retweets e favoritos (apenas com base neste gráfico, também suspeito que poucas pessoas têm interesse em retuítar e favoritar tweets de campanha, como aqueles divulgando agenda de eventos e comícios, o que pode explicar porque a atividade nos períodos eleitorais não produz um impacto por tweet tão grande; também deve ser considerado que o número de seguidores da Presidente não se manteve constante no período).\nQuais termos mais aparecem nos tweets da Presidenta Dilma? Se os últimos tweets da Dilma têm sido os seus mais influentes, no que eles são diferentes dos anteriores? Eles falam sobre assuntos distintos? Para analisar isto, criei uma matriz com a frequência de palavras usadas nos tweets para, então, visualizar os resultados. Começo com os tweets pré-afastamento:\npre_afast \u0026lt;- dilma_tw %\u0026gt;% filter(data_mes \u0026lt; as.POSIXct(\u0026quot;2016-04-01 UTC\u0026quot;)) %\u0026gt;% select(text) %\u0026gt;% VectorSource() %\u0026gt;% Corpus() %\u0026gt;% TermDocumentMatrix(control = list( removePunctuation = T, stopwords = c(stopwords(\u0026quot;portuguese\u0026quot;), \u0026quot;vcs\u0026quot;, \u0026quot;aqui\u0026quot;, \u0026quot;ser\u0026quot;, \u0026quot;hoje\u0026quot;, \u0026quot;sobre\u0026quot;, \u0026quot;agora\u0026quot;, \u0026quot;todos\u0026quot;, \u0026quot;ter\u0026quot;, \u0026quot;vamos\u0026quot;, \u0026quot;anos\u0026quot;), removeNumbers = T, tolower = T) ) %\u0026gt;% as.matrix() %\u0026gt;% as.data.frame() pre_afast \u0026lt;- data.frame(termos = rownames(pre_afast), freq = rowSums(pre_afast), periodo = \u0026quot;Pré afastamento\u0026quot;) pre_afast %\u0026gt;% arrange(desc(freq)) %\u0026gt;% slice(1:15) %\u0026gt;% mutate(termos = factor(termos, levels = termos[order(freq, decreasing = T)])) %\u0026gt;% ggplot(aes(x = termos, y = freq)) + geom_bar(stat = \u0026quot;identity\u0026quot;) + theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + labs(title = \u0026quot;Termos mais usados nos tweets da Dilma\\n(Pré-afastamento)\u0026quot;, x = \u0026quot;Termo\u0026quot;, y = \u0026quot;Frequência\u0026quot;)  Neste período pré-afastamento, os termos que mais aparecem nos tweets da Presidenta se referem principalmente às eleições, ela mesma e ao país. Quando analisamos o segundo período, alguns termos novos aparecem:\nApesar da frequência de termos ser menor (o período também é menor), fica evidente que alguns ganham maior espaço: especialmente os termos \u0026ldquo;provisório\u0026rdquo;, \u0026ldquo;impeachment\u0026rdquo;, \u0026ldquo;processo\u0026rdquo;, \u0026ldquo;democracia\u0026rdquo; e \u0026ldquo;golpe\u0026rdquo;. Estes são, especificamente, os tweets usados como estratégia de defesa da Presidente, como seguinte exemplo mostra.\nPortanto, vimos não só que os tuítes da Dilma se tornaram mais influentes após o seu afastamento, mas também que o conteúdo destes é um pouco diferente dos anteriores: eles mencionam mais o processo de impeachment e, além disso, contêm mais o termo \u0026ldquo;golpe\u0026rdquo;.\nUsar os termos \u0026ldquo;golpe\u0026rdquo; e \u0026ldquo;impeachment\u0026rdquo; dá resultado? Mas os tweets que usam o termo \u0026ldquo;golpe\u0026rdquo; recebem mais retweets e favoritadas? Em caso positivo, podemos dizer que, ao menos no âmbito do twitter, o uso do conceito traz benefícios. Podemos fazer um exercício simples para verificar isto, que consiste em calcular a média de retweets e favoritos nos tweets com a palavra \u0026ldquo;golpe\u0026rdquo; e nos que não a contêm.\n## ## ================================= ## golpe Retweets Favoritos ## --------------------------------- ## C/ termo golpe 734.4 1326.8 ## S/ termo golpe 435.8 817.4 ## ---------------------------------  O resultado dá uma ideia da influência do termo \u0026ldquo;golpe\u0026rdquo;: tweets com este termo recebem, em média, cerca de 299 retweets a mais, além de cerca de 509 favoritadas a mais. Este não é a forma mais rigorosa de fazer isto (o grupo dos tweets sem o termo \u0026ldquo;golpe\u0026rdquo; pode tratar de assuntos menos relevantes, ter sido publicado em períodos diferentes, etc.), mas este simples exercício mostra que o uso do termo tem relação com a influência de um tweet da Presidenta (também deve ser levado em conta que isto não explica toda a influência dos seus tweets mais recentes). E quanto ao termo impeachment? O resultado muda:\n## ## ======================================= ## golpe Retweets Favoritos ## --------------------------------------- ## C/ termo impeachment 464.3 937.7 ## S/ termo impeachment 449.9 836.8 ## ---------------------------------------  Praticamente não existe diferença entre tweets que usam ou não o termo \u0026ldquo;impeachment\u0026rdquo;. Podemos ainda comparar os dois, \u0026ldquo;golpe\u0026rdquo; e \u0026ldquo;impeachment\u0026rdquo;:\n## ## ======================================= ## golpe Retweets Favoritos ## --------------------------------------- ## C/ termo golpe 734.4 1326.8 ## C/ termo impeachment 436.4 893.7 ## ---------------------------------------  Tweets com o termo \u0026ldquo;golpe\u0026rdquo;, novamente, ganham disparado em influência. Fazendo uma estimativa simples de que cada retweet alcance 100 novos usuários, podemos dizer que cada tweet com o termo atinge cerca de 30.000 usuários a mais. Provavelmente este número é maior, e ele ainda deve ser somado ao número de seguidores da Presidente que já viram os tweets em suas timelines. Outra coisa que deve ser considera é que estes retweets são feitos por usuários que provavelmente têm maior inclinação pela Presidenta, o que significa que estes já são mais propensos a se engajar com publicações que mencionam o termo \u0026ldquo;golpe\u0026rdquo;. Em todo caso, como os números mostram, o uso deste termo está associado com um maior número de retweets e favoritos, sugerindo que, ao menos no twitter, classificar o processo de impeachment como golpe parece ser a melhor estratégia.\n","date":1470960000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1470960000,"objectID":"df8147af7edba5b91b84157dc4d7c1d0","permalink":"https://fmeireles.com/blog/politica/golpe-impeachment-uma-analise-dos-tweets-da-dilma/","publishdate":"2016-08-12T00:00:00Z","relpermalink":"/blog/politica/golpe-impeachment-uma-analise-dos-tweets-da-dilma/","section":"post","summary":"Desde o ínicio do impeachment da agora Presidente afastada, Dilma Rousseff (PT), acadêmicos e articulistas discutem se este processo se encaixa na categoria de golpe de estado. Críticos do governo e membros da oposição defendem que, conceitualmente, golpe de estado envolveria deposição à força da ou do presidente (i.e., por golpe militar), o que não é o caso aqui. Por outro lado, esta definição está longe de ser consensual: outras definições são consistentes com a ausência de participação militar.","tags":[],"title":"Golpe ou impeachment? Uma análise dos tweets da Dilma Rousseff","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats"],"content":"Uma das potencialidades do R é que é possível abrir (quase) qualquer tipo de arquivo nele. Arquivos no formato .csv, .txt, .dta, etc., são apenas algumas das opções. Mas esta enorme gama de possibilidades também traz complicações, especialmente porque cada um destes arquivos possui uma função respectiva para importação.\nO pacote rio serve para acabar com estes problemas. Com uma única função, import(), ele é capaz de detectar qual arquivo o usuário deseja abrir e seleciona o método mais eficiente para fazê-lo.\nO primeiro passo para usá-lo é instalar o pacote, que está no CRAN:\n# Instalando o pacote 'rio' install.packages(\u0026quot;rio\u0026quot;, dependencies = TRUE)  Acima, instalamos o pacote com todas as dependências (outros pacotes que são necessários para que ele funcione). Feito isto, carregar qualquer arquivo de dados fica fácil, basta usar a função import():\n# Carrega o pacote rio library(rio) # Carrega um arquivo em .csv no diretorio corrente df \u0026lt;- import(file = \u0026quot;dados.csv\u0026quot;) # Carrega um arquivo em .txt no diretorio corrente df2 \u0026lt;- import(file = \u0026quot;dados.txt\u0026quot;) # Carrega um arquivo em .dta (Stata) no diretorio corrente df3 \u0026lt;- import(file = \u0026quot;dados.dta\u0026quot;) # Carrega um arquivo em .sav (SPSS) no diretorio corrente df4 \u0026lt;- import(file = \u0026quot;dados.sav\u0026quot;)  ","date":1468540800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1468540800,"objectID":"a8b7a8068c1cdd5bd5da772a03434492","permalink":"https://fmeireles.com/blog/rstats/como-importar-qualquer-arquivo-no-r/","publishdate":"2016-07-15T00:00:00Z","relpermalink":"/blog/rstats/como-importar-qualquer-arquivo-no-r/","section":"post","summary":"Uma das potencialidades do R é que é possível abrir (quase) qualquer tipo de arquivo nele. Arquivos no formato .csv, .txt, .dta, etc., são apenas algumas das opções. Mas esta enorme gama de possibilidades também traz complicações, especialmente porque cada um destes arquivos possui uma função respectiva para importação.\nO pacote rio serve para acabar com estes problemas. Com uma única função, import(), ele é capaz de detectar qual arquivo o usuário deseja abrir e seleciona o método mais eficiente para fazê-lo.","tags":[],"title":"Como importar qualquer arquivo no R","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats"],"content":" Uma das tarefas mais básicas no R é importar dados. E, dentre todos os tipos de formatos mais usados para armazenar dados, .csv (ou comma-separated values, em inglês) talvez seja o mais comum. Dados demográficos do Instituto Brasileiro de Geografia e Estatística, dados sobre os gastos do governo federal, por exemplo, vêm neste formato.\nAssim como outros ambientes de programação e softwares, o R possui facilidades nativas para importar este tipo de arquivo. Aqui, vou mostrar uma forma de fazer isto.\nImportando dados em .csv com read.csv A primeira forma de carregar dados em .csv no R, e também a mais simples, é por meio da função read.csv(). Por exemplo, vamos supor que queremos abrir um arquivo chamado dados.csv que está localizado no diretório de trabalho no R (é possível verificar o diretório corrento com a função getwd). O procedimento é simples:\ndf \u0026lt;- read.csv(file = \u0026quot;dados.csv\u0026quot;)  Basicamente, este código apenas atribui a um objeto df o resultado da função read.csv, que serve justamente para importar o conteúdo de um arquivo em .csv. O único argumento que precisamos definir foi file, que é onde devemos especificar o endereço do arquivo (como supomos que o arquivos dados.csv estava no diretório local, apenas o nome do arquivo completo foi necessário; mas é possível especificar outros endereços, como \u0026ldquo;C:/Pasta/dados.csv\u0026rdquo;).\nA função read.csv também possui outros argumentos úteis. O primeiro deles header, que especifica se a primeira linha contém o nome das variáveis (TRUE é o padrão) ou não (para o caso do arquivo não ter o nome das variáveis). O segundo argumento é sep, que indica qual o caractere usado para separar as observações de cada linha (lembrando que um .csv é um tipo de arquivo de texto que apenas separa informações por meio de algum caractere); normalmente, este caractere é ; (ponto e vírgula), mas também é comum o uso de , (vírgula) ou \\t (tab). Erros de importação, como quando o R junta todas as observações numa mesma variável, geralmente ocorrem por falta de especificar corretamente este argumento. Podemos melhorar nossa chamada à função read.csv com estes argumentos:\ndf \u0026lt;- read.csv(file = \u0026quot;dados.csv\u0026quot;, header = TRUE, sep = \u0026quot;;\u0026quot;)  Com este código, deixamos explícito que a primeira linha do arquivo .csv contém o nome das variáveis, e que o caractere usado para separar as observações é ponto e vírgula.\nOutros argumentos úteis da função read.csv Normalmente, apenas file, header e sep precisam ser especificados para abrir corretamente um .csv. Mas, em alguns casos, problemas adicionais podem tornar necessário o uso de outros argumentos da função. Abaixo, listo três outros deles:\n stringsAsFactors: por padrão, a função read.csv transforma variáveis que contêm caracteres em factor, o que normalmente não é útil. Para desabilitar isto, basta especificar na chamada à função stringsAsFactors = FALSE\n fill: nem sempre arquivos .csv possuem todos os valores ordenados no formato correto (por exemplo, uma observação pode ter sido pulada), o que pode gerar erros ao carregá-los. fill = FALSE pode solucionar problemas como este.\n dec: caractere usado para separar as casas decimais de variáveis numéricas. Muitos bancos vêm com vírgulas cumprindo esta função (30,00, por exemplo); neste caso, é possível declarar dec = \u0026quot;,\u0026quot; para fazer com que a função leia corretamente os dados.\n  ","date":1468281600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1468281600,"objectID":"e8002d22ce3ff56d8f6e22b6e2b09e85","permalink":"https://fmeireles.com/blog/rstats/como-importar-dados-em-csv-no-r/","publishdate":"2016-07-12T00:00:00Z","relpermalink":"/blog/rstats/como-importar-dados-em-csv-no-r/","section":"post","summary":"Uma das tarefas mais básicas no R é importar dados. E, dentre todos os tipos de formatos mais usados para armazenar dados, .csv (ou comma-separated values, em inglês) talvez seja o mais comum. Dados demográficos do Instituto Brasileiro de Geografia e Estatística, dados sobre os gastos do governo federal, por exemplo, vêm neste formato.\nAssim como outros ambientes de programação e softwares, o R possui facilidades nativas para importar este tipo de arquivo.","tags":[],"title":"Como importar dados em .csv no R","type":"post"},{"authors":["Fernando Meireles"],"categories":null,"content":"","date":1451617200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1451617200,"objectID":"a70b6513cb6d57d2c61fd1d13df0f6e8","permalink":"https://fmeireles.com/publication/oversized-coalitions-latin-america/","publishdate":"2016-01-01T00:00:00-03:00","relpermalink":"/publication/oversized-coalitions-latin-america/","section":"publication","summary":"Research on executive-legislative relations in presidential systems have emphasized how presidents use cabinet appointments to form and manage government coalitions in the absence of majority legislative support. Yet not all coalitions are similar, as some are larger and, consequently, more prone to agency and coordination problems than others. But what shapes presidents’ decision to include more parties in their coalitions? While several hypotheses exist in the literature, few have been tested in a systematic fashion, none focusing on why surplus coalitions form. This article intends to fill this gap by examining an original time-series cross-sectional dataset comprising 168 unique coalitions in all 18 Latin American presidential countries since 1979. In particular, I find that highly fragmented party systems and presidents with great legislative powers are more likely to generate oversized government coalitions. An additional analysis, with monthly data from Brazilian cabinets between 1989 and 2010, also shows that supermajority rules and bicameralism dynamics play a role in the occurrence of surplus coalitions, but party discipline and presidential approval do not.","tags":[],"title":"Oversized government coalitions in Latin America","type":"publication"},{"authors":["Fernando Meireles"],"categories":null,"content":"","date":1448938800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1448938800,"objectID":"15fca27ac7f5e3fc401d2638f0f21a7a","permalink":"https://fmeireles.com/publication/politica-distributiva-coalizao-tese/","publishdate":"2015-12-01T00:00:00-03:00","relpermalink":"/publication/politica-distributiva-coalizao-tese/","section":"publication","summary":"Esta tese investiga se partidos influem nos investimentos dos ministérios no presidencialismo de coalizão. Ao fazer isso, ela diverge da visão corrente nos estudos sobre política distributiva de que presidentes centralizam as decisões alocativas de seus governos. Meu argumento é o de que, ao oferecer ministérios a outros partidos em troca de apoio legislativo, presidentes compartilham a política distributiva do governo com seus parceiros de coalizão. Com isso, partidos adquirem influência e *expertise* sobre os investimentos das pastas que comandam e, consequentemente, meios de levar mais deles para as suas bases eleitorais. Documento essa conexão eleitoral partidária com dados de mais de vinte anos de transferências discricionárias dos ministérios para prefeituras no Brasil, entrevistas conduzidas em trabalho de campo e uma série de experimentos naturais. Meus resultados mostram que municípios demandam e recebem mais recursos de ministérios comandados pelos partidos dos seus prefeitos e, em troca, estes mobilizam votos para as suas legendas nas eleições gerais. Entre outras contribuições, a tese oferece evidência causal de que partidos extraem benefícios particularistas da ocupação de ministérios; mostra que isso promove desigualdades na provisão de bens públicos no país; e documenta como os partidos brasileiros, considerados fracos por muitos analistas, articulam a oferta e a demanda por recursos públicos estrategicamente para conquistar votos e adquirir influência na política nacional.","tags":[],"title":"A Política Distributiva da Coalizão","type":"publication"},{"authors":["Fernando Meireles"],"categories":null,"content":"","date":1448938800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1448938800,"objectID":"37eaa34f4769b80f04fd7bedbaa373f3","permalink":"https://fmeireles.com/publication/coalizoes-sobredimensionadas/","publishdate":"2015-12-01T00:00:00-03:00","relpermalink":"/publication/coalizoes-sobredimensionadas/","section":"publication","summary":"Nos últimos anos, a maior parte da literatura sobre as relações executivo-legislativo em sistemas presidencialistas vem enfatizando o papel da formação de coalizões governamentais, através da distribuição de ministérios, na obtenção de maiorias legislativas. Contudo, essas coalizões formadas raramente são iguais, já que umas são maiores e, por causa disso, mais propensas à problemas coordenativos e de agência. Mas o que explica a decisão de um presidente de incluir mais ou menos partidos em seu gabinete? Com um banco de dados original contendo informações sobre 168 coalizões na América Latina entre 1979 e 2012, esta dissertação testa algumas das hipóteses correntes sobre o fenômeno. Entre outros, os resultados mostram que legislativos fortes e efetivos, presidentes que dispõem de maiores poderes legislativos e maior fragmentação partidária aumentam a probabilidade de ocorrência de coalizões sobredimensionadas em diversas especificações.","tags":[],"title":"Coalizões governamentais sobredimensionadas na América Latina, 1979-2012","type":"publication"},{"authors":["Denisson Silva","Fernando Meireles"],"categories":null,"content":"","date":1420081200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1420081200,"objectID":"4c2fa74af56774c080178e59cc94cdd6","permalink":"https://fmeireles.com/publication/ciencia-politica-big-data/","publishdate":"2015-01-01T00:00:00-03:00","relpermalink":"/publication/ciencia-politica-big-data/","section":"publication","summary":"Nosso objetivo neste artigo é introduzir uma forma simples de automatizar a coleta de dados na internet para fins acadêmicos. Argumentamos que esta solução trás três principais vantagens em relação à coleta manual: (1) ela reduz drasticamente o tempo gasto na coleta; (2) ela elimina totalmente erros de imputação e de digitação; e, (3), ela aumenta a transparência das pesquisas que a utilizam. Como exemplo, coletamos mais de 25 mil proposições legislativas do site da Assembleia Legislativa de Minas Gerais e oferecemos um passo-a-passo para reproduzir este procedimento no ambiente de programação R. Concluímos discutindo as vantagens desta solução para a Ciência Política, especialmente nesta época em que cada vez mais dados estão disponíveis na internet. ","tags":[],"title":"Ciência Política na era do Big Data: automação na coleta de dados digitais","type":"publication"},{"authors":null,"categories":null,"content":"\rIntrodução ao R em 30 minutos\rcode{white-space: pre;}\rdiv.sourceCode { overflow-x: auto; }\rtable.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {\rmargin: 0; padding: 0; vertical-align: baseline; border: none; }\rtable.sourceCode { width: 100%; line-height: 100%; }\rtd.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }\rtd.sourceCode { padding-left: 5px; }\rcode  span.kw { color: #007020; font-weight: bold; } /* Keyword */\rcode  span.dt { color: #902000; } /* DataType */\rcode  span.dv { color: #40a070; } /* DecVal */\rcode  span.bn { color: #40a070; } /* BaseN */\rcode  span.fl { color: #40a070; } /* Float */\rcode  span.ch { color: #4070a0; } /* Char */\rcode  span.st { color: #4070a0; } /* String */\rcode  span.co { color: #60a0b0; font-style: italic; } /* Comment */\rcode  span.ot { color: #007020; } /* Other */\rcode  span.al { color: #ff0000; font-weight: bold; } /* Alert */\rcode  span.fu { color: #06287e; } /* Function */\rcode  span.er { color: #ff0000; font-weight: bold; } /* Error */\rcode  span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */\rcode  span.cn { color: #880000; } /* Constant */\rcode  span.sc { color: #4070a0; } /* SpecialChar */\rcode  span.vs { color: #4070a0; } /* VerbatimString */\rcode  span.ss { color: #bb6688; } /* SpecialString */\rcode  span.im { } /* Import */\rcode  span.va { color: #19177c; } /* Variable */\rcode  span.cf { color: #007020; font-weight: bold; } /* ControlFlow */\rcode  span.op { color: #666666; } /* Operator */\rcode  span.bu { } /* BuiltIn */\rcode  span.ex { } /* Extension */\rcode  span.pp { color: #bc7a00; } /* Preprocessor */\rcode  span.at { color: #7d9029; } /* Attribute */\rcode  span.do { color: #ba2121; font-style: italic; } /* Documentation */\rcode  span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */\rcode  span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */\rcode  span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */\r\r\r\r\rIntrodução ao R em 30 minutos\rFernando Meireles\rUniversidade Federal de Minas Gerais\n\rSobre o R\rEm vez de explicar o que é o R, melhor começar por entender o ele faz.\n\rO que o R faz\rManipulação de dados (gerar, fatiar, organizar, rearranjar, converter e exportar)\rTransformação de dados (mudar tipos, categorizar variáveis, quantificar informações)\rModelagem (aplicar ou desenvolver qualquer modelo estatístico)\rVisualização (visualizar qualquer tipo de dados de forma simples)\rAutomatização (produzir rotinas, autômatos ou funções)\r\r\rO que o R faz\rO R, portanto, é mais do que um simples programa: ele é um ambiente de programação.\nmensagem \u0026lt;-\u0026quot;R é um ambiente de programação\u0026quot;\rfor(i in 1:10) print(mensagem)\r## [1] \u0026quot;R é um ambiente de programação\u0026quot;\r## [1] \u0026quot;R é um ambiente de programação\u0026quot;\r## [1] \u0026quot;R é um ambiente de programação\u0026quot;\r## [1] \u0026quot;R é um ambiente de programação\u0026quot;\r## [1] \u0026quot;R é um ambiente de programação\u0026quot;\r## [1] \u0026quot;R é um ambiente de programação\u0026quot;\r## [1] \u0026quot;R é um ambiente de programação\u0026quot;\r## [1] \u0026quot;R é um ambiente de programação\u0026quot;\r## [1] \u0026quot;R é um ambiente de programação\u0026quot;\r## [1] \u0026quot;R é um ambiente de programação\u0026quot;\r\rO que é o R?\rEspecificamente, o R é uma linguagem de programação desenvolvida em cima de outras (S e C, principalmente).\nMais importante, o R é uma linguagem orientada a objetos: tudo no R é um objeto, desde vetores a funções.\n\rAlgumas distinções no R\rApesar de tudo ser um objeto no R (e ficar na memória), nem tudo no R serve para a mesma coisa. Via de regra:\nTudo no R é um objeto\rAlguns objetos, entretanto, modificam outros objetos: funções\rE funções, por serem também objetos, podem modificar outras funções\r\r\rHistória\rA história do R é longa, e começa na linguagem S - uma linguagem de programação desenvolvida para análise de dados (mas que possuia código proprietário e era mais limitada).\n\rHistória\rEm 1993, na Univesidade de Auckland (Nova Zelândia), dois acadêmicos adaptam o código primitivo do S para criar o R. Esses dois acadêmicos eram Ross Ihaka e Robert Gentleman.\nMelhor de tudo: o código do R é aberto, o que permitiu que o uso da linguagem se expandisse.\n\rUso do R\rHoje, o R já é uma das linguagens de programação mais utilizadas no mundo. Na acadêmia, seu uso é ainda maior.\n\rVantagens do R\rÉ uma das ferramentas disponíveis no mercado mais versáteis para implementar análises estatísticas.\r\rÉ flexível, o que significa que pode ser adaptada para diversos fins.\r\rPossui um excelente sistema nativo de visualização de dados (que pode ser expandido).\r\rPossui uma comunidade ativa de desenvolvedores no mundo todo.\r\rÉ grátis (sob licença GNU General Public License).\r\r\rUsando o R\rO R possui um console onde podemos digitar nosso código. Podemos testá-lo assim:\n1 +1\r## [1] 2\r\rUsando o R\rOu assim:\n10 -9 *2\r## [1] -8\r2^2 /2\r## [1] 2\r\rOperadores matemáticos\rComo deve ter ficado claro, o R pode ser usado como uma simples calculadora, onde:\n+ serve para adiação\r- serve para subtração\r* serve para multiplicação\r/ serve para divisão\r^ serve para exponenciação\r\r\rOperadores matemáticos mais avançados\rTambém podemos fazer divisão sem resto:\n11 %/%5\r## [1] 2\r\rOperadores matemáticos mais avançados\rOu obter só o resto da divisão:\n11 %%5\r## [1] 1\r\rOperadores matemáticos mais avançados\rNeste caso, os dois operadores são:\n%/% para divisão sem resto\r%% para obter o resto da divisão\r\r\rStrings\rTambém podemos salvar texto no R (character):\na \u0026lt;-\u0026quot;Meu\u0026quot;\rb \u0026lt;-\u0026quot;texto\u0026quot;\r\rStrings\rE depois podemos visualizá-los das seguintes formas:\n# Forma 1\ra\r## [1] \u0026quot;Meu\u0026quot;\rb\r## [1] \u0026quot;texto\u0026quot;\r# Forma 2\rprint(a)\r## [1] \u0026quot;Meu\u0026quot;\rprint(b)\r## [1] \u0026quot;texto\u0026quot;\r\rComentários\rNo código anterior, usamos # antes de algumas palavras. Isto indica comentários: no R, tudo o que vem antecidido por # é um comentário, o que significa que o R não o executará. Comentários são bons principalmente para:\nDocumentar um código\rExplicar o que cada linha faz\r\r\rExemplo de comentário\rTudo o que estiver comentado não será executado.\n# 1 + 1\r2 +2\r## [1] 4\r\rFunções\rTambém vimos a função print. No R, funções são objetos que normalmente aceitam alguns outros objetos como inputs. No caso da função print, algum objeto numérico ou de texto.\n\rOutras funções\r# Função de raiz quadrada\rsqrt(4)\r## [1] 2\r# Função para colar dois textos ou números\rpaste(a, b)\r## [1] \u0026quot;Meu texto\u0026quot;\r\rOutras funções\r# Função para somar dois ou mais números\rsum(1, 1)\r## [1] 2\r# Função para repetir um número ou string\rrep(\u0026quot;Texto\u0026quot;, 3)\r## [1] \u0026quot;Texto\u0026quot; \u0026quot;Texto\u0026quot; \u0026quot;Texto\u0026quot;\r\rAjuda\rUma função bastante útil no R é a help. Basicamente, ela abre uma página de ajuda com o termo (função) que se quer saber mais sobre:\n# Ajuda sobre a função paste\rhelp(paste)\r# Ajuda sobre operadores matemáticos\rhelp(\u0026quot;+\u0026quot;)\r\rCriando objetos\rPodemos salvar objetos no R. Para isto, devemos usar \u0026lt;- como atribuidor.\nnumero \u0026lt;-1 +1\rprint(numero)\r## [1] 2\r\rCriando objetos\rDepois, podemos usar estes objetos diretamente.\nx \u0026lt;-2\ry \u0026lt;-3\rx +y\r## [1] 5\rx *y\r## [1] 6\r\rModificando objetos\rPodemos ainda modificar objetos criados\nx \u0026lt;-\u0026quot;Texto\u0026quot;\rprint(x)\r## [1] \u0026quot;Texto\u0026quot;\rx \u0026lt;-2\rprint(x)\r## [1] 2\r\rVetores\rMais útil que armazenar apenas uma informação é armazenar várias no mesmo objeto. Neste caso, chamamos o objeto de vetor:\n# Para criar um vetor, usamos a funcao c(), de combine\rmeu_vetor \u0026lt;-c(1, 2, 3)\rprint(meu_vetor)\r## [1] 1 2 3\r\rTrabalhando com vetores\rFeito isso, podemos trabalhar com eles normalmente (atente para a diferença de operações com vetores):\nmeu_vetor \u0026lt;-c(1, 2, 3, 4, 5)\rmeu_vetor +1\r## [1] 2 3 4 5 6\rmeu_vetor *2\r## [1] 2 4 6 8 10\r\rVetores com strings\rVetores também podem armazenar texto:\nmeu_vetor \u0026lt;-c(\u0026quot;Meu\u0026quot;, \u0026quot;texto\u0026quot;)\rprint(meu_vetor)\r## [1] \u0026quot;Meu\u0026quot; \u0026quot;texto\u0026quot;\r\rDicas\rAntes de encerrar, algumas dicas básicas que ajudam a trabalhar com o R.\nUse e abuse de comentários. Eles ajudam a documentar uma pesquisa.\rUse espaço entre operadores. Ex: 1 + 1 é melhor que 1+1\rPara pedir ajuda, também use ? antes da chamada de uma função. Ex: ?print\rUse o RStudio para organizar de forma mais eficiente o ambiente de trabalho (RStudio)\r\r\rPara continuar aprendendo R\rEm 30 minutos é difícil, senão impossível, sair já usando o R. Mas, com o que foi visto aqui, já temos o conhecimento indispensável para ir a outras fontes, como:\nSite do R-Project\rWiki do R\rPágina do R-Bloggers\rIndicações de livros\rCurso online do DataCamp\r\r\r\r(function () {\rvar script = document.createElement(\"script\");\rscript.type = \"text/javascript\";\rscript.src = \"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\";\rdocument.getElementsByTagName(\"head\")[0].appendChild(script);\r})();\r\r\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"d1dd95a6e112cda1f3323157dc90006e","permalink":"https://fmeireles.com/introducao_ao_r_30_minutos/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/introducao_ao_r_30_minutos/","section":"","summary":"Introdução ao R em 30 minutos\rcode{white-space: pre;}\rdiv.sourceCode { overflow-x: auto; }\rtable.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {\rmargin: 0; padding: 0; vertical-align: baseline; border: none; }\rtable.sourceCode { width: 100%; line-height: 100%; }\rtd.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }\rtd.sourceCode { padding-left: 5px; }\rcode  span.kw { color: #007020; font-weight: bold; } /* Keyword */\rcode  span.dt { color: #902000; } /* DataType */\rcode  span.","tags":null,"title":"","type":"page"},{"authors":null,"categories":null,"content":"\rR: Um guia prático\r\r\r\r\r\r\r\r\rcode{white-space: pre;}\rdiv.sourceCode { overflow-x: auto; }\rtable.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {\rmargin: 0; padding: 0; vertical-align: baseline; border: none; }\rtable.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }\rtd.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }\rtd.sourceCode { padding-left: 5px; }\rpre, code { background-color: #f8f8f8; }\rcode  span.kw { color: #204a87; font-weight: bold; } /* Keyword */\rcode  span.dt { color: #204a87; } /* DataType */\rcode  span.dv { color: #0000cf; } /* DecVal */\rcode  span.bn { color: #0000cf; } /* BaseN */\rcode  span.fl { color: #0000cf; } /* Float */\rcode  span.ch { color: #4e9a06; } /* Char */\rcode  span.st { color: #4e9a06; } /* String */\rcode  span.co { color: #8f5902; font-style: italic; } /* Comment */\rcode  span.ot { color: #8f5902; } /* Other */\rcode  span.al { color: #ef2929; } /* Alert */\rcode  span.fu { color: #000000; } /* Function */\rcode  span.er { color: #a40000; font-weight: bold; } /* Error */\rcode  span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */\rcode  span.cn { color: #000000; } /* Constant */\rcode  span.sc { color: #000000; } /* SpecialChar */\rcode  span.vs { color: #4e9a06; } /* VerbatimString */\rcode  span.ss { color: #4e9a06; } /* SpecialString */\rcode  span.im { } /* Import */\rcode  span.va { color: #000000; } /* Variable */\rcode  span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */\rcode  span.op { color: #ce5c00; font-weight: bold; } /* Operator */\rcode  span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */\rcode  span.ex { } /* Extension */\rcode  span.at { color: #c4a000; } /* Attribute */\rcode  span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */\rcode  span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */\rcode  span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */\rcode  span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */\r\rpre:not([class]) {\rbackground-color: white;\r}\r\rh1 {\rfont-size: 34px;\r}\rh1.title {\rfont-size: 38px;\r}\rh2 {\rfont-size: 30px;\r}\rh3 {\rfont-size: 24px;\r}\rh4 {\rfont-size: 18px;\r}\rh5 {\rfont-size: 16px;\r}\rh6 {\rfont-size: 12px;\r}\r.table th:not([align]) {\rtext-align: left;\r}\r\r\r\r.main-container {\rmax-width: 940px;\rmargin-left: auto;\rmargin-right: auto;\r}\rcode {\rcolor: inherit;\rbackground-color: rgba(0, 0, 0, 0.04);\r}\rimg {\rmax-width:100%;\rheight: auto;\r}\r.tabbed-pane {\rpadding-top: 12px;\r}\rbutton.code-folding-btn:focus {\routline: none;\r}\r\r\r$(document).ready(function () {\rwindow.buildTabsets(\"TOC\");\r});\r\r\r$(document).ready(function () {\r// move toc-ignore selectors from section div to header\r$('div.section.toc-ignore')\r.removeClass('toc-ignore')\r.children('h1,h2,h3,h4,h5').addClass('toc-ignore');\r// establish options\rvar options = {\rselectors: \"h1,h2\",\rtheme: \"bootstrap3\",\rcontext: '.toc-content',\rhashGenerator: function (text) {\rreturn text.replace(/[.\\\\/?\u0026!#]/g, '').replace(/\\s/g, '_').toLowerCase();\r},\rignoreSelector: \".toc-ignore\",\rscrollTo: 0\r};\roptions.showAndHide = true;\roptions.smoothScroll = true;\r// tocify\rvar toc = $(\"#TOC\").tocify(options).data(\"toc-tocify\");\r});\r\r#TOC {\rmargin: 25px 0px 20px 0px;\r}\r@media (max-width: 768px) {\r#TOC {\rposition: relative;\rwidth: 100%;\r}\r}\r.toc-content {\rpadding-left: 30px;\rpadding-right: 40px;\r}\rdiv.main-container {\rmax-width: 1200px;\r}\rdiv.tocify {\rwidth: 20%;\rmax-width: 260px;\rmax-height: 85%;\r}\r@media (min-width: 768px) and (max-width: 991px) {\rdiv.tocify {\rwidth: 25%;\r}\r}\r@media (max-width: 767px) {\rdiv.tocify {\rwidth: 100%;\rmax-width: none;\r}\r}\r.tocify ul, .tocify li {\rline-height: 20px;\r}\r.tocify-subheader .tocify-item {\rfont-size: 0.90em;\rpadding-left: 25px;\rtext-indent: 0;\r}\r.tocify .list-group-item {\rborder-radius: 0px;\r}\r\r\r\rR: Um guia prático\rFernando Meireles\rUniversidade Federal de Minas Gerais\r\r1 Como usar\rEste guia não é um curso de R, nem um tutorial ou um livro sobre. Ele é uma referência prática sobre a linguagem por detrás do R - o que significa que o foco dele é no código, na adaptação de exemplos. Ainda assim, este material não oferece uma introdução ampla às potencilialidades deste ambiente de programação, apenas a uma parte importante dela: o conteúdo exposto aqui cobre deste o mais básico, que é como trabalhar no console, até análises mais simples. Em outras palavras, o conteúdo cobre o mínimo básico, os fundamentos, para quem quer trabalhar seriamente com o R.\nPor esta razão, o conteúdo do guia provavelmente será mais útil para iniciantes, ainda que também sirva para usuários(as) com nível intermediário aprenderem algumas coisas novas (a verdade é que todo mundo está sempre aprendendo quando o assunto é programação). De qualquer modo, o conteúdo do guia está todo separado em seções e subseções - o menu à esquerda permite visualizar e navegar por elas. Caso tenha algo específico em mente, pule para a parte que te interessar.\nPara usar o guia, portanto, navegue pelo conteúdo, tente entender cada código, reproduzindo e adaptando exemplos, e siga pelas seções. O material avança rapidamente, o que pode tornar necessário ir e voltar várias vezes no texto. Caso tenha dúvidas, use o bom e velho Ctrl+f para procurar um tópico específico. Outra dica: use o www.google.com para procurar coisas que não encontrar aqui; na esmagadora maioria das vezes, ele terá uma resposta para te oferecer.\n1.1 Instruções gerais de leitura do código\r\rTudo o que estiver em caixa cinza, com texto destacado por cores, é código e pode ser executado (copie e cole no R);\rTudo o que estiver em caixa branca, sem destaque no texto, é output do R;\rAlguns códigos dependem de códigos anteriores; caso encontre algum erro ao rodar um código de exemplo, tente voltar atrás e rodar o código anterior.\r\r\r1.2 Instruções sobre o guia\r\rTente reproduzir cada exemplo e procure entender o que cada código produz;\rTeste variações dos exemplos, mude parâmetros, valores, etc.;\rCombine materiais de diferentes seções;\rNa maioria das vezes, explicações não ajudam a entender um código; aprender por exemplos é muito mais fácil; caso tenha dúvidas, repita os códigos.\r\r\r1.3 Requisitos\rNão é necessário nada além de ter uma versão do R instalada no computador para reproduzir e testar o código disponível nos exemplos. Caso não disponha de uma, tente usar o R online pelo site:\n\rhttp://www.r-fiddle.org/\r\r\r\r2 Básico\r2.1 O console\rAbrindo diretamente o R, a primeira coisa que vemos nele é um console - que nada mais é do que uma caixa de texto onde colocamos nosso código. Experimente digitar, por exemplo, 2 ali.\n2\r## [1] 2\rO R reproduzirá o 2 digitado seguido de # e [], geralmente com algum número dentro. No primeiro caso, # indica um comentário: tudo o que vem sucedido de # o R não executará.\n# Isto é um comentário\r# O 2, abaixo, não é um comentário\r2\r## [1] 2\r# O 2, abaixo, é um comentário\r# 2\rO R também serve como calculadora: basta usar operadores matemáticos e números. Aqui vão alguns exemplos (tente outros).\n2 +2 # adição\r## [1] 4\r2 -2 # subtração\r## [1] 0\r2 /2 # divisão\r## [1] 1\r2 *2 # multiplicação\r## [1] 4\r2^2 # 2 ao quadrado\r## [1] 4\r2^3 # 2 ao cubo\r## [1] 8\r3 %/%2 # divisão sem resto\r## [1] 1\r3 %%2 # resto da divisão\r## [1] 1\r\r2.2 Funções\rO R também possui muitas funções - parte da potencialidade dele vem daí, aliás. Funções servem para realizar ações no R, como calcular a raiz quadrada de um número.\n# a funcao sqrt() retorna a raiz quadrada de um número\rsqrt(4) # raiz quadrado de 4\r## [1] 2\rOutros exemplos de funções.\nlog(4) # logaritmo natural de 4\r## [1] 1.386294\rlog10(4) # logaritmo base 10 de 4\r## [1] 0.60206\rsum(2, 2) # soma dois ou mais números\r## [1] 4\r\r2.3 Criando objeto\rPodemos armazenar objetos no R com o operador \u0026lt;- (menor seguido de hífen). Basicamente, ele diz ao R para armazenar um valor num objeto para podermos acessá-lo posteriormente. Podemos salvar o número 2 num objeto x.\nx \u0026lt;-2\rE depois usá-lo diretamente para realizar outras operações.\nx\r## [1] 2\rx +1\r## [1] 3\rx /2\r## [1] 1\rx^2\r## [1] 4\rTambém podemos armazenar texto num objeto.\ntexto \u0026lt;-\u0026quot;texto\u0026quot;\rtexto\r## [1] \u0026quot;texto\u0026quot;\rx \u0026lt;-\u0026quot;outro texto\u0026quot;\rx\r## [1] \u0026quot;outro texto\u0026quot;\rA função print() nos permite visualizar o conteúdo armazenado num objeto (digitar o nome dele no console e executar é o equivalente disso, mas print pode ser útil em algumas situações).\nprint(texto)\r## [1] \u0026quot;texto\u0026quot;\rprint(x)\r## [1] \u0026quot;outro texto\u0026quot;\r\r2.4 Classes\rNo R, cada tipo de informação possui uma classe. Números são numeric ou integer (para números inteiros); texto é character (também pode ser factor). Também existem valores lógicos (TRUE ou FALSE, ou T e F, respectivamente), complexos, etc. Vamos ver os mais comuns.\nclass(\u0026quot;a\u0026quot;) # \u0026quot;a\u0026quot; é character\r## [1] \u0026quot;character\u0026quot;\ris.character(\u0026quot;a\u0026quot;) # \u0026quot;a\u0026quot; é character\r## [1] TRUE\rclass(2) # é numeric\r## [1] \u0026quot;numeric\u0026quot;\ris.numeric(2) # é numeric\r## [1] TRUE\rclass(2L) # 2L (o L força o número a ficar inteiro) é integer\r## [1] \u0026quot;integer\u0026quot;\ris.integer(2L) # 2L é integer\r## [1] TRUE\rclass(TRUE) # TRUE é logical\r## [1] \u0026quot;logical\u0026quot;\ris.logical(TRUE) # TRUE é logical\r## [1] TRUE\rValores lógicos são úteis para fazer testes relacionais (comparações) com valores. Podemos verificar se 2 é maior que 1, por exemplo.\n2 \u0026gt;1\r## [1] TRUE\rOu se 2 é maior que 3.\n2 \u0026gt;3\r## [1] FALSE\rOutros operadores relacionais úteis.\n2 \u0026gt;1 # maior\r## [1] TRUE\r2 \u0026lt;1 # menor\r## [1] FALSE\r2 \u0026gt;=1 # maior ou igual\r## [1] TRUE\r2 \u0026lt;=1 # menor ou igual\r## [1] FALSE\r2 ==1 # igual (note que existem dois '=' aqui)\r## [1] FALSE\r2 !=1 # diferente\r## [1] TRUE\r!TRUE # inverso (não é bem um operador, mas é útil para inverter o resultado de um operador)\r## [1] FALSE\r\r2.5 Recomendações\rPodemos criar objetos e realizar operações no R de forma simples, como vimos. No entanto, algumas coisas devem ser evitadas quando escrevemos nosso código, seja para evitar erros ou para facilitar a compreensão.\nA recomendação mais básica neste sentido é: evite criar objetos com nomes que comecem com números, caracteres especiais ou nomes de funções. Algumas destas coisas produzirão erros imediatos; outras, podem complicar códigos inteiros. Alguns exemplos.\n# Exemplos de nomes de objetos que produzem erros\r2x \u0026lt;-1\r_x \u0026lt;-1\r\u0026amp;x \u0026lt;-1\r# Exemplos de nomes de objetos que não produzem erros imediatos\rclass \u0026lt;-1\rprint \u0026lt;-1\r## Error: \u0026lt;text\u0026gt;:2:2: unexpected symbol\r## 1: # Exemplos de nomes de objetos que produzem erros\r## 2: 2x\r## ^\rTambém note que o R é case sensitive, o que significa que A não é a mesma coisa que a.\nA \u0026lt;-1\rprint(a)\r## Error in print(a): objeto 'a' não encontrado\rSempre que criar um objeto armazenando texto, não esqueça das aspas (outra forma de cometer erros no R bastante comum).\nx \u0026lt;-texto\rx \u0026lt;-\u0026quot;texto\u0026quot;\rx\r## [1] \u0026quot;texto\u0026quot;\rPor fim, sempre que abrir parênteses, não esqueça de fechá-los (caso contrário, aparecerá um + no console, indicando que o R espera mais conteúdo). Estas e outras recomendações comuns para evitar erros podem ser vistas aqui (em inglês).\n\r2.6 Estilo\rIsto não é mandatório, mas algumas noções de estilo - i.e., de como organizar o código - nos ajudam a compreender e partilhar códigos, tanto nossos quanto os de outras pessoas. Resumidamente, as principais considerações aqui são:\n\rUse espaços entre objetos, operadores e chamadas a funções;\rUse quebra de linhas para separar blocos de códigos;\rSempre que possível, crie objetos apenas com letras minúsculas;\rSe precisar separar o nome de um objeto, use _ (underscore);\rPrefira nomes curtos para objetos;\rPrefira o atribuidor \u0026lt;- a = (eles fazem a mesma coisa).\r\rExemplos.\nx\u0026lt;-1 # Ruim\rx \u0026lt;-1 # OK\rx+x+x+x # Ruim\rx +x +x +x # OK\rprint (x) # Ruim\rprint(x) # OK\rx =1 # Ruim\rx \u0026lt;-1 # OK\rOBJETO \u0026lt;-1 # Ruim\robjeto \u0026lt;-1 # OK\rmeu.objeto \u0026lt;-1 # Ruim\rmeu_objeto \u0026lt;-1 # OK\robjeto_com_nome_excessivamente_grande \u0026lt;-1 # Ruim\robjeto \u0026lt;-1 # OK\rUm guia completo de estilo, em inglês, pode ser encontrado neste link.\n\r\r3 Vetores\r3.1 Vetores\rPodemos armazenar mais de um valor num objeto: para isto, criamos um vetor. Vetores armazenam uma sequência de valores em ordem, e cada um fica salvo num elemento do vetor. Usamos a função c para criar um vetor.\nx \u0026lt;-c(1, 2, 3) # vetor com três elementos numéricos\ry \u0026lt;-c(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;) # vetor com três elementos de texto\rPodemos realizar operações com vetores da mesma forma que com valores únicos (na verdade, valores únicos são vetores com apenas um elemento). Tente outras além destas.\nx \u0026lt;-c(1, 2, 3, 4, 5)\rx +1\r## [1] 2 3 4 5 6\rx -1\r## [1] 0 1 2 3 4\rx^2\r## [1] 1 4 9 16 25\rc(1, 2, 3) +c(1, 2, 3)\r## [1] 2 4 6\rOutras formas de criar vetores.\nseq(1, 10, by = 1) # cria um vetor de 1 a 10\r## [1] 1 2 3 4 5 6 7 8 9 10\rseq(1, 10, by = 0.5) # vetor de 1 a 10 com intervalos de 0.5\r## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5\r## [15] 8.0 8.5 9.0 9.5 10.0\rrep(1, 10) # vetor com 10 elementos, todos iguais a 1\r## [1] 1 1 1 1 1 1 1 1 1 1\rrep(c(1, 2), 5) # vetor com 10 elementos, c(1, 2) repetidos 5 vezes\r## [1] 1 2 1 2 1 2 1 2 1 2\rrep(c(1, 2), each = 5) # vetor com 10 elementos, 1 repetido 5 vezes, 2 repetido 5 vezes\r## [1] 1 1 1 1 1 2 2 2 2 2\r1:10 # vetor de 1 a 10\r## [1] 1 2 3 4 5 6 7 8 9 10\r10:1 # vetor de 10 a 1\r## [1] 10 9 8 7 6 5 4 3 2 1\rnumeric(10) # vetor com 10 elementos\r## [1] 0 0 0 0 0 0 0 0 0 0\rx \u0026lt;-c(1, 2)\ry \u0026lt;-c(x, 3)\ry # vetor com tres elementos\r## [1] 1 2 3\rx \u0026lt;-c(1, 2)\ry \u0026lt;-c(1, 2)\rz \u0026lt;-c(x, y, 1, 2) # vetor com seis elementos\rz \u0026lt;-c(z, z) # vetor com 12 elementos\rw \u0026lt;-rnorm(10) # vetor com 10 elementos gerados aleatoriamente (distribuição normal, média 0)\rPara saber o tamanho ou a classe de um vetor, usamos length e class (que já vimos).\nx \u0026lt;-1:100\rlength(x) # número de elementos de x\r## [1] 100\rclass(x) # classe de x (integer)\r## [1] \u0026quot;integer\u0026quot;\rtamanho_x \u0026lt;-length(x) # salva o tamanho de x num novo objeto\r\r3.2 Indexação\rAcessamos um ou mais elementos de um vetor com []. O jeito mais fácil de fazer isto é passar a posição do elemento para dentro dos colchetes.\nx \u0026lt;-c(1, 5, 10, 15, 20)\rx\r## [1] 1 5 10 15 20\rx[1] # acessa o primeiro elemento do vetor\r## [1] 1\rx[3] # acessa o terceiro elemento do vetor\r## [1] 10\rx[1 +1] # acessa o segundo elemento do vetor\r## [1] 5\rx[length(x)] # acessa o último elemento do vetor\r## [1] 20\rx[c(1, 2)] # acessa o primeiro e o segundo elementos do vetor\r## [1] 1 5\rx[c(1, 3, length(x))] # acessa o primeiro, o terceiro e o último elementos do vetor\r## [1] 1 10 20\rx[-2] # acessa todos os elementos do vetor, menos o segundo\r## [1] 1 10 15 20\rx[-c(1, 2)] # acessa todos os elementos do vetor, menos o primeiro e o segundo\r## [1] 10 15 20\rOutro jeito, mais prático em algumas situações, é passar um vetor com valores lógicos de mesmo tamanho do vetor original para dentro dos colchetes.\nx \u0026lt;-c(1, 2, 3)\rx\r## [1] 1 2 3\rx[c(TRUE, FALSE, FALSE)] # acessa o primeiro elemento\r## [1] 1\rx[c(FALSE, TRUE, FALSE)] # acessa o segundo elemento\r## [1] 2\rx[c(T, F, T)] # acessa o primeiro e o último elementos\r## [1] 1 3\rCombinando operadores relacionais e vetores, podemos selecionar elementos de acordo com algum critério (como acessar apenas elementos maiores que 2).\nx \u0026lt;-c(1, 2, 3, 4, 5)\rx\r## [1] 1 2 3 4 5\rx \u0026gt;3\r## [1] FALSE FALSE FALSE TRUE TRUE\rx[x \u0026gt;3] # acessa apenas elementos maiores que 3\r## [1] 4 5\rx[x ==2] # acessa apenas elementos iguais a 2\r## [1] 2\rx[x ==1 |x ==5] # acessa apenas elementos iguais a 1 ou elementos iguais a 5\r## [1] 1 5\rx[x \u0026gt;2 \u0026amp;x \u0026lt;4] # acessa apenas elementos maiores que 2 e menores que 4\r## [1] 3\rx[x !=3] # acessa apenas elementos diferentes de 3\r## [1] 1 2 4 5\rO mesmo vale para vetores com character.\nvec \u0026lt;-c(\u0026quot;a\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;e\u0026quot;)\rvec\r## [1] \u0026quot;a\u0026quot; \u0026quot;c\u0026quot; \u0026quot;e\u0026quot;\rvec[vec ==\u0026quot;a\u0026quot;] # acessa apenas elementos iguais a \u0026quot;a\u0026quot;\r## [1] \u0026quot;a\u0026quot;\rvec[vec !=\u0026quot;c\u0026quot;] # acessa apenas elementos diferentes de \u0026quot;c\u0026quot;\r## [1] \u0026quot;a\u0026quot; \u0026quot;e\u0026quot;\r\r3.3 Manipulação de vetores\rSabendo como criar objetos e indexar vetores, combinamos as duas coisas para modificar e realizar operações com vetores. Um exemplo: alterar o valor do primeiro elemento de um vetor.\nx \u0026lt;-1:5\rx[1] \u0026lt;-99 # muda o valor do primeiro elemento do vetor para 99\rx\r## [1] 99 2 3 4 5\rx[c(1, 2)] \u0026lt;-c(99, 100) # muda o valor do primeiro e do segundo elementos do vetor\rMas também podemos modificar elementos baseados numa condição (operadores relacionais novamente).\nx \u0026lt;-1:10\rx[x \u0026lt;5] \u0026lt;-99\rx\r## [1] 99 99 99 99 5 6 7 8 9 10\ry \u0026lt;-letters[1:5]\ry[y ==\u0026quot;a\u0026quot;] \u0026lt;-\u0026quot;X\u0026quot;\ry\r## [1] \u0026quot;X\u0026quot; \u0026quot;b\u0026quot; \u0026quot;c\u0026quot; \u0026quot;d\u0026quot; \u0026quot;e\u0026quot;\rz \u0026lt;-rnorm(100)\rz[z \u0026gt;0 \u0026amp;z \u0026lt;1] \u0026lt;-99\rz\r## [1] 1.51178117 99.00000000 -0.62124058 -2.21469989 1.12493092\r## [6] -0.04493361 -0.01619026 99.00000000 99.00000000 99.00000000\r## [11] 99.00000000 99.00000000 99.00000000 -1.98935170 99.00000000\r## [16] -0.05612874 -0.15579551 -1.47075238 -0.47815006 99.00000000\r## [21] 1.35867955 -0.10278773 99.00000000 -0.05380504 -1.37705956\r## [26] -0.41499456 -0.39428995 -0.05931340 1.10002537 99.00000000\r## [31] -0.16452360 -0.25336168 99.00000000 99.00000000 -0.68875569\r## [36] -0.70749516 99.00000000 99.00000000 -0.11234621 99.00000000\r## [41] 99.00000000 -0.61202639 99.00000000 -1.12936310 1.43302370\r## [46] 1.98039990 -0.36722148 -1.04413463 99.00000000 -0.13505460\r## [51] 2.40161776 -0.03924000 99.00000000 99.00000000 -0.74327321\r## [56] 99.00000000 -1.80495863 1.46555486 99.00000000 2.17261167\r## [61] 99.00000000 -0.70994643 99.00000000 -0.93409763 -1.25363340\r## [66] 99.00000000 -0.44329187 99.00000000 99.00000000 -0.58952095\r## [71] -0.56866873 -0.13517862 1.17808700 -1.52356680 99.00000000\r## [76] 99.00000000 1.06309984 -0.30418392 99.00000000 99.00000000\r## [81] -0.54252003 1.20786781 1.16040262 99.00000000 1.58683345\r## [86] 99.00000000 -1.27659221 -0.57326541 -1.22461261 -0.47340064\r## [91] -0.62036668 99.00000000 -0.91092165 99.00000000 -0.65458464\r## [96] 1.76728727 99.00000000 99.00000000 99.00000000 1.68217608\rPartindo destas operações mais simples, podemos criar condições mais complexas - como transformar apenas números pares em 0.\nx \u0026lt;-1:100\rx[x %%2 ==0] \u0026lt;-0 # número maior que 0 que seja divisível por 2 sem resto é par\rx\r## [1] 1 0 3 0 5 0 7 0 9 0 11 0 13 0 15 0 17 0 19 0 21 0 23\r## [24] 0 25 0 27 0 29 0 31 0 33 0 35 0 37 0 39 0 41 0 43 0 45 0\r## [47] 47 0 49 0 51 0 53 0 55 0 57 0 59 0 61 0 63 0 65 0 67 0 69\r## [70] 0 71 0 73 0 75 0 77 0 79 0 81 0 83 0 85 0 87 0 89 0 91 0\r## [93] 93 0 95 0 97 0 99 0\r\r3.4 Conversão de vetores\rVetores não armazenam informações de diferentes classes - ao fim, elas são transformadas para uma das classes existentes. Teste variações dos exemplos abaixo para entender como o R força essas conversões.\nx \u0026lt;-c(1, \u0026quot;a\u0026quot;) x # o número 1 vira texto \u0026quot;1\u0026quot;\r## [1] \u0026quot;1\u0026quot; \u0026quot;a\u0026quot;\rclass(x) # character\r## [1] \u0026quot;character\u0026quot;\rx \u0026lt;-c(1, TRUE, FALSE)\rx # TRUE é convertido para 1; FALSE é convertido para 0\r## [1] 1 1 0\rclass(x) # numeric\r## [1] \u0026quot;numeric\u0026quot;\rx \u0026lt;-c(1L, 2.3)\rx # 1L (integer) é convertido para decimal (numeric)\r## [1] 1.0 2.3\rclass(x) # numeric\r## [1] \u0026quot;numeric\u0026quot;\rx \u0026lt;-c(TRUE, \u0026quot;a\u0026quot;)\rx # TRUE vira texto \u0026quot;TRUE\u0026quot;\r## [1] \u0026quot;TRUE\u0026quot; \u0026quot;a\u0026quot;\rclass(x) # character\r## [1] \u0026quot;character\u0026quot;\rResumindo a conversão de classes básicas:\n\rcharacter tem precedência sobre as outras classes;\rlogical pode ser convertido para numeric;\rinteger pode ser convertido para numeric (ganha casas decimais).\r\rNo R, existem algumas funções para converter explicitamente um classe em outra. Seguem algumas.\nx \u0026lt;-c(1.1, 2.2, 3.3, 4.4, 5.5)\rclass(x) # numeric\r## [1] \u0026quot;numeric\u0026quot;\rx \u0026lt;-as.integer(x)\rx\r## [1] 1 2 3 4 5\rclass(x) # agora é integer\r## [1] \u0026quot;integer\u0026quot;\rx \u0026lt;-as.character(x)\rx\r## [1] \u0026quot;1\u0026quot; \u0026quot;2\u0026quot; \u0026quot;3\u0026quot; \u0026quot;4\u0026quot; \u0026quot;5\u0026quot;\rclass(x) # agora é character\r## [1] \u0026quot;character\u0026quot;\rx \u0026lt;-as.numeric(x) # converte de character para numeric\rx\r## [1] 1 2 3 4 5\rclass(x)\r## [1] \u0026quot;numeric\u0026quot;\rx \u0026lt;-as.integer(x) # converte de numeric para integer\rclass(x)\r## [1] \u0026quot;integer\u0026quot;\rx \u0026lt;-as.logical(x) # converte x para logical (tudo o que for diferente de 0 vira TRUE)\rx\r## [1] TRUE TRUE TRUE TRUE TRUE\rclass(x)\r## [1] \u0026quot;logical\u0026quot;\rAinda assim, não podemos fazer conversões como esta.\nx \u0026lt;-c(\u0026quot;Texto\u0026quot;)\ras.numeric(x)\r## Warning: NAs introduzidos por coerção\r## [1] NA\rNeste caso, x vira NA, que é valor logical especial no R para representar missings (valores ausentes). Como o NA, o R também possui alguns valores especiais. Vamos vê-los na sequência.\n\r3.5 Valores especiais\rComo dito anteriormente, NA é um valor logical particular, e serve para indicar missings. Mas, apesar de ser logical (TRUE ou FALSE), ele não muda a classe de um vetor de outro tipo. Exemplo.\nx \u0026lt;-NA\rclass(x) # NA é logical\r## [1] \u0026quot;logical\u0026quot;\rclass(NA) # NA é logical\r## [1] \u0026quot;logical\u0026quot;\rx \u0026lt;-c(1, 2, 3, NA)\rclass(x) # mas 'x' é numeric\r## [1] \u0026quot;numeric\u0026quot;\rz \u0026lt;-c(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, NA)\rclass(z) # e z é character\r## [1] \u0026quot;character\u0026quot;\rclass(z[3]) # assim como o terceiro elemento de z, que armazena o NA\r## [1] \u0026quot;character\u0026quot;\rBasicamente, isto significa que o NA pode ser convertido para qualquer classe a partir de logical e que, no fundo, ele serve para dizer o seguinte: o R não sabe qual valor NA deve assumir, mas certamente é um valor da mesma classe do restante do vetor (afinal, todos os elementos de um vetor precisam ser da mesma classe).\nx \u0026lt;-NA\rx \u0026lt;-as.integer(NA)\rclass(x) # NA agora é integer\r## [1] \u0026quot;integer\u0026quot;\rx \u0026lt;-NA\rx \u0026lt;-as.character(NA)\rclass(x) # NA agora é character\r## [1] \u0026quot;character\u0026quot;\rPodemos testar se um valor ou objeto é NA com a função is.na (este é o método mais apropriado de fazer isto, por sinal).\nx \u0026lt;-c(1, 2, NA)\ris.na(x[3]) # como testar se um valor é NA\r## [1] TRUE\rx[3] ==NA # como NÃO testar se um valor é NA\r## [1] NA\rNote também que qualquer operação feita num objeto NA retorna NA (às vezes também dá erro).\nNA +1\r## [1] NA\rNA /2\r## [1] NA\rOutros valores especiais são Inf, para positivo e negativo infinito, e NaN, que literalmente significa “não é um número” (not a number). Exemplos.\n# Exemplos de números infinitos\rInf +1\r## [1] Inf\r-Inf +1\r## [1] -Inf\r1 /0\r## [1] Inf\rx \u0026lt;-Inf\rclass(x) # infinito é numeric\r## [1] \u0026quot;numeric\u0026quot;\ris.infinite(x) # mas infinito\r## [1] TRUE\r# Exemplos de not a number\rlog(-2) # não existe log de números negativos\r## Warning in log(-2): NaNs produzidos\r## [1] NaN\r0 /0\r## [1] NaN\rx \u0026lt;-NaN\rclass(x) # NaN também é numeric\r## [1] \u0026quot;numeric\u0026quot;\ris.nan(x)\r## [1] TRUE\rOutro valor, este não tão comum (a depender da aplicação): o NULL, que indica um objeto nulo, ou vazio, sem classe e sem valores.\nclass(NULL) # classe \u0026quot;NULL\u0026quot;\r## [1] \u0026quot;NULL\u0026quot;\rNULL +1 # vira NULL\r## numeric(0)\rc(1, 2, 3, NULL) # desaparece do fim do vetor\r## [1] 1 2 3\ris.null(NULL) # maneira de testar se um objeto é NULL\r## [1] TRUE\rComo um objeto NULL, por definição, é vazio, podemos usar este valor especial para apagar o conteúdo de objetos de outras classes.\nx \u0026lt;-c(1, 2, 3)\rx \u0026lt;-NULL\rx # apaga o vetor x\r## NULL\rMas perceba que isto não funciona para apagar elementos dentro de um vetor. Para remover um objeto da memória no R, contudo, usamos a função rm - é só passar para ela o nome do objeto que queremos remover.\nx \u0026lt;-c(1, 2, 3)\rrm(x)\rÉ importante reconhecer estes valores especiais para, se preciso, podermos alterá-los: como quando precisamos transformar missings em outras coisas.\nx \u0026lt;-c(2, 5.6, 24, 45, 89.23, NA)\ris.na(x)\r## [1] FALSE FALSE FALSE FALSE FALSE TRUE\rx[is.na(x)] \u0026lt;-999 # trocamos o NA por 999\rx\r## [1] 2.00 5.60 24.00 45.00 89.23 999.00\r\r\r4 Estatística básica\rVetores numéricos ou inteiros armazenam números que podem ser analisados estatisticamente. E, para tanto, o R oferece um conjunto de funções nativas para realizar as mais diversas análises e testes.\nVimos funções anteriormente, mas cabe lembrar que elas (como funções na matemática) recebem uma informação (no R, geralmente um objeto) e retornam outra. Dá para saber se um objeto é uma função pelas funções class e is.function.\nclass(mean) # mean() é uma função\r## [1] \u0026quot;function\u0026quot;\ris.function(mean)\r## [1] TRUE\rclass(class) # assim como a própria função class() é uma função\r## [1] \u0026quot;function\u0026quot;\ris.function(class)\r## [1] TRUE\ris.function(is.function) # ou como is.function() é uma função\r## [1] TRUE\rAlgumas das estatísticas descritivas mais usadas.\n# Criamos um vetor aleatoriamente com distribuição normal e média 0\rx \u0026lt;-rnorm(100)\rmean(x) # média de x\r## [1] -0.01984126\rmedian(x) # mediana de x\r## [1] -0.1679293\rweighted.mean(x, x) # média ponderada (o segundo x deve ser um vetor com os pesos)\r## [1] -50.3858\rsd(x) # desvio-padrão de x\r## [1] 1.004698\rmax(x) # máxima de x\r## [1] 2.497662\rmin(x) # mínima de x\r## [1] -2.285236\rquantile(x) # quantis de x\r## 0% 25% 50% 75% 100% ## -2.2852355 -0.6394764 -0.1679293 0.5236411 2.4976616\rsummary(x) # retorna várias estatísticas básicas de uma só vez\r## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -2.28500 -0.63950 -0.16790 -0.01984 0.52360 2.49800\r4.1 Aninhando funções\rÀs vezes, uma forma prática de usar funções é aninhando elas, isto é, passando uma função para dentro de outra. Exemplo.\nmean(seq(1, 10))\r## [1] 5.5\rComo dá para intuir, seq(1, 10) cria um vetor de 1 a 10 e, diretamente, este vetor é passado para dentro da função mean - sem a necessidade de salvar o resultado de seq(1, 10) num objeto para, então, passá-lo para a função mean.\nEste uso aninhado de funções pode ir além.\nc(1, 2, c(1, 2, c(1, 2, c(1, 2, c(1, 2, c(1, 2))))))\r## [1] 1 2 1 2 1 2 1 2 1 2 1 2\rMas, à medida que vamos aninhando funções, fica mais difícil entender o código. É por esta razão, principalmente, que o aninhamento de funções é melhor usado apenas em tarefas mais simples.\n\r4.2 Argumentos opcionais\rA maioria das funções no R-base possui argumentos opcionais que podem ser alterarados para atender a alguma necessidade. Geralmente, passamos estes argumentos para dentro das funções via =, como abaixo.\nx \u0026lt;-c(1, 2, 3, 4, NA)\rmean(x) # retorna NA\r## [1] NA\rmean(x, na.rm = TRUE) # na.rm = TRUE para ignorar os NA\r## [1] 2.5\rO uso de cada função, com a documentação completa dos argumentos opcionais, pode ser visto com via função help: basta passar o nome da função desejada para ela.\nhelp(mean)\r\r\r5 Gráficos\r5.1 Histogramas\rO R também possui um potente arsenal nativo de implementações gráficas. Como no caso das estatísticas básicas, acessamos estas ferramentais via funções. Podemos começar com uma das mais simples: o histograma.\nx \u0026lt;-rnorm(100) # cria um vetor\rhist(x) # a função hist() cria um histograma\rA função hist, assim como as demais funções gráficas nativas do R, possui diversos argumentos opcionais que nos permitem controlar a aparência do gráfico.\nIncluímos títulos e mudamos o nome dos eixos com os argumentos main, xlab e ylab, respectivamente.\nhist(x, main = \u0026quot;Um histograma\u0026quot;, xlab = \u0026quot;Eixo X\u0026quot;, ylab = \u0026quot;Eixo Y\u0026quot;)\rMudamos a cor das barras com col.\nhist(x, main = \u0026quot;Um histograma\u0026quot;, xlab = \u0026quot;Eixo X\u0026quot;, ylab = \u0026quot;Eixo Y\u0026quot;, col = \u0026quot;red\u0026quot;)\rE a espessura das barras (i.e., o número de elementos por barra) com breaks.\nhist(x, main = \u0026quot;Um histograma\u0026quot;, xlab = \u0026quot;Eixo X\u0026quot;, ylab = \u0026quot;Eixo Y\u0026quot;, col = \u0026quot;red\u0026quot;, breaks = 50)\rPara organizar melhor o código, podemos quebrá-lo em linhas - nada mudará na sua execução, mas fica visualmente mais simples de entender o que estamos fazendo.\nhist(x, main = \u0026quot;Um histograma\u0026quot;,\rxlab = \u0026quot;Eixo X\u0026quot;,\rylab = \u0026quot;Eixo Y\u0026quot;,\rcol = \u0026quot;red\u0026quot;,\rbreaks = 50)\r\r5.2 Scatterplots\rPara visualizar relações bivariadas, o gráfico de pontos (scatterplot) geralmente é a melhor opção. Criamos ele com a função plot.\nx \u0026lt;-rnorm(100)\ry \u0026lt;-rnorm(100)\rplot(y ~x)\r# plot(x, y) é a mesma coisa\rTambém podemos alterar uma série de elementos do gráfico. Vamos, novamente, mudar títulos e cores.\nplot(y ~x, main = \u0026quot;Um scatterplot\u0026quot;, xlab = \u0026quot;Eixo X\u0026quot;,\rylab = \u0026quot;Eixo Y\u0026quot;,\rcol = \u0026quot;red\u0026quot;)\rAinda podemos alterar o formato dos eixos - deixando-os abertos, por exemplo.\nplot(y ~x, main = \u0026quot;Um scatterplot\u0026quot;, xlab = \u0026quot;Eixo X\u0026quot;,\rylab = \u0026quot;Eixo Y\u0026quot;,\rcol = \u0026quot;red\u0026quot;,\rbty = \u0026quot;n\u0026quot;)\rE depois mudar o formato dos pontos.\nplot(y ~x, main = \u0026quot;Um scatterplot\u0026quot;, xlab = \u0026quot;Eixo X\u0026quot;,\rylab = \u0026quot;Eixo Y\u0026quot;,\rcol = \u0026quot;red\u0026quot;,\rbty = \u0026quot;n\u0026quot;,\rpch = 2) # pch muda o formato dos pontos\rOs valores mais comuns de pch são (veja outros aqui):\n\r0, para quadrado vazado;\r1, para círculo vazado;\r2, para triângulo vazado;\r16, para círculo pequeno sólido;\r19, para círulo grande sólido.\r\r\r5.3 Line plots\rGráficos de linhas, frequentemente usados para plotar séries temporais, também são criados com a função plot.\nx \u0026lt;-1:20\ry \u0026lt;-rnorm(20)\rplot(y ~x, type = \u0026quot;l\u0026quot;)\rUma vez que o gráfico esteja criado, podemos adicionar novas linhas a ele com a função lines.\nx \u0026lt;-1:20\ry \u0026lt;-rnorm(20)\rplot(y ~x, type = \u0026quot;l\u0026quot;)\rz \u0026lt;-rnorm(20)\rlines(z, col = \u0026quot;red\u0026quot;)\r\r5.4 Pontos e linhas\rPara combinar pontos e linhas, basta usar o argumento opcional type = \u0026quot;b\u0026quot;.\nx \u0026lt;-1:20\ry \u0026lt;-rnorm(20)\rplot(y ~x, type = \u0026quot;b\u0026quot;)\r\r5.5 Boxplot\rEm algumas situações, precisamos plotar a distribuição de uma variável por grupos: por exemplo, queremos saber a distribuição da nota dos(as) alunos(as) de duas escolas diferentes. Aqui vai um exemplo de como criar um boxplot mais simples, primeiro.\n# Boxplot com uma só variável\rx \u0026lt;-rnorm(100)\rboxplot(x)\rAgora um exemplo por grupos (precisamos de um vetor que indique quais são estes grupos).\nx \u0026lt;-rnorm(100)\rgrupos \u0026lt;-rep(c(\u0026quot;Grupo A\u0026quot;, \u0026quot;Grupo B\u0026quot;), each = 50)\rboxplot(x ~grupos, main = \u0026quot;Um boxplot\u0026quot;)\r\r5.6 Gráficos de barras\rPor fim, vamos ver como criar gráficos de barras - aqueles gráficos onde cada grupo no eixo X é representado por uma barra indicando o valor dela no eixo Y. Para criar estes gráficos, usamos duas funções combinadas: table, para criar uma tabela de frequência, e plot ou barplot, para plotar o gráfico.\ngrupoA \u0026lt;-rep(\u0026quot;Grupo A\u0026quot;, 30)\rgrupoB \u0026lt;-rep(\u0026quot;Grupo B\u0026quot;, 20)\rgrupoC \u0026lt;-rep(\u0026quot;GrupoC\u0026quot;, 9)\rgrupos \u0026lt;-c(grupoA, grupoB, grupoC)\rgrupos \u0026lt;-table(grupos) # table cria uma tabela de frequência\rgrupos\r## grupos\r## Grupo A Grupo B GrupoC ## 30 20 9\rplot(grupos) # cria uma gráfico de barras com plot\rbarplot(grupos) # cria um gráfico de barras com barplot\r\r5.7 Mais gráficos\rO R-base possui muitas outras opções de gráficos e de funções que, entre outros, nos permitem fazer gráficos como este.\nPara saber mais sobre gráficos no R-base, um bom guia pode ser visto aqui. Também use a função help para obter ajuda sobre argumentos opcionais de cada função.\n\r\r6 Regressão linear\rRegressões nos ajudam a entender a relação entre uma variável quantitativa e uma ou mais variáveis explicativas. E o modelo mais usado para realizar este tipo de análise, sem dúvidas, é a regressão linear, que modela a relação entre variáveis dependente e independente de forma linear - a reta que melhor se ajusta aos dados. No R, podemos estimar regressões como estas com a função lm, de linear model.\n6.1 Modelo bivariado\rVamos começar com um exemplo simples: modelar a relação entre dois vetores numéricos.\nx \u0026lt;-rnorm(50)\ry \u0026lt;-rnorm(50)\rmodelo \u0026lt;-lm(y ~x) # estima um modelo linear e salva os resultados no objeto 'modelo'\rclass(modelo) # a classe do objeto 'modelo' vira 'lm'\r## [1] \u0026quot;lm\u0026quot;\rsummary(modelo) # usamos a função 'summary' para exibir os resultados\r## ## Call:\r## lm(formula = y ~ x)\r## ## Residuals:\r## Min 1Q Median 3Q Max ## -2.40061 -0.66567 0.07957 0.52041 2.99862 ## ## Coefficients:\r## Estimate Std. Error t value Pr(\u0026gt;|t|)\r## (Intercept) 0.0314 0.1501 0.209 0.835\r## x 0.1527 0.1315 1.161 0.252\r## ## Residual standard error: 1.061 on 48 degrees of freedom\r## Multiple R-squared: 0.0273, Adjusted R-squared: 0.007035 ## F-statistic: 1.347 on 1 and 48 DF, p-value: 0.2515\rO output da função summary nos dá um panorama geral dos resultados do modelo. Em ordem:\n\rCall, no topo, indica a fórmula que passamos para o modelo;\rResiduals mostra a distribuição dos resíduos;\rCoefficientes reporta as estimativas do modelo:\r\rEstimate reporta os coeficientes;\rStd. Error reporta erros-padrão;\rt value reporta t valores;\rPr(\u0026gt;|t|) reporta p-valores.\r\rResidual standard error, Multiple R-squared, Adjusted R-squared e F-statistic mostram algumas estatísticas de ajustes do modelo.\r\rUsando a função plot vista anteriormente, podemos plotar a reta estimada nos dados originais.\nplot(y ~x, main = \u0026quot;Regressão linear\u0026quot;)\rabline(modelo) # a função abline toma um objeto 'lm' e plota a reta da regressão\rTambém podemos usar a função plot para termos uma noção geral do ajuste de um modelo.\nplot(modelo)\r\r6.2 Modelo multivariado\rModelos lineares podem ter mais de uma variável independente. Usamos a mesma função, lm, para fazer isto - a única coisa que modificamos é a fórmula passada ao modelo.\nx \u0026lt;-rnorm(50)\rz \u0026lt;-rnorm(50)\ry \u0026lt;-rnorm(50)\rmodelo \u0026lt;-lm(y ~x +z) # adicionamos variável com o operador '+'\rsummary(modelo)\r## ## Call:\r## lm(formula = y ~ x + z)\r## ## Residuals:\r## Min 1Q Median 3Q Max ## -1.78551 -0.60214 -0.04739 0.60877 1.91859 ## ## Coefficients:\r## Estimate Std. Error t value Pr(\u0026gt;|t|)\r## (Intercept) -0.15088 0.13230 -1.140 0.260\r## x 0.19177 0.12861 1.491 0.143\r## z -0.05275 0.12011 -0.439 0.663\r## ## Residual standard error: 0.9347 on 47 degrees of freedom\r## Multiple R-squared: 0.0471, Adjusted R-squared: 0.006552 ## F-statistic: 1.162 on 2 and 47 DF, p-value: 0.3218\rCom mais de duas variáveis independentes no modelo, visualizar a relação entre elas e a variável dependente não é tão simples: o efeito de x e z são controlados por z e x, respectivamente. O que podemos fazer é ver o efeito parcial de cada preditor com a função termplot. (Na verdade, existem várias outras maneiras de fazer isto, mas a maioria delas pressupõe conhecimentos adicionais de R; uma boa referência pode ser vista aqui).\ntermplot(modelo)\r\r6.3 Modelo com dummies\rEm algumas situações, a relação linear entre duas variáveis pode ser diferente para grupos diferentes. Nestes casos, adicionar uma variável ao modelo indicando estes grupos pode ser uma boa opção.\nx \u0026lt;-rnorm(100)\rgrupo \u0026lt;-rbinom(100, 1, prob = 0.5) # 'rbinom' serve para criar uma variavel com distribuicao binomial\ry \u0026lt;-rnorm(100) +grupo # adicionando 'grupo', 'y' sera' afetada por ela\rmodelo \u0026lt;-lm(y ~x +grupo)\rsummary(modelo)\r## ## Call:\r## lm(formula = y ~ x + grupo)\r## ## Residuals:\r## Min 1Q Median 3Q Max ## -2.27228 -0.62717 -0.02431 0.63295 2.37059 ## ## Coefficients:\r## Estimate Std. Error t value Pr(\u0026gt;|t|) ## (Intercept) 0.2996 0.1495 2.003 0.04794 * ## x -0.1147 0.1051 -1.091 0.27810 ## grupo 0.6659 0.2121 3.140 0.00224 **\r## ---\r## Signif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\r## ## Residual standard error: 1.057 on 97 degrees of freedom\r## Multiple R-squared: 0.107, Adjusted R-squared: 0.08857 ## F-statistic: 5.81 on 2 and 97 DF, p-value: 0.004137\rO output de summary já nos indica que a variável grupo tem efeito preditivo significativo sobre y. Com a função plot, podemos ter uma noção visual mais clara disto (usaremos a função points, que, assim como lines, serve para plotar pontos após um gráfico já ter sido criado).\nplot(y ~x, type = \u0026quot;n\u0026quot;) # 'type = n' plota apenas os eixos do gráfico\rpoints(y[grupo ==1] ~x[grupo ==1], col = \u0026quot;red\u0026quot;)\rpoints(y[grupo ==0] ~x[grupo ==0], col = \u0026quot;blue\u0026quot;)\rÉ possível perceber pelo gráfico que as observações em vermelho (grupo == 1) tendem a ter maiores valores no eixo Y. O que vamos fazer, agora, é plotar uma reta de regressão para cada grupo, tomando nosso modelo para fazer isto.\nUsaremos a função fitted para salvar os valores preditos do modelo e, com isto, plotaremos as retas usando a função lines (este exemplo pode parecer complicado, mas envolve apenas coisas que já vimos anteriormente; se tiver dúvidas, tente refazer este exemplo de outras maneiras, até entender).\nplot(y ~x, type = \u0026quot;n\u0026quot;, main = \u0026quot;Regressão com dummy\u0026quot;) points(y[grupo ==1] ~x[grupo ==1], col = \u0026quot;red\u0026quot;) # p\rpoints(y[grupo ==0] ~x[grupo ==0], col = \u0026quot;blue\u0026quot;)\rlines(x[grupo ==1], fitted(modelo)[grupo ==1], col = \u0026quot;red\u0026quot;)\rlines(x[grupo ==0], fitted(modelo)[grupo ==0], col = \u0026quot;blue\u0026quot;)\r\r6.4 Termos multiplicativos\rO exemplo anterior mostra como estimar uma reta para cada grupo num modelo linear, todas com a mesma inclinação. Podemos relaxar isto utilizando termos multiplicativos (x * grupo) para fazer com que cada reta se ajuste individualmente ao grupo de dados. Novamente, só modificamos a fórmula passada para a função lm para fazer isto.\nmodelo \u0026lt;-lm(y ~x *grupo) # reestimamos o modelo com o termo multiplicativo\r# Criamos novamente o gráfico\rplot(y ~x, type = \u0026quot;n\u0026quot;, main = \u0026quot;Regressão com termo multiplicativo\u0026quot;) points(y[grupo ==1] ~x[grupo ==1], col = \u0026quot;red\u0026quot;)\rpoints(y[grupo ==0] ~x[grupo ==0], col = \u0026quot;blue\u0026quot;)\rlines(x[grupo ==1], fitted(modelo)[grupo ==1], col = \u0026quot;red\u0026quot;)\rlines(x[grupo ==0], fitted(modelo)[grupo ==0], col = \u0026quot;blue\u0026quot;)\r\r6.5 Relação quadrática\rRelações entre duas variáveis nem sempre são apenas lineares: às vezes, elas assumem algum tipo de curva. Ainda que um modelo linear nem sempre seja a melhor opção para modelar relações como estas, podemos adaptá-lo para dar conta disto. A solução, neste caso, é bem simples: passamos a variável independente ao quadrado para a função lm.\nx \u0026lt;-rnorm(100)\rx2 \u0026lt;-x^2\ry \u0026lt;-x2 +rnorm(100) # adicionando 'x2' a 'y', fazemos com que a relação entre eles seja quadrática\rplot(y ~x, main = \u0026quot;Relação quadrática\u0026quot;)\rSó precisamos passar x e x2 para a fórmula na função lm para estimarmos a relação quadrática. Depois, para criarmos o gráfico, precisaremos criar dois novos vetores: 1) novo_x, que será um vetor sequencial contendo os valores máximos e mínimos de x como referências; e, 2), pred, que criaremos usando a função predict, que serve para usar um modelo que já estimamos para fazer predições em cima de novos dados (também usaremos a função list para passar x e x2 para dentro da função simultaneamente).\nmodelo \u0026lt;-lm(y ~x +x2)\rplot(y ~x, main = \u0026quot;Relação quadrática\u0026quot;)\rnovo_x \u0026lt;-seq(min(x), max(x), by = 0.1)\rpred \u0026lt;-predict(modelo, list(x = novo_x, x2 = novo_x^2))\rlines(novo_x, pred)\rO mesmo procedimento também serve para uma relação cúbica.\nx \u0026lt;-rnorm(100)\rx2 \u0026lt;-x^2\rx3 \u0026lt;-x^3\ry \u0026lt;-x3 +rnorm(100) modelo \u0026lt;-lm(y ~x +x2 +x3)\rplot(y ~x, main = \u0026quot;Relação cúbica\u0026quot;)\rnovo_x \u0026lt;-seq(min(x), max(x), by = 0.1)\rpred \u0026lt;-predict(modelo, list(x = novo_x, x2 = novo_x^2, x3 = novo_x^3))\rlines(novo_x, pred)\r\r\r7 Mais\rEste é o básico do R. Obviamente, mal tocamos na superfície das coisas que ele é capaz de fazer. Não trabalhamos, entre outros, com bancos de dados (data.frames), listas, controle de fluxo e nem com códigos desenvolvidos por outras pessoas - o que expande massivamente as possibilidades de uso do R. Algumas boas fontes sobre estas e outras coisas incluem:\n\rIntrodutórios\n\rA introdução oficial do R-project (inglês): link\n\r“Introdução ao R”, escrito por Victor Landeiro: link\n\r“Referência rápida”: link\n\r“Learn R” da CodeSchool: link\n\r\rDocumentação e manuais\n\r“Step by Step Guide to Learn Data Science on R” (inglês): link\n\r“Quick R”: link\n\r“R Documentation”: link\n\r\r\r7.1 Licença\rSe precisar citar este material, use:\n\rMEIRELES, F. (2017). R: Um guia prático. URL: http://fmeireles.com/teaching/r_um_guia_pratico.html.\n\r\n\n\r\r\r\r\r\r// add bootstrap table styles to pandoc tables\rfunction bootstrapStylePandocTables() {\r$('tr.header').parent('thead').parent('table').addClass('table table-condensed');\r}\r$(document).ready(function () {\rbootstrapStylePandocTables();\r});\r\r\r(function () {\rvar script = document.createElement(\"script\");\rscript.type = \"text/javascript\";\rscript.src = \"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\";\rdocument.getElementsByTagName(\"head\")[0].appendChild(script);\r})();\r\r\r(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\rm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\rga('create', 'UA-80581604-1', 'auto');\rga('send', 'pageview');\r\r\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"316fa4eaab8ca2b5fa616ece1b16c374","permalink":"https://fmeireles.com/r_um_guia_pratico/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/r_um_guia_pratico/","section":"","summary":"R: Um guia prático\r\r\r\r\r\r\r\r\rcode{white-space: pre;}\rdiv.sourceCode { overflow-x: auto; }\rtable.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {\rmargin: 0; padding: 0; vertical-align: baseline; border: none; }\rtable.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }\rtd.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }\rtd.sourceCode { padding-left: 5px; }\rpre, code { background-color: #f8f8f8; }\rcode  span.","tags":null,"title":"","type":"page"},{"authors":null,"categories":null,"content":" Datasets  Oversized government coalitions in Latin America Country-year data on oversized government coalitions in all 14 presidential countries in Latin America, spanning from 1979 to 2012. Data used in Oversized Government Coalitions in Latin America (BPSR).  Dataset  Codebook     Dilma Rousseff's Impeachment in the Brazilian Chamber of Deputies Data on the rollcall votes cast by all Brazilian Federal Deputies in the Impeachment process of former President Dilma Rousseff, on April 17, 2016. The dataset also contains information on Deputies' backgrounds and their previous electoral performances.  Dataset  Codebook     PhD theses defended in Brazil (1987--2016) A tidy dataset of all PhD theses defended between 1987 and 2016 in Brazilian postgraduate programs gathered from the Capes Open Data Portal.  Dataset    \n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"be566fdb6f0fa08cfea50d77a89a6b5a","permalink":"https://fmeireles.com/data/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/data/","section":"","summary":"Datasets  Oversized government coalitions in Latin America Country-year data on oversized government coalitions in all 14 presidential countries in Latin America, spanning from 1979 to 2012. Data used in Oversized Government Coalitions in Latin America (BPSR).  Dataset  Codebook     Dilma Rousseff's Impeachment in the Brazilian Chamber of Deputies Data on the rollcall votes cast by all Brazilian Federal Deputies in the Impeachment process of former President Dilma Rousseff, on April 17, 2016.","tags":null,"title":"Data","type":"page"},{"authors":null,"categories":null,"content":" Working Papers  The Distributive Politics of Cabinet Ministers Fernando Meireles  Slides     Legislative Representation in a Multilevel System: The Case of Brazil Royce Carroll; Fernando Meireles   \nBook manuscript  Usando R: Um Guia Para Cientistas Políticos Fernando Meireles; Denisson Silva  Manuscript  Book Propospectus    \nPeer-Reviewed Publications 2019  Carreiras Políticas na Câmara dos Deputados: Uma Análise Quase-Experimental. Dados - Revista de Ciências Sociais (Forthcoming). Fernando Meireles    Partisan alignment and requests for federal transfers in Brazil. Revista de Administração Pública. Fernando Meireles  PDF  Cite  DOI    2017  Magnitude eleitoral e representação de mulheres nos municípios brasileiros. Revista de Sociologia \u0026 Política. Fernando Meireles; Luciana Andrade  PDF  Cite  DOI  Scielo     Simulações de Monte Carlo no Ensino de Ciência Política. Revista Brasileira de Ciência Política. Fernando Meireles; Denisson Silva; Filipe Correa  PDF  Cite  DOI  Scielo  Code    2016  Oversized Government Coalitions in Latin America. Brazilian Political Science Review. Fernando Meireles  PDF  Cite  DOI  Scielo  Dataset    2015  Ciência Política na era do Big Data: automação na coleta de dados digitais. Política Hoje. Denisson Silva; Fernando Meireles  PDF  Cite    \nThesis  A Política Distributiva da Coalizão. PhD Thesis. Federal University of Minas Gerais. Fernando Meireles   \nOther Writings  Latin American presidents and their oversized government coalitions. Presidential-Power (blog).  Fernando Meireles    Brazil votes on Sunday for the first time since Rousseff was ousted. What will happen to her party? The Washington Post (Monkey Cage).  Fernando Meireles; Ryan Lloyd   \n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f1d044c0738ab9f19347f15c290a71a1","permalink":"https://fmeireles.com/research/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/research/","section":"","summary":"Working Papers  The Distributive Politics of Cabinet Ministers Fernando Meireles  Slides     Legislative Representation in a Multilevel System: The Case of Brazil Royce Carroll; Fernando Meireles   \nBook manuscript  Usando R: Um Guia Para Cientistas Políticos Fernando Meireles; Denisson Silva  Manuscript  Book Propospectus    \nPeer-Reviewed Publications 2019  Carreiras Políticas na Câmara dos Deputados: Uma Análise Quase-Experimental.","tags":null,"title":"Research","type":"page"},{"authors":null,"categories":null,"content":" R Packages  electionsBR R Functions to Download and Clean Brazilian Electoral Data (w/ Denisson Silva and Beatriz Costa)  CRAN  GitHub  Project website     genderBR Predict gender from Brazilian first names  CRAN  GitHub     deflateBR Simple functions to deflate nominal Brazilian Reais  CRAN  GitHub     rScielo An R package to scrape meta-data from scientific articles hosted on Scielo  GitHub     codesBR Add Brazilian municipal identifiers to a table  GitHub    \n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"6fcae98d7df3b6c44952e7b5fed181e3","permalink":"https://fmeireles.com/software/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/software/","section":"","summary":"R Packages  electionsBR R Functions to Download and Clean Brazilian Electoral Data (w/ Denisson Silva and Beatriz Costa)  CRAN  GitHub  Project website     genderBR Predict gender from Brazilian first names  CRAN  GitHub     deflateBR Simple functions to deflate nominal Brazilian Reais  CRAN  GitHub     rScielo An R package to scrape meta-data from scientific articles hosted on Scielo  GitHub     codesBR Add Brazilian municipal identifiers to a table  GitHub","tags":null,"title":"Software","type":"page"},{"authors":null,"categories":null,"content":" Classes  Análise de Big Data usando R Ciências Sociais, Federal University of Minas Gerais, UFMG (1/2017)  Syllabus     Avaliação de Políticas Públicas Gestão Pública, Federal University of Minas Gerais, UFMG (1/2017)    Gestão no Âmbito Legislativo Gestão Pública, Federal University of Minas Gerais, UFMG (2/2015)   \nShort Courses  R Para Análise e Extração de Dados Federal University of Minas Gerais, Faculdade de Direito (1/2017)    Introdução ao R MODUS, Federal University of Minas Gerais, UFMG (2/2017)\nFederal University of Viçosa, UFV (1/2017)\nMestrado Profissional em Políticas Públicas, Federal University of Pernambuco, UFPE (2/2016)\nFederal University of Minas Gerais, UFMG (2/2016)\n  Syllabus     Construção de indicadores nas Ciências Sociais Federal University of Rio Grande do Sul, UFRGS (2/2016)  Syllabus    \nResources  R: Um Guia Prático An introduction to the R programming environment (in Portuguese)  Website     Introdução ao R em 30 minutos A very short introduction to R (in Portuguese)  Slides     Mínimos Quadrados Ordinários An interactive introduction to OLS (in Portuguese)  Website    \n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"322dbaccf72a6d71f827fdb2866be935","permalink":"https://fmeireles.com/teaching/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/teaching/","section":"","summary":"Classes  Análise de Big Data usando R Ciências Sociais, Federal University of Minas Gerais, UFMG (1/2017)  Syllabus     Avaliação de Políticas Públicas Gestão Pública, Federal University of Minas Gerais, UFMG (1/2017)    Gestão no Âmbito Legislativo Gestão Pública, Federal University of Minas Gerais, UFMG (2/2015)   \nShort Courses  R Para Análise e Extração de Dados Federal University of Minas Gerais, Faculdade de Direito (1/2017)    Introdução ao R MODUS, Federal University of Minas Gerais, UFMG (2/2017)","tags":null,"title":"Teaching","type":"page"}]