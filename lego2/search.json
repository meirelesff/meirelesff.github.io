[
  {
    "objectID": "recursos.html",
    "href": "recursos.html",
    "title": "Recursos",
    "section": "",
    "text": "R for Data Science - Garrett Grolemund e Hadley Wickham\nCausal Inference: The Mixtape - Scott Cunningham"
  },
  {
    "objectID": "recursos.html#livros",
    "href": "recursos.html#livros",
    "title": "Recursos",
    "section": "",
    "text": "R for Data Science - Garrett Grolemund e Hadley Wickham\nCausal Inference: The Mixtape - Scott Cunningham"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Lego II",
    "section": "",
    "text": "Este é o website da disciplina de Lego II do IESP-UERJ. Particularmente, alguns recursos e códigos que usaremos nas nossas aulas estarão aqui. Ementa, textos e outros materiais estão nesta pasta no Google Drive."
  },
  {
    "objectID": "index.html#sobre",
    "href": "index.html#sobre",
    "title": "Lego II",
    "section": "",
    "text": "Este é o website da disciplina de Lego II do IESP-UERJ. Particularmente, alguns recursos e códigos que usaremos nas nossas aulas estarão aqui. Ementa, textos e outros materiais estão nesta pasta no Google Drive."
  },
  {
    "objectID": "aulas/aula2.html",
    "href": "aulas/aula2.html",
    "title": "Aula 2",
    "section": "",
    "text": "Em aula, estudamos Processos Geradores de Dados (PGDs) e probabilidade. Nestas notas, veremos agora como podemos usar funções de probabilidade – que, lembrando, servem para atribuir probabilidade a eventos possíveis, que chamamos de \\(\\omega\\), de um espaço amostral, que definimos como \\(\\Omega\\) – para simular dados. Isso será particularmente útil nas próximas aulas, mas também nos dará mais experiência com visualização de dados usando ggplot2.\nAntes de começar, vamos carregar o tidyverse:\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "aulas/aula2.html#introdução",
    "href": "aulas/aula2.html#introdução",
    "title": "Aula 2",
    "section": "",
    "text": "Em aula, estudamos Processos Geradores de Dados (PGDs) e probabilidade. Nestas notas, veremos agora como podemos usar funções de probabilidade – que, lembrando, servem para atribuir probabilidade a eventos possíveis, que chamamos de \\(\\omega\\), de um espaço amostral, que definimos como \\(\\Omega\\) – para simular dados. Isso será particularmente útil nas próximas aulas, mas também nos dará mais experiência com visualização de dados usando ggplot2.\nAntes de começar, vamos carregar o tidyverse:\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "aulas/aula2.html#distribuições",
    "href": "aulas/aula2.html#distribuições",
    "title": "Aula 2",
    "section": "Distribuições",
    "text": "Distribuições\nO R tem diversas funções que nos permitem sortear números de acordo com algumas distribuições. Abaixo, exemplos das mais comuns.\n\nUniformeBernoulliBinomialNormalPoisson\n\n\n\n# Sorteia um número entre 0 e 1\nrunif(1, min = 0, max = 1)\n\n[1] 0.9933472\n\n\n\n\n\n# Sorteia 1 com probabilidade 0.5\nrbinom(1, size = 1, prob = 0.5)\n\n[1] 0\n\n\n\n\n\n# Dez sequências de Bernoulli com prob. 0.5\nrbinom(1, size = 10, prob = 0.5)\n\n[1] 3\n\n\n\n\n\n# Sorteia um número de uma distribuição normal\nrnorm(1, mean = 0, sd = 1)\n\n[1] 0.8719198\n\n\n\n\n\n# Sorteia um número de uma distribuição Poisson\nrpois(1, lambda = 1)\n\n[1] 1"
  },
  {
    "objectID": "aulas/aula2.html#criando-funções-de-probabilidade",
    "href": "aulas/aula2.html#criando-funções-de-probabilidade",
    "title": "Aula 2",
    "section": "Criando funções de probabilidade",
    "text": "Criando funções de probabilidade\nAlgumas funções para sortear valores de distribuições mais complexas podem ser construídas a partir de funções mais simples. Por exemplo, podemos usar a uniforme para simular uma distribuição Bernoulli:\n\np &lt;- 0.5\nresultado &lt;- runif(1, min = 0, max = 1) &lt; p\nas.numeric(resultado)\n\n[1] 0\n\n\nO que fizemos? Basicamente, realizamos um sorteio a partir de uma distribuição \\(Uniforme(0, 1)\\) e, se ele for maior que \\(p\\), o resultistribuiçado desse sorteio é convertido para 1, caso contrário, para 0.\nPodemos fazer esse processo mil vezes para visualizar o resultado com um gráfico de barras:\n\np &lt;- 0.5\nn &lt;- 1000\nX &lt;- runif(n, min = 0, max = 1) &lt; p\nX &lt;- as.numeric(X)\n\ntibble(X = X) %&gt;%\n  ggplot(aes(x = X)) +\n  geom_bar() +\n  theme_minimal()"
  },
  {
    "objectID": "aulas/aula2.html#simulando-lançamentos-de-um-dado",
    "href": "aulas/aula2.html#simulando-lançamentos-de-um-dado",
    "title": "Aula 2",
    "section": "Simulando lançamentos de um dado",
    "text": "Simulando lançamentos de um dado\nLançamentos de um dado geralmente são simulados a partir de uma distribuição multinomial – mas, já que em um lançamento a probabilidade de tirarmos qualquer face em um sorteio é a mesma (e.g., \\(p_1 = p_2 = ... p_6\\)), podemos criar nossa própria função de probabilidade para simular esse processo usando runif novamente. A ideia é a seguinte:\n\nSortearemos um número entre 0 e 6 usando \\(X \\sim Unif(0, 6)\\)\nSe \\(0 &lt; x \\leq 1\\), o resultado é 1; se \\(1 &lt; x \\leq 2\\), o resultado é 2; e assim por diante\nRepetimos o processo \\(n\\) vezes\n\n\nn &lt;- 1000\nX &lt;- runif(n, min = 0, max = 6)\nX &lt;- ceiling(X)\n\ntibble(X = X) %&gt;%\n  ggplot(aes(x = X)) +\n  geom_bar(width = 0.5, fill = \"orangered\") +\n  theme_minimal() +\n  labs(y = \"Frequência\", x = \"Face do dado\",\n  title = \"Simulações de lançamentos de um dado\")"
  },
  {
    "objectID": "aulas/aula3.html",
    "href": "aulas/aula3.html",
    "title": "Aula 3",
    "section": "",
    "text": "interessante de testar diferentes modelos. Pela teoria, sabemos que um modelo por mínimos quadrados é um bom modelo, e sabemos como ele é calculado (e.g., ). Mas e se quisermos testar outros modelos? Como selecionamos bons modelos?"
  },
  {
    "objectID": "aulas/aula3.html#introdução",
    "href": "aulas/aula3.html#introdução",
    "title": "Aula 3",
    "section": "Introdução",
    "text": "Introdução\nModelos de regressão linear são extremamente úteis para entender a relação entre variáveis. Com ele, podemos examinar a relação linear entre duas variáveis – o que, como vimos, serve como um excelente estimador de valor esperados condicionais, desde que sejam satisfeitas os pressupostos do modelo como o da linearidade.\nPara praticar esse conteúdo, estas notas explicam como baixar e carregar o banco de dados usado por Ross (2001) e, a partir dele, rodar alguns modelos de regressão. Além disso, as notas também oferecem códigos para implementar modelos lineares – não por mínimos quadrados – e visualizá-los usando gggplot2."
  },
  {
    "objectID": "aulas/aula3.html#baixando-e-carregando-o-banco-de-dados",
    "href": "aulas/aula3.html#baixando-e-carregando-o-banco-de-dados",
    "title": "Aula 3",
    "section": "Baixando e carregando o banco de dados",
    "text": "Baixando e carregando o banco de dados\nOs dados de Ross (2001) estão no arquivo doesoil_clean.dta, em formato de Stata. Para carregá-los no R, é preciso instalar o pacote haven, que permite ler arquivos de dados de outros programas estatísticos, como Stata e SPSS. Para instalar o pacote, basta rodar:\n\ninstall.packages(\"haven\")\n\nIsso feito, para carregar o banco de dados, basta rodar:\n\nlibrary(haven)\nross &lt;- read_dta(\"doesoil_clean.dta\")\n\nO banco deve ter a seguinte cara:\n\nhead(ross)\n\n# A tibble: 6 × 59\n  cty_name    id      id1 year  year1  wdr6 wdr123 wdr135   wdr269 wdr271 wdr272\n  &lt;chr&gt;       &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan AFG       3 1966   1966  51.7  NA        NA 82316304     NA     NA\n2 Afghanistan AFG       3 1967   1967  46.4   4.41     NA 85420096     NA     NA\n3 Afghanistan AFG       3 1968   1968  38.1  12.6      NA 71818400     NA     NA\n4 Afghanistan AFG       3 1969   1969  38.1  14.9      NA 82736600     NA     NA\n5 Afghanistan AFG       3 1970   1970  35.8  16.9      NA 84589504     NA     NA\n6 Afghanistan AFG       3 1971   1971  45.7  14.6      NA 99899200     NA     NA\n# ℹ 48 more variables: wdr273 &lt;dbl&gt;, wdr313 &lt;dbl&gt;, wdr344 &lt;dbl&gt;, wdr400 &lt;dbl&gt;,\n#   wdr477 &lt;dbl&gt;, ssafrica &lt;dbl&gt;, mideast &lt;dbl&gt;, me_nafr &lt;dbl&gt;, oecd &lt;dbl&gt;,\n#   v6 &lt;dbl&gt;, agr &lt;dbl&gt;, v123 &lt;dbl&gt;, oil &lt;dbl&gt;, v313 &lt;dbl&gt;, metal &lt;dbl&gt;,\n#   regime &lt;dbl&gt;, regime1 &lt;dbl&gt;, wdr97 &lt;dbl&gt;, wdr151 &lt;dbl&gt;, wdr152 &lt;dbl&gt;,\n#   log135 &lt;dbl&gt;, milpers &lt;dbl&gt;, islam &lt;dbl&gt;, ELF &lt;dbl&gt;, Food &lt;dbl&gt;,\n#   AgrFood &lt;dbl&gt;, WDR85 &lt;dbl&gt;, WDR87 &lt;dbl&gt;, WDR88 &lt;dbl&gt;, illit &lt;dbl&gt;,\n#   life &lt;dbl&gt;, WDR409 &lt;dbl&gt;, WDR411 &lt;dbl&gt;, tv &lt;dbl&gt;, WDR86 &lt;dbl&gt;, …"
  },
  {
    "objectID": "aulas/aula3.html#regressão-linear",
    "href": "aulas/aula3.html#regressão-linear",
    "title": "Aula 3",
    "section": "Regressão linear",
    "text": "Regressão linear\nRodar modelos de regressão linear é algo simples em R. Para regredir regime em oil, as variáveis de Ross (2001) que indicam democracia e petróleo, respectivamente, basta rodar:\n\nlm(regime ~ oil, data = ross)\n\n\nCall:\nlm(formula = regime ~ oil, data = ross)\n\nCoefficients:\n(Intercept)          oil  \n     2.4037      -0.1724  \n\n\nPara facilitar a nossa inspeção dos resultados, vamos salvar o modelo em um objeto:\n\nross_lm &lt;- lm(regime ~ oil, data = ross)\n\nPodemos usar outro pacote, o brooom, para ver os resultados de forma mais direta:\n\n# Caso não tenha o pacote, rode: install.packages(\"broom\")\nlibrary(broom)\ntidy(ross_lm)\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)    2.40     0.151       15.9 1.26e-54\n2 oil           -0.172    0.0103     -16.7 6.59e-60"
  },
  {
    "objectID": "aulas/aula3.html#visualizando-modelos-lineares-simples",
    "href": "aulas/aula3.html#visualizando-modelos-lineares-simples",
    "title": "Aula 3",
    "section": "Visualizando modelos lineares simples",
    "text": "Visualizando modelos lineares simples\nO ggplot2 já nos fornece geometrias que simplificam o processo de criar um gráfico de dispersão com uma linha de regressão. Para isso, basta usar geom_smooth() como uma camada adicional de um gráfico que usa geom_point():\n\nlibrary(tidyverse)\n\nggplot(ross, aes(x = oil, y = regime)) +\n  geom_point(size = 3.4, color = \"red\", alpha = 0.3) +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  theme_minimal() +\n  labs(x = \"Petróleo (% do PIB)\", y = \"Polity (democracia)\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 1822 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 1822 rows containing missing values (`geom_point()`)."
  },
  {
    "objectID": "aulas/aula3.html#visualizando-modelos-lineares-arbitrários",
    "href": "aulas/aula3.html#visualizando-modelos-lineares-arbitrários",
    "title": "Aula 3",
    "section": "Visualizando modelos lineares arbitrários",
    "text": "Visualizando modelos lineares arbitrários\nE se eu tiver um modelo não estimado por mínimos quadrados, como visualizá-lo? Simples: basta trocar geom_smooth() por geom_abline() e passar os coeficientes do modelo como argumentos slope e intercept. Por exemplo, imagine que achamos que o melhor modelo deve ter \\(\\beta_0 = 1\\) e \\(\\beta_1 = -0.2\\):\n\nggplot(ross, aes(x = oil, y = regime)) +\n  geom_point(size = 3.4, color = \"red\", alpha = 0.3) +\n  geom_abline(slope = -0.2, intercept = 1) +\n  theme_minimal() +\n  labs(x = \"Petróleo (% do PIB)\", y = \"Polity (democracia)\")\n\nWarning: Removed 1822 rows containing missing values (`geom_point()`)."
  },
  {
    "objectID": "aulas/aula3.html#testando-diferentes-modelos",
    "href": "aulas/aula3.html#testando-diferentes-modelos",
    "title": "Aula 3",
    "section": "Testando diferentes modelos",
    "text": "Testando diferentes modelos\nO gráfico anterior abre a possibilidade interessante de testar diferentes modelos. Pela teoria, sabemos que um modelo por mínimos quadrados é um bom modelo, e sabemos o que ele busca minimizar (e.g., \\(\\sum_{i=1}^n (y_i - (\\hat{\\beta_0} + \\hat{\\beta_1} x_i))^2\\)). Mas e se quisermos testar outros modelos? Como selecionamos bons modelos?\nAqui, vamos explorar uma solução comum em aprendizado de máquina: vamos gerar aleatoriamente e testar diferentes modelos e ver qual deles é o melhor. Isso, no entanto, envolve criar uma função – algo que não vimos explicitamente em Lego I (caso queira estudar mais sobre, veja este capítulo do R for Data Science).\nPara começar, vamos criar uma função que faz o seguinte: gera modelos aleatoriamente sorteando valores possíveis de \\(\\beta_0\\) e \\(\\beta_1\\). Aí vai o código:\n\n# Função para gerar modelos\ngera_modelos &lt;- function(n_modelos = 1000){\n\n    beta0 &lt;- runif(n_modelos, min = -10, max = 10)\n    beta1 &lt;- runif(n_modelos, min = -1, max = 1)\n\n    modelo &lt;- tibble(beta0 = beta0, beta1 = beta1)\n\n    return(modelo)\n}\n\nUm exemplo do que o modelo retorna:\n\ngera_modelos(10)\n\n# A tibble: 10 × 2\n    beta0   beta1\n    &lt;dbl&gt;   &lt;dbl&gt;\n 1  5.61   0.707 \n 2  1.07   0.484 \n 3  0.476 -0.553 \n 4  3.61   0.941 \n 5 -2.49   0.435 \n 6 -3.13   0.649 \n 7 -3.89  -0.191 \n 8 -9.71  -0.178 \n 9 -7.51   0.898 \n10 -1.84   0.0554\n\n\nComo dá para ver, em vez de estimar os parâmetros, a função os sorteia aleatoriamente. Podemos usar agora o ggplot2 para visualizar alguns desses modelos em cima dos dados de Ross (2001):\n\n# Gera 5 modelos\nmodelos &lt;- gera_modelos(5)\n\n# Plotando modelos\nggplot(ross, aes(x = oil, y = regime)) +\n  geom_point(size = 3.4, color = \"red\", alpha = 0.3) +\n  geom_abline(data = modelos, aes(slope = beta1, intercept = beta0)) +\n  theme_minimal() +\n  labs(x = \"Petróleo (% do PIB)\", y = \"Polity (democracia)\")\n\nWarning: Removed 1822 rows containing missing values (`geom_point()`).\n\n\n\n\n\nNenhum destes 5 modelos parece bom. O que podemos fazer, no entanto, é gerar mais modelos e ver se algum deles é comparável a um estimado por mínimos quadrados. Para isso, vamos criar uma função que, para cada modelo, calcula a soma dos resíduos quadráticos (SRQ):\n\n# Função para calcular SRQ\ncalcula_srq &lt;- function(beta0, beta1, dados){\n    \n    # Remove missings (não podemos calcular SRQ com missings)\n    dados &lt;- dados %&gt;%\n        select(regime, oil) %&gt;%\n        na.omit()\n\n    # Calcula a soma dos resíduos quadráticos\n    srq &lt;- sum((dados$regime - (beta0 + beta1 * dados$oil))^2)\n    return(srq)\n}\n\nCom essa função, agora podemos gerar e testar 100 ou 1000 modelos um a uma. O código a seguir faz isso (usando rowwise() e mutate() para aplicar a função a cada linha do banco de dados):\n\n# Gera 1000 modelos\nmodelos &lt;- gera_modelos(1000)\n\n# Calcula SRQ para cada modelo\nmodelos &lt;- modelos %&gt;%\n  rowwise() %&gt;%\n  mutate(srq = calcula_srq(beta0, beta1, dados = ross)) %&gt;%\n  ungroup() # Desfaz a operação rowwsise()\n\n# Visualiza os 5 melhores modelos\nmodelos %&gt;%\n  arrange(srq) %&gt;%\n  head(5)\n\n# A tibble: 5 × 3\n  beta0  beta1     srq\n  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;\n1  2.53 -0.158 144693.\n2  2.68 -0.161 144857.\n3  1.83 -0.159 145248.\n4  2.98 -0.183 145288.\n5  3.33 -0.215 146716.\n\n\nComparando com o modelo estimado por mínimos quadrados, abaixo, vemos que o resultado não foi nada mal.\n\n# Seleciona os 5 melhores modelos\nmodelos &lt;- modelos %&gt;%\n  arrange(srq) %&gt;%\n  slice(1:5)\n\n# Plota os modelos estimados e o modelo de minimos quadrados\nggplot(ross, aes(x = oil, y = regime)) +\n  geom_point(size = 3.4, color = \"red\", alpha = 0.3) +\n  geom_abline(data = modelos, aes(slope = beta1, intercept = beta0)) +\n  geom_smooth(method = \"lm\", se = FALSE, color = \"purple\", linewidth = 1.2) +\n  theme_minimal() +\n  labs(x = \"Petróleo (% do PIB)\", y = \"Polity (democracia)\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 1822 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 1822 rows containing missing values (`geom_point()`).\n\n\n\n\n\nA moral da história é que, assim como há diferentes estimadores possíveis para uma quantia de interesse, também há diferentes formas de estimar um modelo."
  },
  {
    "objectID": "aulas/aula3.html#indo-além",
    "href": "aulas/aula3.html#indo-além",
    "title": "Aula 3",
    "section": "Indo além",
    "text": "Indo além\nPara simular diferentes modelos, usamos alguns recursos mais avançados do tidyverse que só cobriremos ocasionalmente no curso. Se você quiser se aprofundar, recomendo ver principalmente:\n\nR for Data Science, de Hadley Wickham e Garrett Grolemund, livro fundamental para quem quer aprender R e tidyverse"
  },
  {
    "objectID": "template.html",
    "href": "template.html",
    "title": "Template",
    "section": "",
    "text": "Neste curso, usaremos um template em quarto para criar documentos – principalmente trabalhos parciais e final. Diferentemente de um arquivo de Word, nosso template pode ser editado em qualquer editor de texto usando Markdown; e ele também dispensa termos de formatar o documento final; de inserir bibligrafia manualmente; e de ter de copiar e colar resultados de análises feitas no R."
  },
  {
    "objectID": "template.html#o-que",
    "href": "template.html#o-que",
    "title": "Template",
    "section": "",
    "text": "Neste curso, usaremos um template em quarto para criar documentos – principalmente trabalhos parciais e final. Diferentemente de um arquivo de Word, nosso template pode ser editado em qualquer editor de texto usando Markdown; e ele também dispensa termos de formatar o documento final; de inserir bibligrafia manualmente; e de ter de copiar e colar resultados de análises feitas no R."
  },
  {
    "objectID": "template.html#download",
    "href": "template.html#download",
    "title": "Template",
    "section": "Download",
    "text": "Download\nO template pode ser baixado daqui ou deste repositório do GitHub. Extraia os arquivos para uma pasta da sua preferência. Para abrir o template no RStudio, abra o arquivo template_quarto.Rproj. Seu projeto será aberto e você deverá ver algo mais ou menos assim:\n\n\n\nTemplate de Lego II no RStudio"
  },
  {
    "objectID": "template.html#instalação",
    "href": "template.html#instalação",
    "title": "Template",
    "section": "Instalação",
    "text": "Instalação\nPara usar o template, é necessário ter o R e o quarto instalados. Para instalar especificamente o quarto, busque a versão adequada para o seu computador em:\n\nhttps://quarto.org/docs/get-started/\n\nFeito isso, é necessário instalar uma distribuição de LaTeX (que é necessário para criar arquivos em PDF). Para isso, instalamos o tinytex rodando o seguinte código diretamente do R:\ninstall.packages(\"tinytex\")\ntinytex::install_tinytex()\nFinalmente, instale o pacote quarto para R com:\ninstall.packages(\"quarto\")"
  },
  {
    "objectID": "template.html#usando-o-template",
    "href": "template.html#usando-o-template",
    "title": "Template",
    "section": "Usando o template",
    "text": "Usando o template\nCom as dependências anteriores instaladas, para usar o template basta abrir o arquivo artigo.qmd de dentro RStudio, editar seu conteúdo como quiser e clicar no botão Render. O arquivo artigo.pdf será gerado.\nTambém é possível compilar o arquivo executando o seguinte código em R:\nquarto::render(\"artigo.qmd\")\n\nDicas de uso\n\nMarkdown\nTítulos e sub-títulos são definidos com # e ##, respectivamente. Por exemplo, # Título gera um título, e ## Sub-título gera um sub-título. Para criar uma lista, use - ou * no início de cada item. Exemplo:\n- Item 1\n- Item 2\nPara criar um parágrafo, basta deixar uma linha em branco entre os parágrafos. Para criar uma citação, use &gt;. Exemplo:\n\nCitação qualquer…\n\nPara destacar um texto com itálito, use *texto*; para negrito, use **texto**; e para negrito e itálico, use ***texto***. Finalmente, links podem ser criados com [texto](url).\n\n\nCódigo em R\nPodemos inserir código bruto em R e o template o compilará e o exibirá no documento final. Por exemplo, o código abaixo gerará um gráfico:\nx &lt;- 1:10\ny &lt;- x^2\nplot(x, y)\nPara inserir código, bastar usar três crases seguidas de r, e depois do código três crases novamente. Exemplo:\n```{r}\nplot(x, y)\n```\n\n\nCitações\n\nPara inserir uma citação, use @ seguido do nome do código da referência como definido no arquivo referencias.bib. Por exemplo, @ross2001does citará Ross (2001), e [@ross2001does] citará (Ross 2001). Para inserir várias citações, separe elas por ;. Por exemplo, [@ross2001does; @cunningham2021causal].\n\n\n\nNotação\nPodemos inserir notação matemática usando \\(\\LaTeX\\). Para inserir um símbolo, use $ seguido do código \\(\\LaTeX\\) e $ novamente. Por exemplo, $\\beta$ gerará \\(\\beta\\).\nNotações que usaremos bastante no curso:\n\n\\(\\beta\\) (beta): $\\beta$\n\\(\\beta_i\\) (beta sub i): $\\beta_i$\n\\(\\alpha\\) (alfa): $\\alpha$\n\\(\\sim\\) (sim): $\\sim$\n\\(\\hat{\\beta}\\) (beta chapéu): $\\hat{\\beta}$\n\\(\\sum_{i=1}^n\\) (somatório): $\\sum_{i=1}^n$\n\\(\\mathbb{E}[X]\\) (valor esperado): $\\mathbb{E}[X]$"
  }
]