[{"authors":null,"categories":null,"content":"I am a Postdoctoral Researcher at the Federal University of Minas Gerais (UFMG/Brazil), where I study comparative politics and political methodology. I am also a Research Associate at the Center for Legislative Studies (CEL-UFMG) and was previously a Postdoctoral Fellow at the Institute of Social and Political Studies (IESP-UERJ) and visiting scholar at the Department of Government of the University of Essex.\nMy research centers on the consequences of political institutions on policy-making and welfare in presidential countries. In my spare time, I also develop open-source software for social research. In particular, I have been working mostly on tools to facilitate access to Brazilian public data \u0026ndash; that often comes in unfriendly, poorly documented formats \u0026ndash; to a broader public.\n","date":1538265600,"expirydate":-62135596800,"kind":"term","lang":"pt","lastmod":1538265600,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://www.femeireles.com/autor/fernando-meireles/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/autor/fernando-meireles/","section":"authors","summary":"I am a Postdoctoral Researcher at the Federal University of Minas Gerais (UFMG/Brazil), where I study comparative politics and political methodology. I am also a Research Associate at the Center for Legislative Studies (CEL-UFMG) and was previously a Postdoctoral Fellow at the Institute of Social and Political Studies (IESP-UERJ) and visiting scholar at the Department of Government of the University of Essex.","tags":null,"title":"Fernando Meireles","type":"authors"},{"authors":null,"categories":["rstats","electionsbr"],"content":"Depois de alguns meses sem novidades, hoje lançamos um nova atualização do electionsBR, o nosso pacote no R criado para extrair dados eleitorais do Repositório do TSE. Para além de tudo que o software já fazia, agora adicionamos a ele suporte para extração de todos os dados da última eleição, de 2018, além de correções que devem torná-lo mais estável e maduro. Esperamos que essa seja, digamos, a sua versão definitiva.\nObtendo dados eleitorais com o electionsBR Para quem não o conhece ou nunca o usou, o electionsBR faz essencialmente três tarefas:\n   Conectar o R ao Repositório do TSE para baixar as informações eleitorais, fazendo o gerenciamento de diretórios e de arquivos;    Extrair e carregar as diversas planilhas dentro de cada arquivo compactado (tarefa que, feita de forma manual, pode levar horas);    Unir, limpar e consolidar as diversas informações em um banco de dados pronto para análise, que pode ser exportado diretamente para análise em softwares como Stata e SPSS (basta habilitar o argumento export disponível na maioria das funções).    Essas tarefas são realizadas por algumas funções, uma para cada tipo de informação eleitoral. Assim, para obter dados sobre as candidaturas individuais nas eleições de 2014, por exemplo, basta usar a função candidate_fed; para eleições municipais, a função correspondente é candidate_local.\nAo todo, o pacote passa a contar com 21 funções nessa versão, que permitem extrair e limpar em segundos tanto resultados desagregados por seções eleitorais quanto informações sobre as declarações de bens de cada candidatura. Para além disso, ampliamos a já extensa documentação do pacote, em inglês, sobre a origem e a natureza de cada informação extraída por meio dele.\nPara saber mais detalhes sobre como usar o electionsBR, as seguintes referências podem ajudar:\n electionsbr.com; electionsBR: uma nova versão; electionsBR (blog post); Introduction to the electionsBR package (tutorial em inglês).  Novas funcionalidades A principal funcionalidade que adicionamos, para além das pequenas melhorias de código, foi um argumento chamado br_archive na maioria das funções do pacote. Quando ele é colocado como TRUE, as funções do pacote retornam apenas o conteúdo de arquivos com sufixo _BR, que contém dados nacionais de uma determinada eleição – o que economiza tempo no processamento dos dados quando alguém deseja, por exemplo, obter apenas resultados de eleições presidenciais. Quando deixado como FALSE, o electionsBR usa todas as planilhas baixadas do TSE para construir o banco demandado pela(o) usuária(o).\nNa prática, o uso dessa opção pode trazer problemas, como dados insuficientes ou duplicados. Infelizmente, isso ocorre porque o próprio TSE mantém em seu repositório oficial arquivos que são incompletos ou duplicados. Por conta disso, nossa recomendação é usar cada função dos dois modos.\nOutras alterações Entre outras coisas, essa versão corrige pequenos problemas apontados por diversas pessoas ao longo do último ano (fica aqui, novamente, o nosso agradecimento a todas).\nTalvez mais importante, alteramos a forma com que o electionsBR carregava os dados. Até a última versão, esse trabalho era feito pela fread do data.table em pouquíssimo tempo. Por conta da inclusão de dados no TSE, especialmente em formato diferente dos que eram públicos até então, tivemos que alterar a API de leitura do pacote para evitar erros. A partir de agora, o electionsBR é movido por read_delim do tidyverse, mais flexível.\nDados das eleições de 2018 A partir dessa versão, o electionsBR passa a contar, de forma estável, com todos os dados das eleições de 2018. Como o TSE ampliou a cobertura de informações registradas de seus dados mais recentes, isso significa que o electionsBR retorna agora bases maiores – com mais variáveis – para esses pleitos. Ao mesmo tempo, também atualizamos a documentação das funções usadas para extrair dados de eleições gerais (i.e., as funções com sufixo _fed) para descrever o conteúdo das novas colunas.\nA título de exemplo, quem coletar dados sobre as candidaturas à Câmara dos Deputados de 2018, obtidas com candidate_fed(2018), poderá notar que, agora, existe um variável chamada SITUACAO_REELEICAO. Como o nome sugere, essa variável indica quais candidaturas foram realizadas por pessoas que já foram eleitas para o mesmo cargo anteriormente. Como dá para ver no gráfico abaixo, pouco mais de 400 incumbentes tentaram suas reeleições ano passado.\nPara saber quais informações estão disponíveis para as eleições de 2018, basta consultar a documentação das funções _fed (usando help(candidate_fed), por exemplo).\nInstalação A nova versão do electionsBR já está disponível no repositório oficial de pacotes para R, o CRAN. Para instalá-lo diretamente, rode:\ninstall.packages(\u0026quot;electionsBR\u0026quot;)\r Eventualmente, uma nova versão pre-release ficará disponível no GitHub do pacote (onde também é possível postar dúvidas e sugestões). Para instalar essa, é possível executar:\nif(!require(\u0026quot;devtools\u0026quot;)) install.packages(\u0026quot;devtools\u0026quot;)\rdevtools::install_github(\u0026quot;silvadenisson/electionsBR\u0026quot;)\r ","date":1562630400,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1562630400,"objectID":"fb1dbf0c4e572790e3c52cc3782725dc","permalink":"https://www.femeireles.com/post/rstats/electionsbr-novos-dados-e-funcionalidades/","publishdate":"2019-07-09T00:00:00Z","relpermalink":"/post/rstats/electionsbr-novos-dados-e-funcionalidades/","section":"post","summary":"Depois de alguns meses sem novidades, hoje lançamos um nova atualização do electionsBR, o nosso pacote no R criado para extrair dados eleitorais do Repositório do TSE. Para além de tudo que o software já fazia, agora adicionamos a ele suporte para extração de todos os dados da última eleição, de 2018, além de correções que devem torná-lo mais estável e maduro.","tags":[],"title":"electionsBR 0.3.1: novos dados e funcionalidades","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","deflatebr"],"content":"Deflacionar séries é pré-requisito em qualquer análise sobre o valor do dinheiro ao longo do tempo. E embora não seja algo complexo, isso envolve várias etapas que consomem tempo, todas sujeitas a erro humano: obter dados históricos de algum índice de preços; compatibilizar as datas da série nominal que se quer corrigir com a série do índice de preços; calcular o ajuste; refazer o processo caso seja necessário usar outro índice de preços. Em suma, deflacionar séries acaba sempre tomando mais tempo do que deveria.\nPara realizar essa tarefa de uma forma mais rápida e replicável, usando cinco dos índices de preços mais populares no Brasil, criei um pacote para R: o deflateBR. A partir de uma série de reais nominais, ele obtém as séries de índices de preços atualizadas diretamente da API do IPEA e, em segundos, retorna os valores corrigidos – usando a metodologia adotada pelo Banco Central. Segue um breve descrição do pacote.\nComo funciona o deflateBR? O deflateBR automatiza três processos para deflacionar uma série. Primeiro, ele extrai dados de um dos seguintes índices de preços da API do IPEA: IPCA e INPC, desenvolvidos pelo IBGE; e IGP-M, IGP-DI e IPC, desenvolvidos pela FGV. Segundo, ele compatibiliza as datas mensais desses índices com as datas dos valores nominais da série. Feito isso, enfim, ele deflaciona e retorna os valores corrigidos.\nA função principal do pacote, deflate, requer apenas três argumentos: um vetor numérico de valores nominais; um vetor com as datas nominais; e uma data de referência no formato MM/AAAA. Um exemplo usando o IPCA:\n# Carrega o pacote\rlibrary(deflateBR)\r# Deflaciona 100 reais de janeiro de 2000\rdeflate(nominal_values = 100, nominal_dates = as.Date(\u0026quot;2000-01-01\u0026quot;), real_date = \u0026quot;01/2018\u0026quot;)\r ## ## Downloading necessary data from IPEA's API\r## ...\r## [1] 310.3893\r Por padrão, a função deflate esse índice. Podemos alterar isso com outro argumento chamado index.\ndeflate(100, as.Date(\u0026quot;2000-01-01\u0026quot;), \u0026quot;01/2018\u0026quot;, index = \u0026quot;igpm\u0026quot;)\r ## ## Downloading necessary data from IPEA's API\r## ...\r## [1] 372.1672\r Passando o valor igpm para o argumento, a função usa o IGP-M como indexador. Os demais indexadores possíveis são: ipc para o IPC; igpdi para o IGP-DI; inpc para o INPC. Para sabermos 100 reais de janeiro de 1995 valeriam hoje segundo esse último, bastaria usar:\ndeflate(100, as.Date(\u0026quot;1995-01-01\u0026quot;), \u0026quot;01/2018\u0026quot;, \u0026quot;inpc\u0026quot;)\r ## ## Downloading necessary data from IPEA's API\r## ...\r## [1] 491.0543\r Deflacionando séries maiores Mais útil do que corrigir um único valor é corrigir séries inteiras, com várias quantias em reais nominais associadas a algum período específico. Para mostrar como a função deflate faz isso, podemos criar os seguinte data.frame:\ndados \u0026lt;- data.frame(reais = seq(1, 5),\rdatas = seq.Date(from = as.Date(\u0026quot;2001-01-01\u0026quot;), by = \u0026quot;month\u0026quot;, length.out = 5),\rstringsAsFactors = FALSE\r)\r Feito isso, temos agora dados fictícios, com valores de 1 a 5 observados desde janeiro até maio de 2001. Suponha que queremos deflacionar esses valores para janeiro de 2017 usando o IPC da FGV. Como fazer isso? Apenas mudando o jeito de passar as informações necessárias para a função deflate:\ndeflate(dados$reais, dados$datas, \u0026quot;01/2017\u0026quot;, \u0026quot;ipc\u0026quot;)\r ## ## Downloading necessary data from IPEA's API\r## ...\r## [1] 2.759569 5.484001 8.193400 10.863809 13.464326\r Combinando o deflateBR com o tidyverse Para quem usa o conjunto de pacotes contidos no tidyverse, a função deflate pode ser usada dentro de mutate() ou similares. Adaptando o exemplo anterior:\nlibrary(tidyverse)\rdados %\u0026gt;%\rmutate(reais_deflacionados = deflate(reais, datas, \u0026quot;01/2017\u0026quot;, \u0026quot;ipc\u0026quot;))\r ## ## Downloading necessary data from IPEA's API\r## ...\r## reais datas reais_deflacionados\r## 1 1 2001-01-01 2.759569\r## 2 2 2001-02-01 5.484001\r## 3 3 2001-03-01 8.193400\r## 4 4 2001-04-01 10.863809\r## 5 5 2001-05-01 13.464326\r Outras funções Para facilitar o uso de cada um dos cinco índices de preços, também incluí no pacote deflateBR cinco funções auxiliares. Em vez de usar a função deflate com o argumento index = \u0026quot;ipca\u0026quot; para deflacionar pelo IPCA, é possível fazer isso:\nipca(dados$reais, dados$datas, \u0026quot;01/2017\u0026quot;)\r ## ## Downloading necessary data from IPEA's API\r## ...\r## [1] 2.847600 5.662908 8.455458 11.231286 13.958171\r Ou, para usar o IGP-DI, o seguinte:\nigpdi(dados$reais, dados$datas, \u0026quot;01/2017\u0026quot;)\r ## ## Downloading necessary data from IPEA's API\r## ...\r## [1] 3.385977 6.738949 10.074312 13.325380 16.471004\r Por fim, o pacote deflateBR também contém uma função simples, chamada inflation, para identificar a variação percentual na inflação entre dois períodos. Se quisermos saber qual foi a taxa de inflação em 2017 segundo o IPCA, por exemplo, basta rodar:\ninflation(\u0026quot;01/2017\u0026quot;, \u0026quot;12/2017\u0026quot;, \u0026quot;ipca\u0026quot;)\r ## ## Downloading necessary data from IPEA's API\r## ...\r## [1] 2.947421\r Como o resultado está em percentual, podemos dizer que a taxa de inflação em 2017, medida pelo IPCA, foi de 2.95%, conforme também reportado oficialmente pelo IBGE.\nExemplo de aplicação 1: o valor do salário mínimo Deflacionar séries é útil para ver como o poder de compra de salários ou outros variam ao longo do tempo. O salário mínimo, por exemplo, cresceu ou não acima da inflação? É possível responder a essa pergunta ajustando os salários nominais em cada período específico com um índice de preços, como o IPCA. Fazendo isso com o pacote deflateBR, podemos ver que o mínimo realmente cresceu acima da inflação desde 1995.\nExemplo de aplicação 2: o valor de bolsas de pós-graduação Um bom exemplo de categoria que não teve aumento de renda acima da inflação de 1995 a 2018 foram pós-graduandos que recebem bolsas de estudos da Capes. Fixadas há anos nos mesmos patamares – R$ 2200 para Doutorado, R$ 1500 para Mestrado –, a inflação não reposta se reflete em perda de poder de compra da categoria.[1] Como dá pra ver, o valor dos benefícios, hoje, praticamente voltaram aos patamares do início do primeiro governo Lula.\nValidade Como já dito, o deflateBR usa a fórmula convencional para corrigir valores nominais pela inflação: multiplicá-lo pela razão entre o índice de preços no período de referência e no período observado, assim como a calculadora disponibilizada pelo Banco Central. Os resultados do pacote e desse serviço, por essa razão, são iguais.[2]\nComo instalar Para instalar a versão disponível no CRAN do pacote, basta executar o seguinte códido:\ninstall.packages(\u0026quot;deflateBR\u0026quot;)\r Final Como procurei mostrar, o pacote deflateBR faz rapidamente, e de forma replicável, correções de valores nominais pela inflação. De qualquer forma, por ser ainda a primeira versão dele, certamente existem várias coisas por implementar ou melhorar. Para quem quiser sugerir melhorias como essas ou outras, o código do pacote está disponível no GitHub. Críticas e sugestões, como sempre, são bem-vindos.\n  Os dados sobre os períodos de ajustes nas bolsas foram retirados daqui.\n  Em todos os testes que realizei, os resultados sempre foram praticamente idênticos – com algumas diferenças na terceira e, raramente, na segunda casa decimal, provavelmente por conta de algum arredondamento realizado pela ferramenta online do BC.\n  ","date":1538265600,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1538265600,"objectID":"7945034df2fdba2de7c27a0148be88d2","permalink":"https://www.femeireles.com/post/rstats/deflacionar-series-no-r-deflatebr/","publishdate":"2018-09-30T00:00:00Z","relpermalink":"/post/rstats/deflacionar-series-no-r-deflatebr/","section":"post","summary":"Deflacionar séries é pré-requisito em qualquer análise sobre o valor do dinheiro ao longo do tempo. E embora não seja algo complexo, isso envolve várias etapas que consomem tempo, todas sujeitas a erro humano: obter dados históricos de algum índice de preços; compatibilizar as datas da série nominal que se quer corrigir com a série do índice de preços; calcular o ajuste; refazer o processo caso seja necessário usar outro índice de preços.","tags":[],"title":"Deflacionando séries com o deflateBR","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","genderbr"],"content":"Para quem trabalha com bases de dados públicas, não é incomum encontrar o seguinte problema: ter disponível em alguma coluna o nome de várias pessoas, mas não a informação sobre o sexo delas. Para lidar com esse problema, há alguns meses desenvolvi um pacote para R, o genderBR, que oferece um método simples para resolvê-lo: usando dados do Censo de 2010 do IBGE, ele inferie o sexo de uma pessoa a partir de seu nome próprio (como descrito em maiores detalhes aqui). Comparado à tarefa manual de classificar sexo a partir desses nomes, o método não só é infinitamente mais rápido, mas também evita erros de imputação, tornando replicável qualquer pesquisa que o use.\nApesar da utilidade do pacote para resolver esse problema, ele fazia isso com algumas limitações. A principal delas é a de tempo gasto na tarefa, às vezes na casa de horas ou dias. Basicamente, isso ocorre por causa da forma com que a principal função do pacote, get_gender, faz predições: para cada nome solicitado, ela envia uma requisição ao serviço online de nomes do IBGE (daqui para frente, API), recebe as informações necessárias e, com base nelas, calcula a probabilidade desse nome pertencer a um a homem ou a uma mulher. Como esse processo consome cerca de 0.1 segundos, as consequências são inevitáveis: para 10 mil nomes, a função pode facilmente rodar por mais de 15 horas.\nA partir da recém lançada versão do pacote, contudo, isso deixou de ser um problema. Aproveitando que o IBGE divulgou a base de dados que alimenta a API do serviço de nomes, agora o genderBR dispõe internamente dessas informações. Especificamente, a função get_gender ganhou um argumento opcional, internal, que permite escolher entre usar os dados internos do pacote (internal = TRUE, que agora é o padrão) ou requisitar os dados da API (internal = FALSE). Optando pelo primeiro, o processo de predizer nomes consome poucos segundos – e isso mesmo em bases com milhares ou milhões de nomes próprios.[1]\nComo usar o genderBR O primeiro passo para usar o genderBR é simples: com o R aberto, só é necessário executar install.packages(\u0026quot;genderBR\u0026quot;) para instalá-lo. Feito isso, predizer sexo a partir de nomes próprios é uma questão de chamar a função get_gender:\n# Carrega o pacote\rlibrary(genderBR)\r# Prediz o sexo de oito nomes\rnomes \u0026lt;- c(\u0026quot;Guilherme\u0026quot;, \u0026quot;Maria\u0026quot;, \u0026quot;Ana\u0026quot;, \u0026quot;Arnaldo\u0026quot;, \u0026quot;Martha\u0026quot;, \u0026quot;Carlos\u0026quot;, \u0026quot;Almir\u0026quot;, \u0026quot;Cida\u0026quot;)\rget_gender(nomes)\r ## [1] \u0026quot;Male\u0026quot; \u0026quot;Female\u0026quot; \u0026quot;Female\u0026quot; \u0026quot;Male\u0026quot; \u0026quot;Female\u0026quot; \u0026quot;Male\u0026quot; \u0026quot;Male\u0026quot; \u0026quot;Female\u0026quot;\r Mais útil que isso, é possível predizer o sexo de nomes contidos numa base de dados, adicionando o resultado dessa predição numa nova variável. Exemplo:\nbase \u0026lt;- data.frame(nome = c(\u0026quot;Ana Maria\u0026quot;, \u0026quot;Roberto Silva\u0026quot;, \u0026quot;Marcia Campos\u0026quot;),\ridade = c(25, 42, 33),\rgrupo = c(\u0026quot;A\u0026quot;, \u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;)\r)\rbase$sexo \u0026lt;- get_gender(base$nome)\rbase\r ## nome idade grupo sexo\r## 1 Ana Maria 25 A Female\r## 2 Roberto Silva 42 A Male\r## 3 Marcia Campos 33 B Female\r Nos dois casos, as predições usam os dados internos ao pacote. Para desabilitar essa opção, fazendo requisições diretamente à API do IBGE, basta declarar como falso o argumento internal: get_gender(nomes,\rinternal = FALSE). Como mostro na sequência, entretanto, usar essa opção consome muito mais tempo.\nO desempenho da nova versão do genderBR Quão rápido é predizer o sexo usando os dados internos do pacote genderBR? A título de ilustração, podemos comparar o tempo gasto para predizer o sexo daqueles 8 nomes do primeiro exemplo usando a API do IBGE, i.e. internal = FALSE, e os dados internos do pacote, internal\r= TRUE. Repeti essa operação 100 vezes com cada método, registrando o tempo gasto para concluir a predição em cada uma. Resultado: com os dados internos, o pacote leva cerca de 0.06 segundos para concluir a predição dos 8 nomes, em média; já usando a API do IBGE, o tempo necessário gira em torno de 1.4 segundos. Em outras palavras, o novo método adicionado ao pacote é cerca de 23 vezes mais rápido nesse exemplo.\nNa verdade, usar os dados internos é ainda mais rápido se levarmos em conta as pausas entre requisições, aplicadas pela função get_gender quando o número de nomes a serem consultados na API do IBGE excede 100. Além disso, os ganhos em escala do método interno são imensos porque ele consome quase o mesmo tempo para predizer o sexo de 100, 1000, ou 10000 nomes. Isso, de novo, não acontece ao usar a opção internal = FALSE para extrair dados da API do IBGE.\nEm resumo, predizer sexo a partir de nomes próprios com o genderBR ficou extremamente mais rápido.\nExemplo: sexo de autores de teses de Doutorado no Brasil Para exemplificar os usos do pacote genderBR, classifiquei o sexo de autores(as) de todas as 221990 teses de Doutorado defendidas no Brasil entre 1987 e 2016. Esses dados vêm do Banco de Teses e Dissertações da Capes, disponíveis no novo portal de dados abertos da instituição – onde também estão outros sobre a composição dos programas de pós-graduação no país, ou sobre a produção acadêmica de doscentes e discentes, por exemplo.\nO importante a notar é que a Capes disponibiliza apenas informações sobre instituição, área de avaliação e nome dos autores das teses defendidas no período, mas não o sexo de quem as defendeu.[2] É aí que entra o genderBR: usando os dados internos do pacote, predizer o sexo para todos os nomes na base leva menos de 5 segundos. Com essa informação, podemos criar um gráfico como esse.\nO gráfico acima ilustra bem o trabalho do genderBR: ele classificou a imensa maioria dos nomes como pertencendo a homens ou mulheres (96% do total). Ainda assim, como os dados disponibilizados pelo IBGE incluem apenas nomes com mais de 20 ocorrências no país, alguns na base da Capes, cerca de 3% deles, foram classificados como Desconhecido, o que indica que não encontraram correspondência. Em outros casos, nomes classificados podem ser tanto de homens quanto de mulheres – como Ariel, Darci, Noá e Elir, por exemplo –, dificultando a tarefa de atribuir sexo (os Unissex do gráfico). De qualquer forma, como é possível ver, ambos os casos são residuais.\nVoltando ao gráfico, dá para notar que mulheres defenderam cerca de metade das teses registradas no banco da Capes no período. Entretanto, como o número de defesas era pequeno até os anos 2000 – em 1987, por exemplo, apenas 939 teses defendidas foram registradas, e mesmo em 2000 esse número ainda era de apenas 5344 –, acompanhar o crescimento absoluto, ano a ano, dessa série dificulta detectar tendências. Por essa razão, podemos focar apenas na percentagem de teses defendidas por mulheres, excluindo da base pessoas com sexo classificado como Desconhecido ou Unissex.\nA tendência geral, agora, é clara: com o passar do tempo, mulheres aumentaram sua participação na defesa de teses no Brasil.\nDefesas de tese por grandes áreas O mesmo padrão, entretanto, certamente varia entre áreas: pode ser que mulheres defendam mais teses em algumas grandes áreas da Capes, menos em outras. Como o Banco de Teses contém variáveis indicando essas grandes áreas, verificar isso é relativamente simples.\nPor um lado, mulheres defendem mais teses no Brasil, ao menos nos últimos anos. Por outro lado, é possível ver que essa participação é desigual entre grandes áreas da Capes: mulheres defendem mais teses nas Ciências Biológicas, nas Humanas e nas Letras; homens, entretanto, estão sobrerrepresentados nas áreas de Engenharia e Exatas. O gradual aumento no número de mulheres defendendo teses não ocorreu nessas duas últimas.\nDefesas de tese por área de avaliação Enquanto que classificar o sexo de autores(as) de teses por grande área revela um cenário detalhado da participação de mulheres, é possível ir além com os dados da Capes. Em especial, podemos usar a classificação por área de avaliação, que é usada para classificar os programas de pós-graduação no país. Aqui, vou fazer isso para algumas dessas: para a Ciência Política, separadamente, e em algumas outras, mais próximas dessa. Os resultados, também aqui, mostram que mulheres participam mais na produção e defesa de teses em algumas áreas; já em outras, inclusa a Ciência Política, a presença delas fica aquém – às vezes muito aquém – da de homens.\nFinal Classificar por sexo autores(as) de teses no Brasil é apenas uma das utilidades do genderBR. Usando as mesmas fontes de dados, na verdade, é possível investigar as causas da variação na participação de homens e mulheres na produção de teses; mapear a distribuição de docentes e discentes por sexo em todos os programas de pós-graduação; ou, ainda, aplicar o mesmo método para classificar qualquer outro tipo de produção por sexo do(a) autor(a). Isso tudo, note-se, apenas com os dados da Capes, o que está longe de esgotar todas as aplicações possíveis do pacote.\nA mensagem mais geral desse texto, entretanto, é outra: com a nova atualização, usar o genderBR para predizer sexo a partir de nomes próprios ficou muito mais rápido. Como o exemplo anterior indica, isso pode ser feito em poucos segundos mesmo em bases de dados grandes; quando os nomes próprios estão formatados de diferentes maneiras; e levando em conta diferenças no uso de nomes por sexo entre estados (ver aqui) – nesse caso, usando a API do IBGE. Como já discuti no texto da versão anterior do pacote, as predições do genderBR, além disso, são bastante precisas: nos testes que realizei, o método prediz o sexo a partir de um nome de forma correta mais de 99% das vezes, além de produzir poucos missings, como no caso do exemplo anterior. Tudo somado, o genderBR não só é incomparavelmente mais rápido do que classificar manualmente sexo a partir de nomes, mas também mais recomendado para evitar erros de imputação e contribuir para a replicabilidade de qualquer pesquisa que o use.\nDados e cógido Os dados e o código usados nesse posto podem ser encontrados aqui. Como o pacote genderBR é open source, o que significa que qualquer um pode consultar ou trabalhar em cima do seu código, disponível no GitHub. Críticas e sugestões são bem-vindos.\n  A única ressalva, aqui, é que esse método só está disponível quando outro argumento, state, não é declarado. Com isso, apenas pela API do IBGE é possível obter predições considerando variação entre estados.\n  Os dados do Banco de Teses e Dissertações da Capes têm muitos problemas, como missings, campos preenchidos de forma incorreta, incosistência de classificação em alguns anos, entre outros. Como meu objetivo é apenas exemplificar o pacote, fiz uma limpeza superficial na base. Os dados e o código usados nesse post, de qualquer forma, podem ser encontrados aqui.\n  ","date":1524096000,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1524096000,"objectID":"d9d06b60fd31ab77a7f83551c49c2796","permalink":"https://www.femeireles.com/post/rstats/predizendo-sexo-nomes-proprios-genderbr/","publishdate":"2018-04-19T00:00:00Z","relpermalink":"/post/rstats/predizendo-sexo-nomes-proprios-genderbr/","section":"post","summary":"Para quem trabalha com bases de dados públicas, não é incomum encontrar o seguinte problema: ter disponível em alguma coluna o nome de várias pessoas, mas não a informação sobre o sexo delas.","tags":[],"title":"Predizendo sexo a partir de nomes próprios com o genderBR","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","genderbr"],"content":"Várias questões importantes nas Ciências Sociais estão ligadas ao sexo das pessoas. Se quisermos saber se mulheres recebem menores salários, se estão sub-representadas na política, se sofrem mais com as violências urbana e doméstica, entre outros, precisamos identificar o sexo das pessoas que investigamos. Entretanto, esse dado nem sempre é fácil de obter: vários bancos usados para responder às perguntas acima não contêm informações sobre o sexo das pessoas estudadas \u0026ndash; embora alguns destes contenham outras que podem ser usada para inferir seus sexos.\nO pacote genderBR para o R, que acabou de ser publicado no CRAN, serve para isso: ele usa uma informação relativamente simples de obter \u0026ndash; nome próprio \u0026ndash; e, a partir dela, prediz o sexo de uma pessoa com dados do Censo de 2010 realizado pelo IBGE. Se o nome João, por exemplo, é usado majoritariamente por individuos do sexo masculino no Brasil, temos alguma confiança em dizer que outro brasileiro qualquer com o mesmo nome provavelmente também seja do sexo masculino. Entre outras vantagens, este método é replicável, baseado em dados públicos e, o que é mais importante, muito mais rápido do que qualquer classificação manual de sexos a partir de nomes próprios. O passo-a-passo a seguir exemplifica isso.\nComo instalar Como o pacote genderBR está no CRAN e, portanto, pode ser instalado diretamente pelo R com:\ninstall.packages(\u0026quot;genderBR\u0026quot;)\r Ou, para versões beta do pacote, ele pode ser instalado com devtools:\nif(!require(\u0026quot;devtools\u0026quot;)) install.packages(\u0026quot;devtools\u0026quot;)\rdevtools::install_github(\u0026quot;meirelesff/genderBR\u0026quot;)\r Feito isso, para usar o pacote, basta carregá-lo:\nlibrary(genderBR)\r Como usar O pacote genderBR possui uma função principal, get_gender, que prediz o sexo de uma pessoa baseado no seu primeiro nome (com ou sem letras maiúsculas, acentos e sobrenomes), como no exemplo abaixo:\nget_gender(\u0026quot;maria\u0026quot;)\r ## [1] \u0026quot;Female\u0026quot;\r get_gender(\u0026quot;MARIA\u0026quot;)\r ## [1] \u0026quot;Female\u0026quot;\r get_gender(\u0026quot;Maria da Silva Conceição\u0026quot;)\r ## [1] \u0026quot;Female\u0026quot;\r A função funciona igualmente com um vetor de nomes:\nget_gender(c(\u0026quot;isabel\u0026quot;, \u0026quot;marta\u0026quot;, \u0026quot;silvia\u0026quot;, \u0026quot;rodrigo\u0026quot;, \u0026quot;roberto\u0026quot;, \u0026quot;thiago\u0026quot;))\r ## [1] \u0026quot;Female\u0026quot; \u0026quot;Female\u0026quot; \u0026quot;Female\u0026quot; \u0026quot;Male\u0026quot; \u0026quot;Male\u0026quot; \u0026quot;Male\u0026quot;\r Resumidamente, esta chamada envia uma requisição GET a API do Censo 2010 (que pode demorar a responder), calcula a proporção de mulheres que possuem o nome passado e, então, faz uma predição baseado num ponto de corte: por padrão, se mais de 0.9 das pessoas com o nome passado são do sexo feminino, segundo o Censo de 2010, a função prediz o sexo deste nome como Female; se mais 0.9 das pessoas com esse nome forem do sexo masculino, a predição será Male; por fim, nomes com proporções menores que 0.9 ou não encontrados na base do IBGE são classificados como missing (e.g., NA) Exemplos:\n# Male\rget_gender(\u0026quot;joao\u0026quot;)\r ## [1] \u0026quot;Male\u0026quot;\r # NA\rget_gender(\u0026quot;muriel\u0026quot;)\r ## [1] NA\r # NA\rget_gender(\u0026quot;ashdfjg\u0026quot;)\r ## [1] NA\r É possível modificar a proporção usada para classificar corretamente um nome. Por exemplo, podemos considerar como do sexo masculino apenas pessoas cujo primeiro nome seja usado por 0.95 (95%) de pessoas identificadas como do sexo masculino pelo IBGE:\nget_gender(\u0026quot;augusto\u0026quot;, threshold = 0.95)\r ## [1] \u0026quot;Male\u0026quot;\r Além deste resulto básico, a função get_gender também permite saber a proporção de mulheres que usam um dado primeiro nome no país \u0026ndash; com isto, é possível usar qualquer outra medida para predizer o sexo de uma pessoa. No exemplo abaixo, percebe-se que a probabilidade de alguém com o nome Muriel ser do sexo feminino no universo de entrevistados do Censo de 2010 é igual a 43%.\nget_gender(\u0026quot;muriel\u0026quot;, prob = TRUE)\r ## [1] 0.4303515\r Por fim, podemos obter os resultados por estado \u0026ndash; partido da ideia de que o uso de um dado nome próprio entre sexos pode variar de região para região. Um bom exemplo é o do político goiano Iris Rezende, casado com sua xará Iris de Araújo.\n# Probabilidade do nome Iris ser usado por uma mulher em SP\rget_gender(\u0026quot;iris\u0026quot;, prob = TRUE, state = \u0026quot;SP\u0026quot;)\r ## [1] 0.9491027\r # Probabilidade do nome Iris ser usado por uma mulher em GO\rget_gender(\u0026quot;iris\u0026quot;, prob = TRUE, state = \u0026quot;GO\u0026quot;)\r ## [1] 0.5\r Como o exemplo acima mostra, o nome Iris é muito mais comum para pessoas do sexo masculino em Goiás do que em São Paulo.\nOutras funções Além da função get_gender, o pacote genderBR possui outras duas funções que podem ser úteis em algumas situações. A primeira delas, get_states, serve para retornar um data.frame com o nome, a sigla e o código do IBGE de todos os estados brasileiros, o que pode ajudar nas consultas à função get_gender.\nJá a segunda função, map_gender, serve para mapear os usos de um nome qualquer entre todos os estados do Brasil:\nmap_gender(\u0026quot;mario\u0026quot;, gender = \u0026quot;f\u0026quot;)\r ## # A tibble: 19 x 6\r## nome uf freq populacao sexo prop\r## * \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Amazonas 13 60 3483985 f 1.72\r## 2 Piauí 22 30 3118360 f 0.96\r## 3 Rio de Janeiro 33 140 15989929 f 0.88\r## 4 Rio Grande do Norte 24 23 3168027 f 0.73\r## 5 São Paulo 35 293 41262199 f 0.71\r## 6 Ceará 23 56 8452381 f 0.66\r## 7 Santa Catarina 42 41 6248436 f 0.66\r## 8 Mato Grosso 51 19 3035122 f 0.63\r## 9 Pernambuco 26 54 8796448 f 0.61\r## 10 Maranhão 21 40 6574789 f 0.61\r## 11 Pará 15 46 7581051 f 0.61\r## 12 Espírito Santo 32 21 3514952 f 0.60\r## 13 Bahia 29 84 14016906 f 0.60\r## 14 Alagoas 27 17 3120494 f 0.54\r## 15 Paraíba 25 20 3766528 f 0.53\r## 16 Paraná 41 55 10444526 f 0.53\r## 17 Rio Grande do Sul 43 48 10693929 f 0.45\r## 18 Minas Gerais 31 79 19597330 f 0.40\r## 19 Goiás 52 20 6003788 f 0.33\r Nela, basta passar as letras f, para Female, ou m, para Male, e a função retorna o total de pessoas em cada estado com o nome fornecido, além do total de usos daquele nome no sexo indicado.\nAvaliando as predições O método é confiável? Depois de ter feitos alguns testes, a precisão média do método sempre foi maior que 95%, sem sinal de viés. Aqui, vou exemplificar isso com um exemplo simples: os dados de candidaturas do TSE (extraídos com o electionsBR).\nBasicamente, candidatos a cargos eletivos no Brasil reportam seus sexos no formulário de registro de suas candidaturas, informação que, posteriormente, é disponibilizada pelo TSE. Apesar de possíveis erros de mensuração \u0026ndash; afinal, estes dados são auto-reportados e, como tal, estão sujeitos até mesmo a erros de imputação \u0026ndash;, o genderBR faz um bom trabalho de classificar o sexo dos 104122 candidatos a cargos federais nas cinco eleições entre 1998 e 2014, como mostra a tabela abaixo.\n   Sexo declarado Sexo predito N %     Male Female 410 0.5%   Male Male 79485 95.5%   Male Unissex 1121 1.3%   Male Unknown 2201 2.6%   Female Female 19796 94.7%   Female Male 106 0.5%   Female Unissex 348 1.7%   Female Unknown 655 3.1%    Especificamente, o método classificou 99.5% das observações corretamente (desconsiderando os missings, que são mostrados aqui como Unissex, quando a proporção de usos do nome pelo sexo feminino ou masculino é menor que 0.9, ou Unknown, quando o nome não foi encontrado na base do TSE), e apenas 2.74% ficaram como missing. No geral, portanto, o método funciona.\n","date":1504569600,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1504569600,"objectID":"08f8bead4e0605e66cbfbfade09d1a6d","permalink":"https://www.femeireles.com/post/rstats/genderbr-predizer-sexo/","publishdate":"2017-09-05T00:00:00Z","relpermalink":"/post/rstats/genderbr-predizer-sexo/","section":"post","summary":"Várias questões importantes nas Ciências Sociais estão ligadas ao sexo das pessoas. Se quisermos saber se mulheres recebem menores salários, se estão sub-representadas na política, se sofrem mais com as violências urbana e doméstica, entre outros, precisamos identificar o sexo das pessoas que investigamos.","tags":[],"title":"genderBR: predizendo sexo a partir de nomes próprios","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","electionsBR"],"content":"O pacote do R para baixar e limpar dados eleitorais do TSE criado pelo Denisson Silva, Beatriz Costa e eu, o electionsBR, acaba de ganhar uma grande atualização, já disponível no CRAN: para a versão 0.3.0[1]. Para quem não o conhece, basicamente ele automatiza o trabalho de baixar, deszipar, tratar e limpar dados eleitorais brasileiros diretamente do Repositório de Dados Eleitorais do TSE \u0026ndash; tudo acompanhado de extensa documentação baseada em informações oficiais. Em outras palavras, com ele é possível extrair quase todos os dados públicos de resultados eleitorais, apuração, partidos, coligações, candidaturas, de perfil dos eleitores, entre outros, diretamente pelo R, e isto em pouquíssimo tempo.\nNesta nova versão, estendemos as funcionalidades do pacote em vários pontos, mas sem comprometer a forma com que ele já funcionava. Segue, em forma de lista, as novidades do pacote.\nVelocidade O electionsBR já era extremamente rápido (em poucos segundos ele é capaz de baixar e processar centenas de milhares de informações do website do TSE), especialmente comparado à tarefa manual de baixar separadamente os arquivos do TSE, tratar e limpar cada um para, enfim, unir todos numa base única.\nNessa versão, melhoramos esse desempenho ainda mais: alteramos internamente as formas de leitura e união dos arquivos por meio das funções fread e rbindlist do pacote data.table. Com isso, o pacote ficou cerca de 6x mais rápido do que já era.\nResultados por estado Anteriormente, só era possível pegar dados eleitorais para todo o Brasil com o pacote \u0026ndash; o que significa que, caso desejássemos ter resultados apenas para um ou mais estados, teríamos que extrair dados do país todo para, aí sim, filtrar as informações.\nAgora, a maioria das funções possui um argumento opcional chamado uf, que serve para indicar estados para os quais queremos dados \u0026ndash; e isto de forma eficiente, sem ter de processar informações dos demais estados. Para pegar dados sobre as candidaturas (nome, sexo, partido, número de urna, profissão, entre outros, dos[as] candidatos[as]) nas eleições federais de 2010 apenas em Minas Gerais, por exemplo, podemos fazer isso:\n# Instala a nova versão do pacote # (é preciso descomentar a linha abaixo)\r# install.packages(\u0026quot;electionsBR\u0026quot;)\r# Carrega o pacote\rlibrary(electionsBR)\r# Pega dados de candidaturas em 2010 apenas para Minas Gerais\rmg2010 \u0026lt;- candidate_fed(2010, uf = \u0026quot;MG\u0026quot;)\r# Um panorama dos dados\rmg2010\r ## # A tibble: 1,789 × 43\r## DATA_GERACAO HORA_GERACAO ANO_ELEICAO NUM_TURNO DESCRICAO_ELEICAO\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt;\r## 1 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010\r## 2 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010\r## 3 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010\r## 4 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010\r## 5 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010\r## 6 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010\r## 7 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010\r## 8 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010\r## 9 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010\r## 10 19/02/2016 19:56:37 2010 1 ELEIÇÕES 2010\r## # ... with 1,779 more rows, and 38 more variables: SIGLA_UF \u0026lt;chr\u0026gt;,\r## # SIGLA_UE \u0026lt;chr\u0026gt;, DESCRICAO_UE \u0026lt;chr\u0026gt;, CODIGO_CARGO \u0026lt;chr\u0026gt;,\r## # DESCRICAO_CARGO \u0026lt;chr\u0026gt;, NOME_CANDIDATO \u0026lt;chr\u0026gt;,\r## # SEQUENCIAL_CANDIDATO \u0026lt;chr\u0026gt;, NUMERO_CANDIDATO \u0026lt;chr\u0026gt;,\r## # CPF_CANDIDATO \u0026lt;chr\u0026gt;, NOME_URNA_CANDIDATO \u0026lt;chr\u0026gt;,\r## # COD_SITUACAO_CANDIDATURA \u0026lt;chr\u0026gt;, DES_SITUACAO_CANDIDATURA \u0026lt;chr\u0026gt;,\r## # NUMERO_PARTIDO \u0026lt;chr\u0026gt;, SIGLA_PARTIDO \u0026lt;chr\u0026gt;, NOME_PARTIDO \u0026lt;chr\u0026gt;,\r## # CODIGO_LEGENDA \u0026lt;chr\u0026gt;, SIGLA_LEGENDA \u0026lt;chr\u0026gt;, COMPOSICAO_LEGENDA \u0026lt;chr\u0026gt;,\r## # NOME_COLIGACAO \u0026lt;chr\u0026gt;, CODIGO_OCUPACAO \u0026lt;chr\u0026gt;, DESCRICAO_OCUPACAO \u0026lt;chr\u0026gt;,\r## # DATA_NASCIMENTO \u0026lt;chr\u0026gt;, NUM_TITULO_ELEITORAL_CANDIDATO \u0026lt;chr\u0026gt;,\r## # IDADE_DATA_ELEICAO \u0026lt;chr\u0026gt;, CODIGO_SEXO \u0026lt;chr\u0026gt;, DESCRICAO_SEXO \u0026lt;chr\u0026gt;,\r## # COD_GRAU_INSTRUCAO \u0026lt;chr\u0026gt;, DESCRICAO_GRAU_INSTRUCAO \u0026lt;chr\u0026gt;,\r## # CODIGO_ESTADO_CIVIL \u0026lt;chr\u0026gt;, DESCRICAO_ESTADO_CIVIL \u0026lt;chr\u0026gt;,\r## # CODIGO_NACIONALIDADE \u0026lt;chr\u0026gt;, DESCRICAO_NACIONALIDADE \u0026lt;chr\u0026gt;,\r## # SIGLA_UF_NASCIMENTO \u0026lt;chr\u0026gt;, CODIGO_MUNICIPIO_NASCIMENTO \u0026lt;chr\u0026gt;,\r## # NOME_MUNICIPIO_NASCIMENTO \u0026lt;chr\u0026gt;, DESPESA_MAX_CAMPANHA \u0026lt;chr\u0026gt;,\r## # COD_SIT_TOT_TURNO \u0026lt;chr\u0026gt;, DESC_SIT_TOT_TURNO \u0026lt;chr\u0026gt;\r Também é possível pegar dados de mais de um estado por vez passando um vetor para a função:\n# Pega dados de estados da região sul\rsul \u0026lt;- candidate_fed(2010, uf = c(\u0026quot;RS\u0026quot;, \u0026quot;SC\u0026quot;, \u0026quot;PR\u0026quot;))\r As siglas dos estados podem ser passadas em maiúsculo, minúsculo ou combinação dos dois: MG, mg, Mg ou mG são todos inputs igualmente válidos.\nPercentual de votos Para além das funções que o pacote já tinha (ver aqui uma descrição de todas as funções disponíveis), incluímos quatro funções para facilitar a extração de resultados eleitorais, que já retornam o percentual de votos válidos (nominais e de legenda somados) de cada partido nas eleições presidenciais, para o Senado e para a Câmara Federal agregados por estado ou por município. Estas funções são, respectivamente:\n president_mun_vote, para votação percentual nas eleições presidenciais no segundo turno por município; president_state_vote, para votação percentual nas eleições presidenciais no segundo turno por estado; legislative_mun_vote, para votação percentual nas eleições legislativas federais (Senado e Câmara) por município; legislative_state_vote, para votação percentual nas eleições legislativas federais (Senado e Câmara) por município.  No caso das eleições legislativas, as funções aceitam um argumento opcional, house indicando a casa a ser analisada, se Senado ou Câmara (senate ou chamber).\nPor exemplo, o código abaixo pega os resultados presidenciais do segundo turno de 2014 por estado:\npres \u0026lt;- president_state_vote(2010)\r E o abaixo pega o total de votos percentuais de cada partido na disputa para a Câmara Federal em 2010, por estado:\ncam \u0026lt;- legislative_state_vote(2010, house = \u0026quot;chamber\u0026quot;)\r Vagas em disputa Também acrescentamos uma função para coletar dados sobre o número de cadeira para cada cargo em disputa (seats_fed, para eleições federais, e seats_local, para eleições municipais). Para saber quantas vagas nas Câmara municipais estavam disponíveis em cada município em 2016, por exemplo, use:\nvagas \u0026lt;- seats_local(2016)\r Exportar dados para Stata e SPSS Para quem não usa, ou não tem tanta familiaridade com o R, incluímos uma opção para exportar os dados pegos pelas funções do pacote para arquivos .dta e .sav, que podem ser analisados pelo Stata e pelo SPSS, respectivamente. O argumento opcional para fazer isso é o export, que, por padrão, é igual a FALSE. Para exportar os resultados das funções, é só passar ele para TRUE:\n# Resultados eleitorais federais de 2010, agregados por zona eleitoral\rdf \u0026lt;- vote_mun_zone_fed(2010, export = TRUE)\r# Resultados eleitorais municipais de 2012, agregados por zona eleitoral\rdf2 \u0026lt;- vote_mun_zone_local(2012, export = TRUE)\r Siglas de estados e partidos Para consultar uma lista de siglas de estados e partidos, que pode ser útil para filtrar resultados, use:\n# Sigla dos estados brasileiros\ruf_br()\r ## [1] \u0026quot;AC\u0026quot; \u0026quot;AL\u0026quot; \u0026quot;AM\u0026quot; \u0026quot;AP\u0026quot; \u0026quot;BA\u0026quot; \u0026quot;CE\u0026quot; \u0026quot;DF\u0026quot; \u0026quot;ES\u0026quot; \u0026quot;GO\u0026quot; \u0026quot;MA\u0026quot; \u0026quot;MG\u0026quot; \u0026quot;MS\u0026quot; \u0026quot;MT\u0026quot; \u0026quot;PA\u0026quot;\r## [15] \u0026quot;PB\u0026quot; \u0026quot;PE\u0026quot; \u0026quot;PI\u0026quot; \u0026quot;PR\u0026quot; \u0026quot;RJ\u0026quot; \u0026quot;RN\u0026quot; \u0026quot;RO\u0026quot; \u0026quot;RR\u0026quot; \u0026quot;RS\u0026quot; \u0026quot;SC\u0026quot; \u0026quot;SE\u0026quot; \u0026quot;SP\u0026quot; \u0026quot;TO\u0026quot;\r # Sigla dos partidos que disputaram a eleicao de 2016\rparties_br()\r ## [1] \u0026quot;PPS\u0026quot; \u0026quot;PSB\u0026quot; \u0026quot;PSOL\u0026quot; \u0026quot;PP\u0026quot; \u0026quot;PSL\u0026quot; \u0026quot;PR\u0026quot; \u0026quot;PSDB\u0026quot; ## [8] \u0026quot;PDT\u0026quot; \u0026quot;PSDC\u0026quot; \u0026quot;PHS\u0026quot; \u0026quot;PT\u0026quot; \u0026quot;PROS\u0026quot; \u0026quot;PTC\u0026quot; \u0026quot;PSC\u0026quot; ## [15] \u0026quot;PC do B\u0026quot; \u0026quot;PRB\u0026quot; \u0026quot;PMDB\u0026quot; \u0026quot;DEM\u0026quot; \u0026quot;PMB\u0026quot; \u0026quot;PTB\u0026quot; \u0026quot;PEN\u0026quot; ## [22] \u0026quot;PTN\u0026quot; \u0026quot;SD\u0026quot; \u0026quot;PMN\u0026quot; \u0026quot;PT do B\u0026quot; \u0026quot;PSD\u0026quot; \u0026quot;PV\u0026quot; \u0026quot;PRP\u0026quot; ## [29] \u0026quot;REDE\u0026quot; \u0026quot;PPL\u0026quot; \u0026quot;PRTB\u0026quot; \u0026quot;PSTU\u0026quot; \u0026quot;PCB\u0026quot; \u0026quot;PCO\u0026quot; \u0026quot;NOVO\u0026quot;\r Tutoriais Para quem deseja ver um tutorial mais completo do funcionamento do electionsBR, adicionamos uma vignette ao pacote, que pode ser visto em:\n http://electionsbr.com/articles/index.html  Na mesma página, também existem outros tutoriais sobre em inglês e em português.\nWebsite Por fim, em vez de ter toda a documentação espalhada por aí, reunimos tudo num único website, que agora é também o site oficial do projeto.\n http://electionsbr.com  [1] Para instalar a nova versão, basta abrir o R e executar no console o seguinte código: install.packages(\u0026quot;electionsBR\u0026quot;).\n","date":1496880000,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1496880000,"objectID":"9519854d8b6af5857ff5dc0f868789d4","permalink":"https://www.femeireles.com/post/rstats/electionsbr-versao-0.3.0/","publishdate":"2017-06-08T00:00:00Z","relpermalink":"/post/rstats/electionsbr-versao-0.3.0/","section":"post","summary":"O pacote do R para baixar e limpar dados eleitorais do TSE criado pelo Denisson Silva, Beatriz Costa e eu, o electionsBR, acaba de ganhar uma grande atualização, já disponível no CRAN: para a versão 0.","tags":[],"title":"electionsBR: versão 0.3.0","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","electionsbr"],"content":"Obter dados eleitorais no Brasil nunca foi uma tarefa das mais fáceis. Quem já precisou fazer isso provavelmente sabe o tamanho do problema: baixar diversos arquivos, deszipá-los, abrir um a um os arquivos brutos, limpar e arrumar os dados, juntar tudo, exportar, e por aí vai. Foi com isso na cabeça que o Denisson, a Beatriz e eu lançamos, nos idos de agosto, o electionsBR - um pacote para baixar e limpar estes dados automaticamente, direto do Repositório de Dados Eleitorais do TSE. Passado algum tempo, e depois dos diversos feedbacks que recebemos, lançamos agora uma nova versão do electionsBR, já disponível no CRAN[1]: a 0.2.0.\nResumidamente, além de todas as funcionalidades existentes na versão anterior (era possível baixar quase todos os dados disponíveis do TSE e armazená-los em objetos na memória no R em segundos; para saber mais sobre a versão anterior, clique aqui), ampliamos a cobertura dela com diversos reparos e acréscimos. Destes, três se destacam:\n  Novas funções - Incluímos duas novas funções, voter_affiliation e voter_profile, que coletam e limpam dados de filiação e de perfil demográfico dos(as) eleitores(as), respectivamente. Com elas, é possível saber, por exemplo, quantos(as) filiados(as) um partido possui em cada estado; nome, sexo, data de filiação e situação cadastral destes(as) filiados(as); o número de eleitores(as) registrados(as) em cada eleição desde 1998; além do sexo, faixa etária e grau de escolaridade dos(as) votantes. No R, basta digitar ?voter_affiliation, ou ?voter_profile, para acessar a documentação completa destas funções.\n  Controle de acentos - Seguindo uma sugestão dada pelo Robert McDonnel, adicionamos um argumento chamado ascii em todas as funções. Basicamente, este remove acentos das informações do TSE - o que pode ser útil para computadores que não têm suporte para acentos latinos ou evitar erros em algumas operações com strings (comparar nomes, por exemplo). Para remover acentos, só é necessário usar ascii = TRUE.\n  Inclusão das eleições de 2016 - Agora também é possível obter os dados eleitorais das eleições municipais de 2016 pelo pacote (esta atualização, na verdade, já havia sido feito na versão beta, disponível no GitHub, por boa sugestão do Guilherme Duarte). Todas as funções que coletam dados de eleições municipais (como candidate_local ou legend_local, por exemplo) aceitam esta opção: o usuário precisa apenas passar 2016 para o argumento year destas funções (e.g., legend_local(year = 2016)).\n  Tudo isto para que o electionsBR dê mais opções ao usuário: qual dado eleitoral ele quer (agora, sim, o pacote cobre quase todos os dados); como ele quer as informações (com ou sem acentos) e para qual período (incluso as eleições de 2016).\nOutras novidades Além destas três melhorias, também alteramos outros aspectos do electionsBR. Em primeiro lugar, corrigimos alguns problemas no código da versão anterior que geravam erros. Em segundo lugar, e em parte por causa dessas correções, também tivemos de modificar a documentação técnica do pacote para registrar as alterações feitas; nesta nova versão, portanto, mais detalhes passaram a ser abordados na documentação oficial do pacote (disponível neste link). Por fim, removemos algumas funções internas (i.e. menos confusão para os usuários) e deixamos todas as funções externas mais flexíveis (é possível, por exemplo, customizar o encoding dos dados do TSE; para isso, basta definir o argumento, como enconding = \u0026quot;UTF-8\u0026quot;, ou enconding = \u0026quot;windows-1252\u0026quot;).\nApesar destas mudanças, contudo, o funcionamento do pacote permanece o mesmo. Para baixar dados eleitorais, tanto com a versão anterior quanto com essa, só é necessário carregar o pacote numa sessão do R e chamar a função desejada. Um mini-exemplo:\n# Instala a nova versao do electionsBR\rinstall.packages(\u0026quot;electionsBR\u0026quot;)\r# Carrega o pacote\rlibrary(\u0026quot;electionsBR\u0026quot;)\r# Baixa dados de filiacao individuais do PT no estado de Sao Paulo\rx \u0026lt;- voter_affiliation(party = \u0026quot;PT\u0026quot;, uf = \u0026quot;SP\u0026quot;)\r# Baixa os mesmos dados, agora sem acentos nas informacoes textuais\rx \u0026lt;- voter_affiliation(party = \u0026quot;PT\u0026quot;, uf = \u0026quot;SP\u0026quot;, ascii = TRUE)\r# Baixa dados de filiacao individuais do PT e do PSDB nos estados de Minas Gerais e Bahia\rx \u0026lt;- voter_affiliation(party = c(\u0026quot;PT\u0026quot;, \u0026quot;PSDB\u0026quot;), uf = c(\u0026quot;MG\u0026quot;, \u0026quot;BA\u0026quot;))\r O electionsBR Para quem descobriu o pacote agora e/ou quer saber mais, segue abaixo uma lista de outros exemplos e tutoriais de como usá-lo:\n  electionsBR: o que é e como usar;\n  Coletando e analisando dados de apuração eleitoral;\n  Exportando dados eleitorais para o Stata;\n  Criando mapas eleitorais;\n  electionsBR: R Functions to Download and Clean Brazilian Electoral Data, (paper acadêmico do pacote, para quem precisa de uma referência mais detalhada).\n  Para publicações que usam o pacote, esta última fonte, o paper, pode ser citada. É possível obter a referência dela, tanto em texto já formatado quanto em BibTeX, pela função citation. Exemplo:\n# Gera a informacao bibliografica para citar o electionsBR\rcitation(\u0026quot;electionsBR\u0026quot;)\r ## ## To cite electionsBR in publications, please use:\r## ## Meireles, F.; Silva, D.; Costa, B. (2016). electionsBR: R\r## functions to download and clean Brazilian electoral data.\r## Federal University of Minas Gerais (UFMG). Belo Horizonte,\r## Brazil. http://fmeireles.com/files/electionsbr.pdf\r## ## A BibTeX entry for LaTeX users is\r## ## @Manual{,\r## title = {electionsBR: {R} Functions to Download and Clean {B}razilian Electoral Data},\r## author = {Fernando Meireles and Denisson Silva and Beatriz Costa},\r## organization = {Federal University of Minas Gerais (UFMG)},\r## address = {Belo Horizonte, Brazil},\r## year = {2016},\r## url = {http://fmeireles.com/files/electionsbr.pdf},\r## }\r Notas finais Como não poderia deixar de ser num projeto como este, nos beneficiamos muito da ajuda de diversas pessoas para fazer esta atualização. Em especial, nossos colegas do Centro de Estudos Legislativos Suzana Alves, Haína Coelho, Felipe Lima, Leonardo Ev, Lucas Gelape, Bruno Arcas, e também Bruno Reis e Carlos Ranulfo; e os já mencionados Guilherme e Robert, além do Daniel Falbel, Sillas Gonzaga e Flávio Barros (estes, pelo github) contribuíram com críticas e sugestões e, por isto, estamos indefinidamente em débito com todos(as).\n[1] CRAN, ou Comprehensive R Archive Network, é um repositório oficial de pacotes para o R.\n","date":1481587200,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1481587200,"objectID":"5837dfd4506791abf43d26c82637da9b","permalink":"https://www.femeireles.com/post/rstats/electionsbr-uma-nova-versao/","publishdate":"2016-12-13T00:00:00Z","relpermalink":"/post/rstats/electionsbr-uma-nova-versao/","section":"post","summary":"Obter dados eleitorais no Brasil nunca foi uma tarefa das mais fáceis. Quem já precisou fazer isso provavelmente sabe o tamanho do problema: baixar diversos arquivos, deszipá-los, abrir um a um os arquivos brutos, limpar e arrumar os dados, juntar tudo, exportar, e por aí vai.","tags":[],"title":"electionsBR: uma nova versão (0.2.0)","type":"post"},{"authors":["Fernando Meireles"],"categories":["politica","eleicoes"],"content":"Apesar das invariáveis críticas que os institutos de pesquisa recebem toda eleição (vide aqui, por exemplo)[1], neste segundo turno o desempenho deles, \u0026ndash; ao menos o de alguns deles \u0026ndash;, não deixou a desejar.\nComo já havia postado no Twitter, o instituto Ibope, por exemplo, acertou, dentro da margem de erro (os 3 ou 4 tradicionais pontos para mais ou para menos), os resultados em 15 das 18 capitais onde realizou pesquisa entre os dias 25 e 28 de outubro. Nos três casos onde chutou a bola fora, os erros foram pequenos \u0026ndash; caso de Porto Alegre, Florianópolis e Maceió. Apenas em uma capital, Aracaju, o Ibope errou o resultado da eleição, onde a previsão era de que o candidato do PSB, Valadares Filho, ficaria na frente de Edvaldo Nogueira, do PC do B, por 2% de votos válidos. Como a previsão já era de resultado apertado, e o instituto acertou o resultado dentro da margem, este é um caso residual entre as capitais pesquisadas.\nDois outros casos ilustram o desempenho dos institutos de pesquisa \u0026ndash; agora incluindo Datafolha, Paraná Eleitoral e CP2. Os gráficos abaixo mostram o retrospecto de todas as pesquisas feitas no segundo turno no Rio de Janeiro, onde Crivella (PRB) enfretou o Freixo (PSOL), e em Belo Horizonte, onde Leite (PSDB) competiu contra Kalil (PHS), por estes institutos. Nos gráficos, cada ponto é a percentagem de intenção de votos (incluindo, portanto, não-válidos) de cada candidato estimada por cada pesquisa (em outras palavras, cada data de pesquisa, no eixo X, representa uma pesquisa eleitoral); a curva (ou linha) representa a tendência geral destas pesquisas, estimadas via LOESS; e as áreas mais claras ao redor das curvas representam os intervalos de confiança de 95%.\nDuas coisas merecem comentários em relação a esses dados:\n  Tendências são mais importantes do que resultados exatos: as intenções de votos dos quatro candidatos variaram ao longo do segundo turno; no caso de BH, o resultado inclusive se inverte no meio da campanha. Como consequência, tentar estimar o resultado final de uma eleição dias antes dela se encerrar poderia nos levar a cometer erros grotescos. Por outro lado, ao examinarmos a evolução da intenção de votos de cada candidato, temos um quadro mais claro da dinâmica das campanhas. Por exemplo, Freixo teve menos tempo de TV e recursos no primeiro turno no Rio, mas, como é possível verificar, seu desempenho oscilou pouco no período todo, ressalva feita à pequena tendência de crescimento no final do segundo turno. Só por isso, já teríamos bons indicíos de que não teríamos grandes reviravoltas ali, já que nos 30 dias anteriores isto não ocorreu. Ao contrário, em BH a ultrapassagem de Kalil em meados de outubro já indicava um movimento maior, constante, e foi inclusive comentado na mídia como um cenário mais incerto.\n  Não se pode tomar o resultado de uma única pesquisa como indicativo do resultado final das eleições. Institutos de pesquisa fazem amostras diferentes, aplicam questionários em períodos e locais diferentes, usando metodologias e pessoal diferentes, e, apenas por isso, variações aleatórias (ruídos no meio do sinal que as pesquisas tentam detectar) são esperadas. Observando o gráfico de Belo Horizonte, isto fica evidente: algumas pesquisas, às vezes realizadas pouquíssimos dias antes ou depois de outras, são destoantes; e, o que é ainda mais problemático, quando dois candidatos aparecem muito próximos, como os dois concorrentes em BH, é difícil distinguir quem está na frente (caso também de Aracaju). Nestes casos, dois institutos diferentes podem atribuir a vitória a candidatos diferentes \u0026ndash; mesmo que não exista má fé por parte deles. Cautela, enfim, é sempre necessária ao se projetar os resultados de uma eleiçao com base em pesquisas eleitorais.\n  De resto, cabe notar que pesquisas eleitorais, com todos os seus defeitos, são extremamente úteis. Quando bem interpretadas e tomadas em conjunto, podem nos dizer com bastante grau de certeza os resultados de uma eleição \u0026ndash; vide o retrospecto do 538, nos EUA.\n[1] Eu mesmo já critiquei, e ainda tenho ressalvas contra, as pesquisas eleitorais brasileiras por conta do uso de amostra por quotas. Um bom resumo do sistema, e uma crítica às margens de erro que os intitutos calculam para elas, pode ser visto aqui.\n","date":1477872000,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1477872000,"objectID":"35f289aef978886fee3e78bebbc69941","permalink":"https://www.femeireles.com/post/politica/o-desempenho-das-pesquisas-eleitorais-nas-eleicoes-de-2016/","publishdate":"2016-10-31T00:00:00Z","relpermalink":"/post/politica/o-desempenho-das-pesquisas-eleitorais-nas-eleicoes-de-2016/","section":"post","summary":"Apesar das invariáveis críticas que os institutos de pesquisa recebem toda eleição (vide aqui, por exemplo)[1], neste segundo turno o desempenho deles, \u0026ndash; ao menos o de alguns deles \u0026ndash;, não deixou a desejar.","tags":[],"title":"Desempenho das pesquisas eleitorais no segundo turno","type":"post"},{"authors":["Fernando Meireles"],"categories":["politica","abstencao","eleicoes"],"content":"Aproveitando os dados do TSE-RS, que divulgou uma lista completa dos municípios que passaram pelo recadastramento biométrico até esse ano, resolvi investigar se a biometria realmente afetou as taxas de abstenção nestas eleições.\nO gráfico abaixo ilustra essa diferença entre municípios que passaram ou não pelo recadastramento. Como dá pra ver, a taxa de abstenção média nos municípios que passaram a usar o sistema de biometria cai visivelmente depois de 2014 no Rio Grande do Sul (quando a maior parte dos municípios fez o cadastramento).\nQuando removemos os efeitos temporais e entre casos via um modelo de regressão com efeitos fixos, este efeito fica ainda mais nítido:\nEspecificamente, o efeito estimado é de cerca de 4.5% (estimado com um modelo diff-in-diff), o que significa que, na média, a taxa de abstenção no estado estava inflada em quase 50% (ela foi de cerca de 10% em 2012 na média dos municípios, embora Porto Alegre e região tenham tido abstenção maior). Em outras palavras, removendo os eleitores fantasmas, a abstenção caiu quase pela metade.\n","date":1475798400,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1475798400,"objectID":"06c6b58130b85b95e98f2587cca0d965","permalink":"https://www.femeireles.com/post/politica/desatualizacao-nas-bases-do-tse-abstencao-eleitoral/","publishdate":"2016-10-07T00:00:00Z","relpermalink":"/post/politica/desatualizacao-nas-bases-do-tse-abstencao-eleitoral/","section":"post","summary":"Aproveitando os dados do TSE-RS, que divulgou uma lista completa dos municípios que passaram pelo recadastramento biométrico até esse ano, resolvi investigar se a biometria realmente afetou as taxas de abstenção nestas eleições.","tags":[],"title":"Desatualização nas bases do TSE e abstenção eleitoral","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","metodologia"],"content":"Uma das coisas que dá dor de cabeça a usuários do Stata que migram para o R é a estimação de modelos estatísticos. Como o Stata já oferece, de forma simples, diversos modelos e opções para alterar as suas especificações, a migração para o R pode ser frustrante neste aspecto: muitas coisas simples no Stata, como incluir erros-padrão robustos ou efeitos fixos, geralmente demandam mais linhas de código (e chamada a vários pacotes) no R.\nNeste post, vou iniciar um pequeno guia para estimar regressões logísticas no R. O procedimento básico é bastante simples, como se poderá ver, mas alguns detalhes, como converter os coeficientes para razão de chance, envolvem algumas manhas adicionais.\nEstimando modelos logísticos: explorando dados do Titanic Antes de começar, precisamos de alguns dados para rodar um modelo logístico. Para isto, vou utilizar dados sobre os sobreviventes do Titanic, onde a variável de interesse (que usaremos como variável dependente nos modelos) é binária (ter sobrevivido, 1, ou não, 0). Esta base pode ser baixada aqui (meus tutoriais de como carregar dados no R, aqui e aqui), mas também podemos armazená-la num objeto diretamente no R via:\n# Salva a base de dados sobre os sobreviventes do Titanic\rtitanic \u0026lt;- read.table(\u0026quot;http://web.univ-ubs.fr/lmam/blanche/data-titanic.txt\u0026quot;, sep = \u0026quot;,\u0026quot;, header = T)\r Feito isto, podemos explorar um pouco a base. Em particular, ela possui 891 observações e 12 variáveis, que são:\nnames(titanic)\r ## [1] \u0026quot;PassengerId\u0026quot; \u0026quot;Survived\u0026quot; \u0026quot;Pclass\u0026quot; \u0026quot;Name\u0026quot; \u0026quot;Sex\u0026quot; ## [6] \u0026quot;Age\u0026quot; \u0026quot;SibSp\u0026quot; \u0026quot;Parch\u0026quot; \u0026quot;Ticket\u0026quot; \u0026quot;Fare\u0026quot; ## [11] \u0026quot;Cabin\u0026quot; \u0026quot;Embarked\u0026quot;\r O que mais nos interessa aqui é a variável binária Survived, que assume o valor de 1 para passageiros sobreviventes, e 0 para os não sobreviventes. Outras variáveis podem nos ajudar a explicá-la, como o sexo dos passageiros. Com alguns gráficos simples, podemos ter uma noção da relação entre estas duas variáveis:\n# Primeiro, carregamos o pacote ggplot2 (para gerar os graficos)\rlibrary(ggplot2)\r# Geramos um grafico de barras para visualizar o numero de sobreviventes e nao sobreviventes\rggplot(titanic, aes(x = as.factor(Survived))) + geom_bar() + theme_light() + labs(title = \u0026quot;Titanic\u0026quot;, x = \u0026quot;Sobreviventes\u0026quot;, y = \u0026quot;Frequência\u0026quot;)\r # Por fim, cruzamos a variavel sexo com a variavel sobreviventes\rggplot(titanic, aes(x = as.factor(Survived), fill = Sex)) + geom_bar() + theme_light() + labs(title = \u0026quot;Titanic\u0026quot;, x = \u0026quot;Sobreviventes\u0026quot;, y = \u0026quot;Frequência\u0026quot;)\r O que podemos concluir? Que a maior parte dos passageiros do Titanic, infelizmente, não sobreviveu ao acidente, e que, dos que sobreviveram, a maioria é do sexo feminino. Estimando uma regressão logística, podemos investigar esta relação mais detidamente.\nEstimando modelos logísticos: a função glm do R Para estimar essa regressão logística, uso a função glm, que já vem no R, especificamente no pacote stats. A função aceita vários argumentos, mas os principais que usaremos são três: a fórmula, o link (o que usaremos é o logístico, mas a função também aceita outros) e os dados usados (no caso, da base dos sobreviventes do Titanic, que já carregamos). Exemplo:\n# Estima um modelo logistico com a funcao glm\rmodelo \u0026lt;- glm(Survived ~ Sex, family = \u0026quot;binomial\u0026quot;, data = titanic)\r Explicando o código acima, fizemos o seguinte. Primeiro, passamos a fórmula que queremos estimar, com a variável Survived (sobreviventes) como dependente (Y) sendo explicada (o ~ indica que tudo após isto é variável independente) pela variávei Sex (sexo dos passageiros). Segundo, explicitamos o link (family = \u0026quot;binomial\u0026quot;). Por fim, passamos os nossos dados (data = titanic).\nPara visualizarmos o resultado deste modelo, apenas precisamos usar a função summary:\n# Acessa os resultados do modelo logistico\rsummary(modelo)\r ## ## Call:\r## glm(formula = Survived ~ Sex, family = \u0026quot;binomial\u0026quot;, data = titanic)\r## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.6462 -0.6471 -0.6471 0.7725 1.8256 ## ## Coefficients:\r## Estimate Std. Error z value Pr(\u0026gt;|z|) ## (Intercept) 1.0566 0.1290 8.191 2.58e-16 ***\r## Sexmale -2.5137 0.1672 -15.036 \u0026lt; 2e-16 ***\r## ---\r## Signif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\r## ## (Dispersion parameter for binomial family taken to be 1)\r## ## Null deviance: 1186.7 on 890 degrees of freedom\r## Residual deviance: 917.8 on 889 degrees of freedom\r## AIC: 921.8\r## ## Number of Fisher Scoring iterations: 4\r Como já havíamos visto, a probabilidade de passageiros homens terem sobrevivido é menor do que a de passageiras mulheres (aqui há um bom tutorial de como interpretar os resultados de modelos logísticos). Mas, da forma como é reportado, este coeficiente (Sexmale, que retorna a probabilidade, em log odds, de um homem ter sobrevivido em relação a uma mulher) é difícil de ser interpretado. Uma forma mais simples é por meio de razão de chance.\nTendo salvo o modelo, podemos calcular as razões de chance de forma fácil usando a função exp, que serve para exponenciar um número:\n# Converte os coeficientes do modelo de log odds para razao de chance\rexp(modelo$coefficients)\r ## (Intercept) Sexmale ## 2.87654321 0.08096732\r Agora, podemos interpretar os resultado de forma mais direta: para cada mulher que se salvou no Titanic, 0.08 homens se salvaram (ou, de forma mais intuitiva, 100 mulheres para cada 8 homens; o artigo da Wikipedia sobre razão de chance é um bom guia para interpretar essas razões de chance).\n","date":1473379200,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1473379200,"objectID":"d8f2aa5d24c6729e600f431b061ac5b4","permalink":"https://www.femeireles.com/post/rstats/estimando-regressoes-logisticas-no-r-com-razao-de-chance/","publishdate":"2016-09-09T00:00:00Z","relpermalink":"/post/rstats/estimando-regressoes-logisticas-no-r-com-razao-de-chance/","section":"post","summary":"Uma das coisas que dá dor de cabeça a usuários do Stata que migram para o R é a estimação de modelos estatísticos. Como o Stata já oferece, de forma simples, diversos modelos e opções para alterar as suas especificações, a migração para o R pode ser frustrante neste aspecto: muitas coisas simples no Stata, como incluir erros-padrão robustos ou efeitos fixos, geralmente demandam mais linhas de código (e chamada a vários pacotes) no R.","tags":[],"title":"Estimando regressões logísticas no R (com razão de chance)","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","electionsbr"],"content":"Semana passada, o Denisson, a Bia e eu lançamos o electionsBR, um pacote no R para baixar e limpas dados eleitorais do repositório do TSE. Como explicamos, o pacote contém diversas funções que facilitam a obtenção destes dados, além de tornar um processo imensamente mais rápido. Mas, como algumas mensagens que recebemos de lá pra cá indicaram, algumas (talvez muitas) pessoas usam o Stata para rodar suas análises e, por isso, não se beneficiariam do pacote.\nNeste post, farei um pequeno tutorial de como baixar e exportar estes dados do R para o Stata. Não é necessário muito conhecimento de R para segui-lo. Na verdade, o procedimento é tão simples que pode ser resumido em três etapas:\n Carregar os pacotes necessários: a primeira coisa a fazer é instalar e carregar o pacote electionsBR no R, que contêm as funções para baixar os dados do TSE. Para isto, basta apenas digitar no console:  # Instala o pacote electionsBR (se ja foi instalado, esta etapa pode ser pulada)\rinstall.packages(\u0026quot;electionsBR\u0026quot;)\r  Carregar e baixar os dados necessários: agora, precisamos carregar o pacote e apenas utilizar a função desejada. Por exemplo, podemos baixar todos os dados sobre as coligações eleitorais e partidos que concorreram nas eleições de 2010 com o seguinte código:  # Carrega o pacote electionsBR\rlibrary(electionsBR)\r# Baixa os dados sobre as legendas da eleicao de 2010\rdados \u0026lt;- legend_fed(2010)\r  Exportanto os dados: por fim, exportamos os dados com o pacote foreign, disponível por padrão no R (ao menos nas distribuições do R Project, que é também a mais utilizada):  # Carrega o pacote foreign\rlibrary(foreign)\r# Exporta os dados baixados do TSE (objeto 'dados') para o Stada\rwrite.dta(dados, file = \u0026quot;dados.dta\u0026quot;)\r Feito isto, os dados baixados estarão disponíveis no diretório de trabalho do R (é possível vê-lo digitando no console getwd()), especificamente no arquivo \u0026ldquo;dados.dta\u0026rdquo;. É possível usar outro nome de arquivo para salvá-lo \u0026ndash; desde que seja mantida a extensão no final (.dta). Exemplos:\n# Este nome de arquivo e' valido\rwrite.dta(dados, file = \u0026quot;outro_nome.dta\u0026quot;)\r# Este nome de arquivo nao e'\rwrite.dta(dados, file = \u0026quot;outro_nome\u0026quot;)\r (Na verdade, é até possível exportar um data.frame para o Stata sem usar a extensão .dta no nome do arquivo; o problema é que o arquivo não será associado ao Stata e, portanto, não será possível abri-lo com dois cliques simultâneos).\nEm resumo, mesmo com um conhecimento quase zero de R, é fácil usar o pacote electionsBR para pegar dados do TSE e exportá-los para o Stata (ou para outros softwares) \u0026ndash; e, o que não é menos importante, de forma rápida e eficiente.\n","date":1471824000,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1471824000,"objectID":"c761eb19dc28cafc911ffe02991fffb1","permalink":"https://www.femeireles.com/post/rstats/electionsbr-exportanto-dados-eleitorais-do-r-para-o-stata-spss/","publishdate":"2016-08-22T00:00:00Z","relpermalink":"/post/rstats/electionsbr-exportanto-dados-eleitorais-do-r-para-o-stata-spss/","section":"post","summary":"Semana passada, o Denisson, a Bia e eu lançamos o electionsBR, um pacote no R para baixar e limpas dados eleitorais do repositório do TSE. Como explicamos, o pacote contém diversas funções que facilitam a obtenção destes dados, além de tornar um processo imensamente mais rápido.","tags":[],"title":"electionsBR: Exportando dados eleitorais do R para o Stata","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","electionsbr"],"content":"Usando o nosso pacote no R para baixar e limpar dados eleitorais do TSE, desenvolvimento conjuntamente pelo Denisson Silva, Beatriz Costa e eu, vou mostrar aqui como é possível obter e analisar os resultados de apuração das eleições para a Câmara dos Deputados desde 1998 (o período disponível, por causa de limitações nos dados do TSE, vai de 98 a 2014 \u0026ndash; mas pretendemos expandir ele no futuro) desagregados por município/zona eleitoral.\nBaixando os dados de apuração das eleições federais Como o pacote está no CRAN, a primeira coisa que precisamos fazer é instalá-lo via console:\n# Instala o pacote electionsBR via CRAN\rinstall.packages(\u0026quot;electionsBR\u0026quot;)\r Também é possível baixar as versões pre-release do pacote via GitHub (o que permite acessar as modificações que vamos fazendo nele antes delas irem para o CRAN):\n# Instala o pacote electionsBR via GitHub\rif (!require(\u0026quot;devtools\u0026quot;)) install.packages(\u0026quot;devtools\u0026quot;)\rdevtools::install_github(\u0026quot;silvadenisson/electionsBR\u0026quot;)\r Feito isto, o pacote pode ser carregado com library:\n# Carrega o pacote electionsBR\rlibrary(electionsBR)\r Os dados sobre a apuração (i.e. votos válidos, nulos, brancos, etc.) podem ser acessados pela função details_mun_zone_fed() (ou details_mun_zone_local, para as eleições municipais). O primeiro passo para analisar a votação nas eleições da Câmara, portanto, é extrair os dados para 1998, 2002, 2006, 2010 e 2014:\n# Extrai os dados das eleicoes federais de 1998 a 2014\re1998 \u0026lt;- details_mun_zone_fed(1998)\re2002 \u0026lt;- details_mun_zone_fed(2002)\re2006 \u0026lt;- details_mun_zone_fed(2006)\re2010 \u0026lt;- details_mun_zone_fed(2010)\re2014 \u0026lt;- details_mun_zone_fed(2014)\r Ainda é possível reduzir este código via lapply (com a desvantagem de que, se em algum momento o servidor do TSE tiver problemas, o código para de executar; ao coletar os dados por eleição, é possível lidar melhor com erros):\n# Cria um vetor armazenando os anos\ranos \u0026lt;- seq(1998, 2014, by = 4)\r# Baixa os dados com lapply e details_mun_zone_fed\rdados \u0026lt;- lapply(anos, details_mun_zone_fed)\r ## Processing the data...Done.Processing the data...Done.Processing the data...Done.Processing the data...Done.Processing the data...Done.\r Para unir as bases, uma maneira fácil é por meio da função bind_rows() do pacote dplyr (uma pequena introdução a ele pode ser vista aqui):\n# Carrega o pacote dplyr\rif (!require(\u0026quot;dplyr\u0026quot;)) install.packages(\u0026quot;dplyr\u0026quot;)\rlibrary(dplyr)\r# Une as bases (se foram baixadas separadamente, descomente a linha abaixo)\r# dados \u0026lt;- bind_rows(list(e1998, e2002, e2006, e2010, e2014))\r# Une as bases (se foram baixadas separadamente, comente a linha abaixo)\rdados \u0026lt;- bind_rows(dados)\r Feito isso (em poucos segundos!), a base final deve ficar com 196723 observações, algo que seria difícil de organizar manualmente ou em planilhas de excel. Só é necessário agora filtrar as observações para ficar apenas com as referentes às eleições da Câmara (excluindo, portanto, eleições para as assembleias estaduais, senado, etc.):\n# Filtra os dados\rdados \u0026lt;- dados[dados$DESCRICAO_CARGO == \u0026quot;DEPUTADO FEDERAL\u0026quot;,]\r Analisando os dados Tendo todos estes dados já na memória do R, é possível analisá-los. Para fazer isto, utilizo o pacote ggplot2 para gerar alguns gráficos. O primeiro deles é para examinar a relação entre a quantidade de comparecimentos vs. quantidade de abstenções \u0026ndash; obviamente, os dois têm de ser negativamente relacionados:\n# Carrega o pacote ggplot2\rif (!require(\u0026quot;ggplot2\u0026quot;)) install.packages(\u0026quot;ggplot2\u0026quot;)\rlibrary(ggplot2)\rggplot(dados, aes(x = QTD_ABSTENCOES, y = QTD_COMPARECIMENTO)) + geom_point() +\rtheme_bw() + labs(title = \u0026quot;Abstenções vs. Comparecimento\u0026quot;, y = \u0026quot;Comparecimento\u0026quot;, x = \u0026quot;Abstenções\u0026quot;)\r O que obtemos é justamente o contrário. Mas por quê? Porque o gráfico está captando o total de eleitores \u0026ndash; é necessário transformar comparecimentos e abstenções em percentuais do total de eleitores aptos a votar. Podemos fazer isto da seguinte forma:\nggplot(dados, aes(x = I(QTD_ABSTENCOES / QTD_APTOS), y = I(QTD_COMPARECIMENTO / QTD_APTOS))) + geom_point() +\rtheme_bw() + labs(title = \u0026quot;Abstenções vs. Comparecimento\u0026quot;, y = \u0026quot;% Comparecimento\u0026quot;, x = \u0026quot;% Abstenções\u0026quot;)\r Agora obtemos o resultado esperado, uma relação perfeita entre comparecimento e abstenções. Com um código um pouco diferente (é preciso remover missings e converter a variável ANO_ELEICAO para factor), também podemos investigar a média de abstenções durante o período:\nfilter(dados, !is.na(ANO_ELEICAO)) %\u0026gt;% mutate(ANO_ELEICAO = factor(ANO_ELEICAO)) %\u0026gt;%\rggplot(aes(y = I(QTD_ABSTENCOES / QTD_APTOS), x = ANO_ELEICAO)) + geom_bar(stat = \u0026quot;summary\u0026quot;, fun.y = \u0026quot;mean\u0026quot;) +\rtheme_bw() + labs(title = \u0026quot;Média de abstenções nas eleições para a Câmara\u0026quot;, y = \u0026quot;% Abstenção\u0026quot;, x = \u0026quot;Ano\u0026quot;)\r É possível ver que, após a eleição de 98, a média de abstenções cai, mas se mantém mais ou menos constante depois disso. Como a média sofre influência de outliers, podemos refazer o mesmo gráfico para visualizar a mediana das abstenções:\nfilter(dados, !is.na(ANO_ELEICAO)) %\u0026gt;% mutate(ANO_ELEICAO = factor(ANO_ELEICAO),\rPERC_ABST = QTD_ABSTENCOES / QTD_APTOS) %\u0026gt;%\rggplot(aes(y = PERC_ABST, x = ANO_ELEICAO)) + geom_bar(stat = \u0026quot;summary\u0026quot;, fun.y = \u0026quot;median\u0026quot;) +\rtheme_bw() + labs(title = \u0026quot;Mediana de abstenções nas eleições para a Câmara\u0026quot;, y = \u0026quot;% Abstenção\u0026quot;, x = \u0026quot;Ano\u0026quot;)\r Por fim, podemos investigar a distribução destas abstenções por eleição para obter uma informação mais detalhada:\nfilter(dados, !is.na(ANO_ELEICAO)) %\u0026gt;% mutate(ANO_ELEICAO = factor(ANO_ELEICAO),\rPERC_ABST = QTD_ABSTENCOES / QTD_APTOS) %\u0026gt;%\rggplot(aes(x = PERC_ABST)) + geom_histogram() + facet_wrap(~ ANO_ELEICAO) +\rtheme_bw() + labs(title = \u0026quot;Distribuição de abstenções nas eleições para a Câmara\u0026quot;,\ry = \u0026quot;Freqência\u0026quot;, x = \u0026quot;% Abstenção\u0026quot;)\r O que corrobora os gráficos anteriores: a distribuição das abstenções em 98 estava mais dispersa do que nas eleições seguintes.\nNotas finais Este é apenas um dois possíveis tipos de análises que é possível fazer com a ajuda do pacote electionsBR. Como deve ter ficado claro, ele simplifica enormemente a tarefa de obter dados eleitorais, além de já os deixar prontos para uso. Mesmo assim, ainda é possível que alguns dos dados do TSE não possam ser tão simplemente analisados. A formação de alguns campos varia ao longo do tempo (a data de nascimento dos candidatos, por exemplo, era preenchida como \u0026ldquo;13/10/1976\u0026rdquo; em anos anteriores, mas também já foi preenchida como \u0026ldquo;13-10-76\u0026rdquo;), algumas variáveis são acrescentadas e, constantemente, outras são atualizadas pelo TSE. Por estas e outras razões, o pacote electionsBR ainda é um trabalho em aberto, que pode melhorar com a contribuição de outras pessoas.\n","date":1471564800,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1471564800,"objectID":"8728ac9ca79e1f6cf572b615ad017201","permalink":"https://www.femeireles.com/post/rstats/electionsbr-analisando-a-apuracao-das-eleicoes-para-a-camara-dos-deputados/","publishdate":"2016-08-19T00:00:00Z","relpermalink":"/post/rstats/electionsbr-analisando-a-apuracao-das-eleicoes-para-a-camara-dos-deputados/","section":"post","summary":"Usando o nosso pacote no R para baixar e limpar dados eleitorais do TSE, desenvolvimento conjuntamente pelo Denisson Silva, Beatriz Costa e eu, vou mostrar aqui como é possível obter e analisar os resultados de apuração das eleições para a Câmara dos Deputados desde 1998 (o período disponível, por causa de limitações nos dados do TSE, vai de 98 a 2014 \u0026ndash; mas pretendemos expandir ele no futuro) desagregados por município/zona eleitoral.","tags":[],"title":"electionsBR: analisando a apuração das eleições para a Câmara dos Deputados","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","electionsbr"],"content":"Nosso pacote para baixar e limpar dados eleitorais do website do TSE, desenvolvido conjuntamente por Denisson Silva, Beatriz Costa e eu, foi publicado no Comprehensive R Archive Network (CRAN): o electionsBR. Basicamente, ele contém uma série de funções para extrair e limpar a maioria dos dados disponíveis no Repositório de Dados Eleitorais do TSE, deixando-os prontos para uso.\nO electionsBR vem para facilitar a vida de quem trabalha ou precisa consultar estes dados do TSE de duas formas. Primeiro, ele fornece um conjunto de funções para baixar a maioria dos dados do TSE, que são então armazenados diretamente num objeto na memória do R \u0026ndash; sem a necessidade de abrir o website do TSE, deszipar, ler e limpar cada um dos arquivos individuais. Segundo, ele faz isso em poucos segundos e, além disso, já lida com os principais problemas nas bases do TSE: como é notório entre os usuários do Repositório, os arquivos do TSE frequentemente vêm com problemas de enconding (i.e. acentos tornam-se caracteres inelegíveis), incompatibilidade entre arquivos (i.e. mais ou menos variáveis, células vazias) e informações mal formatadas (i.e. variáveis numéricas contêm caracteres não-numéricos).Com ele, portanto, é possível baixar rapidamente, e sem problemas, os principais dados eleitorais do TSE.\nUsando o pacote Apenas duas coisas são necessárias para usar o pacote: uma versão do R superior a 2.1 (\u0026gt;= 2.1) e conexão com a internet. Para instalar a versão estável dele no CRAN, basta digitar no console:\ninstall.packages(\u0026quot;electionsBR\u0026quot;)\r Também é possível instalar as versões pré-release direto do GitHub (onde também está disponível uma pequena introdução ao pacote, em inglês):\nif (!require(\u0026quot;devtools\u0026quot;)) install.packages(\u0026quot;devtools\u0026quot;)\rdevtools::install_github(\u0026quot;silvadenisson/electionsBR\u0026quot;)\r O pacote electionsBR possui dez funções básicas para baixar cinco tipos de dados diferentes. São elas:\n candidate_fed(): baixa dados sobre as candidaturas individuais nas eleições federais. candidate_local(): baixa dados sobre as candidaturas individuais nas eleições municipais. details_mun_zone_fed(): baixa dados sobre os detalhes de apuração desagregados por município/zona eleitoral das eleições federais. details_mun_zone_fed(): baixa dados sobre os detalhes de apuração desagregados por município/zona eleitoral das eleições municipais. legend_fed(): baixa dados sobre as legendas que concorreram nas eleições federais. legend_local(): baixa dados sobre as legendas que concorreram nas eleições locais. party_mun_zone_fed(): baixa dados sobre o desempenho das legendas desagregados por município/zona eleitoral nas eleições federais. party_mun_zone_local(): baixa dados sobre o desempenho das legendas desagregados por município/zona eleitoral nas eleições locais. vote_mun_zone_fed(): baixa dados sobre os resultados eleitorais desagregados por município/zona eleitoral nas eleições federais. vote_mun_zone_locais(): baixa dados sobre os resultados eleitorais desagregados por município/zona eleitoral nas eleições locais.  Para baixar os dados sobre os candidatos que disputaram as eleições nacionais de 2002, por exemplo, basta executar o seguinte código:\n# Carrega o pacote\rlibrary(electionsBR)\r# Baixa os dados\rdados \u0026lt;- candidate_fed(year = 2002)\r ## Processing the data...Done\r Todas as funções funcionam da mesma forma: o único argumento que deve ser preenchido pelo usuário é o ano do pleito (year), que deve ser introduzido como integer (e.g., 2002, 2006, 1996). O objeto resultante é um data.frame que contém diversas variáveis (para uma descrição detalhada de cada uma, ver a documentação do pacote no CRAN).\nAlgumas notas finais É importante ressaltar que este pacote é resultado de alguns projetos de pesquisa em andamento no Centro de Estudos Legislativos (CEL), do qual o Denisson, a Bia e eu fazemos parte. Ao ter de repetir diversas vezes a tarefa de baixar, descompactar, abrir e unir todas as bases do TSE, achamos uma boa ideia criar este pacote para facilitar a nossa vida. Mas, como efeito final, também possibilitamos que outras pessoas consultem os mesmos dados facilmente.\nComo esta é a primeira versão estável do pacote, críticas e sugestões para melhorá-lo são bem-vindas.\n","date":1471478400,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1471478400,"objectID":"96ba45dfb1f7bb2716c728ca8b3a3705","permalink":"https://www.femeireles.com/post/rstats/electionsbr-um-pacote-para-baixar-dados-eleitorais-do-tse/","publishdate":"2016-08-18T00:00:00Z","relpermalink":"/post/rstats/electionsbr-um-pacote-para-baixar-dados-eleitorais-do-tse/","section":"post","summary":"Nosso pacote para baixar e limpar dados eleitorais do website do TSE, desenvolvido conjuntamente por Denisson Silva, Beatriz Costa e eu, foi publicado no Comprehensive R Archive Network (CRAN): o electionsBR.","tags":[],"title":"electionsBR: um pacote no R para baixar e limpar dados eleitorais do TSE","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats","politica","dilma"],"content":"Num post anterior, fiz uma análise dos tweets da Presidenta Dilma Rousseff. Neste aqui, aproveitei os dados já coletados para fazer algo diferente, que já estava querendo fazer há tempos: uma análise de sentimentos. Basicamente, esta técnica serve para avaliar um determinado texto, dando a ele uma nota numa escala que vai de negativo a positivo, triste a feliz, etc. No caso, vou fazer isto utilizando a API do cognitive services da Microsoft, que possui um algoritimo próprio para classificar os textos numa escala que vai de 0, mais negativo, a 1, mais positivo (assim como outros métodos, ele classifica cada palavra num texto e, então, computa um score para a frase ou trecho; para uma análise sobre a potencialidade do método, ver aqui).\nAnalisando os sentimentos dos tweets da Dilma Como mostro naquele post anterior, podemos concluir três coisas em relação aos tweets da @dilmabr publicados desde 2015: (1) ela passou a tuítar mais após o seu afastamento (mas já tuitou mais no passado); (2) seus tweets passaram a receber mais retweets e favoritadas após o afastamento; e, (3), os tweets que mencionam o termo \u0026ldquo;golpe\u0026rdquo; são mais influentes do que a média deste outro grupo (tweets pós-afastamento sem o termo \u0026ldquo;golpe\u0026rdquo;).\nCom uma análise de sentimentos destes tweets, podemos descobrir outras coisas: como o tom das postagens da Presidenta variaram ao longo do tempo? Seus tweets mais recentes possuem conteúdo mais negativo (críticas, mostras de ressentimento, etc.) ou mais positivos (expressões de felicidade, elogios, etc.)? Para responder estas perguntas, apliquei o algoritimo do cognitive services em cada um dos tweets 1859 da Dilma e salvei seus scores (aqui há um bom tutorial sobre como usar o serviço da Microsoft no R, com o pacote mscstexta4r). Feito isto, podemos plotar os resultados (cada ponto cinza indica um tweet, o eixo y indica o score do tweet naquela escala que vai de 0, mais negativo, a 1, mais positivo e, enfim, a linha azul é uma curva loess):\nDuas coisas chamam a atenção logo de cara. A primeira delas é o fato de que, após o seu afastamento (maio de 2016, linha tracejada), o sentimento geral dos tweets da Dilma tornam-se mais negativos, como mostra o declínio da linha azul (o que até faz sentido). Exemplos disto:\n## Tweet = Fico triste de não assistir à festa \u0026quot;ao vivo e a cores\u0026quot;.\rMas estarei acompanhando, torcendo pelo Brasil. / Score = 0\r## Tweet = O golpe consiste em 2 coisas: estancar a sangria, impedir\rq as investigações da #LavaJato chegasse até eles. O meu gov não\rinterromperia. / Score = 0.2127647\r O que contrasta com alguns tweets anteriores:\n## Tweet = Viva a mulher brasileira! Viva o povo brasileiro.\rViva o Brasil! #DilmaDaMulher / Score = 1\r## Tweet = (...) valeu a pena lutar pela liberdade,\rvaleu a pena lutar pela democracia! Este País está + forte\rdo q nunca. / Score = 1\r Durante todo o restante do período, os tweets da Presidenta oscilavam pouco em seus tons, ficando, na média, um pouco acima de 0.5 na escala de sentimentos. A caída repentina após o afastamento, portanto, indica que o tom geral dos tweets da Presidenta mudaram (embora não dê pra saber, apenas visualmente, se a média destes tweets é significativamente diferente dos demais).\nJá a segunda coisa que merece destaque é a retomada do tom positivos nos últimos tweets Como dá pra ver, após a queda, a linha azul volta a subir bastante (superando, inclusive, períodos anteriores). Mas o que ela tem dito? Coisas como estas:\n## Tweet = As mulheres têm se destacado nesses Jogos,\ro que nos enche de orgulho e alegria. #Rio2016 /\rScore = 0.9818006\r## Tweet = Obrigada, @BernieSanders! Dilma agradece\rsolidariedade do senador democrata norte-americano:\rhttps://t.co/jtPVdAouaA / Score = 1\r## Tweet = O Brasil está orgulhoso, @RafaelaSilvaa.\rEstamos emocionados com sua conquista. Você é o máximo!\rParabéns! #Rio2016 / Score = 1\r Como se pode ver, o tom triste e combativo dos tweets mais negativos contrasta com estes, que são dedicados a agradecer pessoas e exaltar conquistas.\n","date":1471132800,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1471132800,"objectID":"884f6bca73e36253aec75df21d9a3f10","permalink":"https://www.femeireles.com/post/rstats/analise-de-sentimentos-dos-tweets-da-dilma/","publishdate":"2016-08-14T00:00:00Z","relpermalink":"/post/rstats/analise-de-sentimentos-dos-tweets-da-dilma/","section":"post","summary":"Num post anterior, fiz uma análise dos tweets da Presidenta Dilma Rousseff. Neste aqui, aproveitei os dados já coletados para fazer algo diferente, que já estava querendo fazer há tempos: uma análise de sentimentos.","tags":[],"title":"Uma análise de sentimentos dos tweets da Dilma Rousseff","type":"post"},{"authors":["Fernando Meireles"],"categories":["politica","impeachment","dilma"],"content":"Desde o ínicio do impeachment da agora Presidente afastada, Dilma Rousseff (PT), acadêmicos e articulistas discutem se este processo se encaixa na categoria de golpe de estado. Críticos do governo e membros da oposição defendem que, conceitualmente, golpe de estado envolveria deposição à força da ou do presidente (i.e., por golpe militar), o que não é o caso aqui. Por outro lado, esta definição está longe de ser consensual: outras definições são consistentes com a ausência de participação militar. No caso da queda do então Presidente do Paraguai, Fernando Lugo, o mesmo foi frequentemente alegado, embora, também ali, seja difícil explicar como que um processo tão rápido possa ter seguido dentro da normalidade democrática.\nOutra questão neste debate, entretanto, não é muito analisada: rotular o processo de impedimento da Presidenta Dilma como golpe é uma boa estratégia? Para analisar isto, resolvi aproveitar o pacote twitteR, no R, para fazer uma análise de todos os tweets dela desde outubro de 2014 para responder esta pergunta. Como o twitter é reconhecidamente uma ferramenta importante de comunicação (a Dilma, além disso, tem quase 5 milhões de seguidores), este é um bom exercício para investigar o retorno desta estratégia.\nOs dados que usei, com todos os tweets da Presidenta, podem ser baixados neste link. Com eles, é possível replicar o código que usei abaixo para fazer a análise (também é necessário ter instalado alguns pacotes, como o ggplot2, pra gerar gráficos, e o dplyr, pra manipular os dados).\nA Presidenta Dilma ficou mais ativa no Twitter nos últimos meses? Depois de sua posse em 2010, Dilma Rousseff acabou abandonando o Twitter, rede social onde foi bastante ativa durante as eleições. Entre indas e vindas, logo após ter sido afastada da Presidência, entretanto, o perfil dilmabr voltou a ser usado com mais frequência. E, segundo a revista Época, seu novo uso para a ferramente tem sido divulgar sua defesa no processo de impeachment.\nA primeira coisa que resolvi investigar foi justamente isto: se a Presidenta teria ficado mais ativa no Twitter após o seu afastamento. Para começar, primeiro carrego os pacotes e os dados necessários no R.\nlibrary(lubridate) # Para manipular datas\rlibrary(ggplot2) # Para gerar graficos\rlibrary(tidyr) # Para manipular os dados\rlibrary(dplyr) # Para manipular os dados\rlibrary(tm) # Para fazer text mining nos tweets\rload(\u0026quot;dilma_tw.Rda\u0026quot;)\r A base tem 16 variáveis e 1859 observações (significando que, desde 2010, o perfil @dilmabr tuítou 1859 vezes). A questão que precisamos analisar, agora, é verificar a frequência com que a Presidenta tem tuítado. Agregando seus tweets por mês, podemos visualizar isto:\ndilma_tw$data_mes \u0026lt;- floor_date(dilma_tw$created, \u0026quot;month\u0026quot;)\rdilma_tw %\u0026gt;%\rcount(data_mes) %\u0026gt;%\rggplot(aes(x = data_mes, y = n)) + geom_line() + geom_vline(xintercept = as.numeric(as.POSIXct(\u0026quot;2016-05-01\u0026quot;)), linetype = 2) + theme_bw() + labs(title = \u0026quot;Atividade da Dilma no Twitter\u0026quot;,\rx = \u0026quot;Ano-Mês\u0026quot;, y = \u0026quot;Número de tweets\u0026quot;)\r O gráfico mostra que a pró-atividade da Presidenta no twitter é ambígua. É verdade que ela passou a tuítar mais nos últimos dois meses (a linha pontilhada indica o mês de maio de 2016), mas em outros períodos ela utilizava a ferramente muito mais, especialmente nos meses anteriores às eleições de 2014. Mesmo assim, pode ser que, mesmo não tuitando com tanta frequência, seus tweets mais recentes estejam atingindo um público maior (recebendo mais retweets ou sendo mais favoritados pelos usuários, o que indicaria que eles estariam tendo maior engajamento com os seus conteúdos). Podemos ver isso agregando as retuítadas e os favoritos também por mês:\ndilma_tw %\u0026gt;%\rgroup_by(data_mes) %\u0026gt;%\rsummarise(Reteets = sum(retweetCount), Favoritos = sum(favoriteCount)) %\u0026gt;%\rgather(key = Ação, value = N, Reteets:Favoritos) %\u0026gt;%\rggplot(aes(x = data_mes, y = N / 1000, color = Ação)) +\rgeom_line() + geom_vline(xintercept = as.numeric(as.POSIXct(\u0026quot;2016-05-01\u0026quot;)),\rlinetype = 2) + theme_bw() + labs(title = \u0026quot;RTs e Favs dos tweets da Dilma\u0026quot;,\rx =\u0026quot;Ano-Mês\u0026quot;, y = \u0026quot;RTs e Fav (em milhares)\u0026quot;)\r O padrão parece seguir o anterior: a Presidenta vem tendo maior influência no twitter após seu afastamento, mas já teve mais que isso no passado. O problema é que estas simples medidas escondem uma informação importante: mesmo tuitando menos, pode ser que seus tweets atuais sejam relativamente mais influentes. Suponhamos, por exemplo, que todo tweet da @dilmabr tenha sempre 100 retweets; caso ela tuíte muito num mês, este gerará mais retweets no agregado. Como essa influência depende do número de tweets (quem tuíta mais pode receber mais retweets e favoritos), portanto, uma medida melhor de influência pode ser obtida calculando a média de retweets e favoritos por tweet num mês, i.e. retweets / total de tweets e favoritos / total de tweets. É possível ver este gráfico abaixo:\ndilma_tw %\u0026gt;%\rgroup_by(data_mes) %\u0026gt;%\rsummarise(Retweets_por_tuite = sum(retweetCount) / n(),\rFavoritos_por_tuite = sum(favoriteCount) / n()) %\u0026gt;%\rgather(key = Ação, value = N, Retweets_por_tuite:Favoritos_por_tuite) %\u0026gt;%\rggplot(aes(x = data_mes, y = N, color = Ação)) + geom_line() +\rgeom_vline(xintercept = as.numeric(as.POSIXct(\u0026quot;2016-05-01\u0026quot;)),\rlinetype = 2) + theme_bw() + labs(title = \u0026quot;RTs e Favs por tweet da Dilma\u0026quot;, x = \u0026quot;Ano-Mês\u0026quot;,\ry = \u0026quot;RTs e Fav por tweet\u0026quot;)\r Agora é que as coisas mudam de figura: mesmo tendo tuítado relativamente menos do que em outras épocas, os tweets mais recentes da Presidenta são mais influentes, isto é, eles obtêm mais retweets e favoritos (apenas com base neste gráfico, também suspeito que poucas pessoas têm interesse em retuítar e favoritar tweets de campanha, como aqueles divulgando agenda de eventos e comícios, o que pode explicar porque a atividade nos períodos eleitorais não produz um impacto por tweet tão grande; também deve ser considerado que o número de seguidores da Presidente não se manteve constante no período).\nQuais termos mais aparecem nos tweets da Presidenta Dilma? Se os últimos tweets da Dilma têm sido os seus mais influentes, no que eles são diferentes dos anteriores? Eles falam sobre assuntos distintos? Para analisar isto, criei uma matriz com a frequência de palavras usadas nos tweets para, então, visualizar os resultados. Começo com os tweets pré-afastamento:\npre_afast \u0026lt;- dilma_tw %\u0026gt;%\rfilter(data_mes \u0026lt; as.POSIXct(\u0026quot;2016-04-01 UTC\u0026quot;)) %\u0026gt;%\rselect(text) %\u0026gt;%\rVectorSource() %\u0026gt;%\rCorpus() %\u0026gt;%\rTermDocumentMatrix(control = list(\rremovePunctuation = T,\rstopwords = c(stopwords(\u0026quot;portuguese\u0026quot;),\r\u0026quot;vcs\u0026quot;,\r\u0026quot;aqui\u0026quot;,\r\u0026quot;ser\u0026quot;,\r\u0026quot;hoje\u0026quot;,\r\u0026quot;sobre\u0026quot;,\r\u0026quot;agora\u0026quot;,\r\u0026quot;todos\u0026quot;,\r\u0026quot;ter\u0026quot;,\r\u0026quot;vamos\u0026quot;,\r\u0026quot;anos\u0026quot;),\rremoveNumbers = T, tolower = T)\r) %\u0026gt;%\ras.matrix() %\u0026gt;%\ras.data.frame()\rpre_afast \u0026lt;- data.frame(termos = rownames(pre_afast),\rfreq = rowSums(pre_afast), periodo = \u0026quot;Pré afastamento\u0026quot;)\rpre_afast %\u0026gt;%\rarrange(desc(freq)) %\u0026gt;%\rslice(1:15) %\u0026gt;%\rmutate(termos = factor(termos,\rlevels = termos[order(freq, decreasing = T)])) %\u0026gt;%\rggplot(aes(x = termos, y = freq)) +\rgeom_bar(stat = \u0026quot;identity\u0026quot;) + theme_bw() +\rtheme(axis.text.x = element_text(angle = 45, hjust = 1)) + labs(title = \u0026quot;Termos mais usados nos tweets da Dilma\\n(Pré-afastamento)\u0026quot;,\rx = \u0026quot;Termo\u0026quot;, y = \u0026quot;Frequência\u0026quot;)\r Neste período pré-afastamento, os termos que mais aparecem nos tweets da Presidenta se referem principalmente às eleições, ela mesma e ao país. Quando analisamos o segundo período, alguns termos novos aparecem:\nApesar da frequência de termos ser menor (o período também é menor), fica evidente que alguns ganham maior espaço: especialmente os termos \u0026ldquo;provisório\u0026rdquo;, \u0026ldquo;impeachment\u0026rdquo;, \u0026ldquo;processo\u0026rdquo;, \u0026ldquo;democracia\u0026rdquo; e \u0026ldquo;golpe\u0026rdquo;. Estes são, especificamente, os tweets usados como estratégia de defesa da Presidente, como seguinte exemplo mostra.\nPortanto, vimos não só que os tuítes da Dilma se tornaram mais influentes após o seu afastamento, mas também que o conteúdo destes é um pouco diferente dos anteriores: eles mencionam mais o processo de impeachment e, além disso, contêm mais o termo \u0026ldquo;golpe\u0026rdquo;.\nUsar os termos \u0026ldquo;golpe\u0026rdquo; e \u0026ldquo;impeachment\u0026rdquo; dá resultado? Mas os tweets que usam o termo \u0026ldquo;golpe\u0026rdquo; recebem mais retweets e favoritadas? Em caso positivo, podemos dizer que, ao menos no âmbito do twitter, o uso do conceito traz benefícios. Podemos fazer um exercício simples para verificar isto, que consiste em calcular a média de retweets e favoritos nos tweets com a palavra \u0026ldquo;golpe\u0026rdquo; e nos que não a contêm.\n## ## =================================\r## golpe Retweets Favoritos\r## ---------------------------------\r## C/ termo golpe 734.4 1326.8 ## S/ termo golpe 435.8 817.4 ## ---------------------------------\r O resultado dá uma ideia da influência do termo \u0026ldquo;golpe\u0026rdquo;: tweets com este termo recebem, em média, cerca de 299 retweets a mais, além de cerca de 509 favoritadas a mais. Este não é a forma mais rigorosa de fazer isto (o grupo dos tweets sem o termo \u0026ldquo;golpe\u0026rdquo; pode tratar de assuntos menos relevantes, ter sido publicado em períodos diferentes, etc.), mas este simples exercício mostra que o uso do termo tem relação com a influência de um tweet da Presidenta (também deve ser levado em conta que isto não explica toda a influência dos seus tweets mais recentes). E quanto ao termo impeachment? O resultado muda:\n## ## =======================================\r## golpe Retweets Favoritos\r## ---------------------------------------\r## C/ termo impeachment 464.3 937.7 ## S/ termo impeachment 449.9 836.8 ## ---------------------------------------\r Praticamente não existe diferença entre tweets que usam ou não o termo \u0026ldquo;impeachment\u0026rdquo;. Podemos ainda comparar os dois, \u0026ldquo;golpe\u0026rdquo; e \u0026ldquo;impeachment\u0026rdquo;:\n## ## =======================================\r## golpe Retweets Favoritos\r## ---------------------------------------\r## C/ termo golpe 734.4 1326.8 ## C/ termo impeachment 436.4 893.7 ## ---------------------------------------\r Tweets com o termo \u0026ldquo;golpe\u0026rdquo;, novamente, ganham disparado em influência. Fazendo uma estimativa simples de que cada retweet alcance 100 novos usuários, podemos dizer que cada tweet com o termo atinge cerca de 30.000 usuários a mais. Provavelmente este número é maior, e ele ainda deve ser somado ao número de seguidores da Presidente que já viram os tweets em suas timelines. Outra coisa que deve ser considera é que estes retweets são feitos por usuários que provavelmente têm maior inclinação pela Presidenta, o que significa que estes já são mais propensos a se engajar com publicações que mencionam o termo \u0026ldquo;golpe\u0026rdquo;. Em todo caso, como os números mostram, o uso deste termo está associado com um maior número de retweets e favoritos, sugerindo que, ao menos no twitter, classificar o processo de impeachment como golpe parece ser a melhor estratégia.\n","date":1470960000,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1470960000,"objectID":"df8147af7edba5b91b84157dc4d7c1d0","permalink":"https://www.femeireles.com/post/politica/golpe-impeachment-uma-analise-dos-tweets-da-dilma/","publishdate":"2016-08-12T00:00:00Z","relpermalink":"/post/politica/golpe-impeachment-uma-analise-dos-tweets-da-dilma/","section":"post","summary":"Desde o ínicio do impeachment da agora Presidente afastada, Dilma Rousseff (PT), acadêmicos e articulistas discutem se este processo se encaixa na categoria de golpe de estado. Críticos do governo e membros da oposição defendem que, conceitualmente, golpe de estado envolveria deposição à força da ou do presidente (i.","tags":[],"title":"Golpe ou impeachment? Uma análise dos tweets da Dilma Rousseff","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats"],"content":"Uma das potencialidades do R é que é possível abrir (quase) qualquer tipo de arquivo nele. Arquivos no formato .csv, .txt, .dta, etc., são apenas algumas das opções. Mas esta enorme gama de possibilidades também traz complicações, especialmente porque cada um destes arquivos possui uma função respectiva para importação.\nO pacote rio serve para acabar com estes problemas. Com uma única função, import(), ele é capaz de detectar qual arquivo o usuário deseja abrir e seleciona o método mais eficiente para fazê-lo.\nO primeiro passo para usá-lo é instalar o pacote, que está no CRAN:\n# Instalando o pacote 'rio'\rinstall.packages(\u0026quot;rio\u0026quot;, dependencies = TRUE)\r Acima, instalamos o pacote com todas as dependências (outros pacotes que são necessários para que ele funcione). Feito isto, carregar qualquer arquivo de dados fica fácil, basta usar a função import():\n# Carrega o pacote rio\rlibrary(rio)\r# Carrega um arquivo em .csv no diretorio corrente\rdf \u0026lt;- import(file = \u0026quot;dados.csv\u0026quot;)\r# Carrega um arquivo em .txt no diretorio corrente\rdf2 \u0026lt;- import(file = \u0026quot;dados.txt\u0026quot;)\r# Carrega um arquivo em .dta (Stata) no diretorio corrente\rdf3 \u0026lt;- import(file = \u0026quot;dados.dta\u0026quot;)\r# Carrega um arquivo em .sav (SPSS) no diretorio corrente\rdf4 \u0026lt;- import(file = \u0026quot;dados.sav\u0026quot;)\r ","date":1468540800,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1468540800,"objectID":"a8b7a8068c1cdd5bd5da772a03434492","permalink":"https://www.femeireles.com/post/rstats/como-importar-qualquer-arquivo-no-r/","publishdate":"2016-07-15T00:00:00Z","relpermalink":"/post/rstats/como-importar-qualquer-arquivo-no-r/","section":"post","summary":"Uma das potencialidades do R é que é possível abrir (quase) qualquer tipo de arquivo nele. Arquivos no formato .csv, .txt, .dta, etc., são apenas algumas das opções. Mas esta enorme gama de possibilidades também traz complicações, especialmente porque cada um destes arquivos possui uma função respectiva para importação.","tags":[],"title":"Como importar qualquer arquivo no R","type":"post"},{"authors":["Fernando Meireles"],"categories":["rstats"],"content":"Uma das tarefas mais básicas no R é importar dados. E, dentre todos os tipos de formatos mais usados para armazenar dados, .csv (ou comma-separated values, em inglês) talvez seja o mais comum. Dados demográficos do Instituto Brasileiro de Geografia e Estatística, dados sobre os gastos do governo federal, por exemplo, vêm neste formato.\nAssim como outros ambientes de programação e softwares, o R possui facilidades nativas para importar este tipo de arquivo. Aqui, vou mostrar uma forma de fazer isto.\nImportando dados em .csv com read.csv A primeira forma de carregar dados em .csv no R, e também a mais simples, é por meio da função read.csv(). Por exemplo, vamos supor que queremos abrir um arquivo chamado dados.csv que está localizado no diretório de trabalho no R (é possível verificar o diretório corrento com a função getwd). O procedimento é simples:\ndf \u0026lt;- read.csv(file = \u0026quot;dados.csv\u0026quot;)\r Basicamente, este código apenas atribui a um objeto df o resultado da função read.csv, que serve justamente para importar o conteúdo de um arquivo em .csv. O único argumento que precisamos definir foi file, que é onde devemos especificar o endereço do arquivo (como supomos que o arquivos dados.csv estava no diretório local, apenas o nome do arquivo completo foi necessário; mas é possível especificar outros endereços, como \u0026ldquo;C:/Pasta/dados.csv\u0026rdquo;).\nA função read.csv também possui outros argumentos úteis. O primeiro deles header, que especifica se a primeira linha contém o nome das variáveis (TRUE é o padrão) ou não (para o caso do arquivo não ter o nome das variáveis). O segundo argumento é sep, que indica qual o caractere usado para separar as observações de cada linha (lembrando que um .csv é um tipo de arquivo de texto que apenas separa informações por meio de algum caractere); normalmente, este caractere é ; (ponto e vírgula), mas também é comum o uso de , (vírgula) ou \\t (tab). Erros de importação, como quando o R junta todas as observações numa mesma variável, geralmente ocorrem por falta de especificar corretamente este argumento. Podemos melhorar nossa chamada à função read.csv com estes argumentos:\ndf \u0026lt;- read.csv(file = \u0026quot;dados.csv\u0026quot;, header = TRUE, sep = \u0026quot;;\u0026quot;)\r Com este código, deixamos explícito que a primeira linha do arquivo .csv contém o nome das variáveis, e que o caractere usado para separar as observações é ponto e vírgula.\nOutros argumentos úteis da função read.csv Normalmente, apenas file, header e sep precisam ser especificados para abrir corretamente um .csv. Mas, em alguns casos, problemas adicionais podem tornar necessário o uso de outros argumentos da função. Abaixo, listo três outros deles:\n  stringsAsFactors: por padrão, a função read.csv transforma variáveis que contêm caracteres em factor, o que normalmente não é útil. Para desabilitar isto, basta especificar na chamada à função stringsAsFactors = FALSE\n  fill: nem sempre arquivos .csv possuem todos os valores ordenados no formato correto (por exemplo, uma observação pode ter sido pulada), o que pode gerar erros ao carregá-los. fill = FALSE pode solucionar problemas como este.\n  dec: caractere usado para separar as casas decimais de variáveis numéricas. Muitos bancos vêm com vírgulas cumprindo esta função (30,00, por exemplo); neste caso, é possível declarar dec = \u0026quot;,\u0026quot; para fazer com que a função leia corretamente os dados.\n  ","date":1468281600,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":1468281600,"objectID":"e8002d22ce3ff56d8f6e22b6e2b09e85","permalink":"https://www.femeireles.com/post/rstats/como-importar-dados-em-csv-no-r/","publishdate":"2016-07-12T00:00:00Z","relpermalink":"/post/rstats/como-importar-dados-em-csv-no-r/","section":"post","summary":"Uma das tarefas mais básicas no R é importar dados. E, dentre todos os tipos de formatos mais usados para armazenar dados, .csv (ou comma-separated values, em inglês) talvez seja o mais comum.","tags":[],"title":"Como importar dados em .csv no R","type":"post"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"https://www.femeireles.com/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"},{"authors":null,"categories":null,"content":"Fernando Meireles Departamento de Ciência Política\nUniversidade Federal de Minas Gerais\nBelo Horizonte, Minas Gerais, Brasil\n Lattes   CV in PDF   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":-62135596800,"objectID":"fd36605688ef45e10dc233c860158012","permalink":"https://www.femeireles.com/cv/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/cv/","section":"","summary":"Fernando Meireles Departamento de Ciência Política\nUniversidade Federal de Minas Gerais\nBelo Horizonte, Minas Gerais, Brasil\n Lattes   CV in PDF   ","tags":null,"title":"Curriculum Vitae","type":"page"},{"authors":null,"categories":null,"content":"Datasets  Oversized government coalitions in Latin America Country-year data on oversized government coalitions in all 14 presidential countries in Latin America, spanning from 1979 to 2012. Data used in Oversized Government Coalitions in Latin America (BPSR).  Dataset  Codebook     Dilma Rousseff's Impeachment in the Brazilian Chamber of Deputies Data on the rollcall votes cast by all Brazilian Federal Deputies in the Impeachment process of former President Dilma Rousseff, on April 17, 2016. The dataset also contains information on Deputies' backgrounds and their previous electoral performances.  Dataset  Codebook     PhD theses defended in Brazil (1987--2016) A tidy dataset of all PhD theses defended between 1987 and 2016 in Brazilian postgraduate programs gathered from the Capes Open Data Portal.  Dataset    \n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":-62135596800,"objectID":"be566fdb6f0fa08cfea50d77a89a6b5a","permalink":"https://www.femeireles.com/data/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/data/","section":"","summary":"Datasets  Oversized government coalitions in Latin America Country-year data on oversized government coalitions in all 14 presidential countries in Latin America, spanning from 1979 to 2012. Data used in Oversized Government Coalitions in Latin America (BPSR).","tags":null,"title":"Data","type":"page"},{"authors":null,"categories":null,"content":"Working Papers  The Distributive Politics of Cabinet Ministers Fernando Meireles  \n\n Legislative Representation in a Multilevel System: The Case of Brazil Royce Carroll; Fernando Meireles   \nBook manuscript  Usando R: Um Guia Para Cientistas Políticos Fernando Meireles; Denisson Silva  Manuscript  Book Propospectus    \nPeer-Reviewed Publications 2019  Carreiras Políticas na Câmara dos Deputados: Uma Análise Quase-Experimental. Dados - Revista de Ciências Sociais. Fernando Meireles  \nPDF  Cite  DOI  Supplemental materials  \n\n\n Partisan alignment and requests for federal transfers in Brazil. Revista de Administração Pública. Fernando Meireles  \nPDF  Cite  DOI   \n2017  Magnitude eleitoral e representação de mulheres nos municípios brasileiros. Revista de Sociologia \u0026amp; Política. Fernando Meireles; Luciana Andrade  PDF  Cite  DOI  Scielo     Simulações de Monte Carlo no Ensino de Ciência Política. Revista Brasileira de Ciência Política. Fernando Meireles; Denisson Silva; Filipe Correa  PDF  Cite  DOI  Scielo  Code    2016  Oversized Government Coalitions in Latin America. Brazilian Political Science Review. Fernando Meireles  PDF  Cite  DOI  Scielo  Dataset    2015  Ciência Política na era do Big Data: automação na coleta de dados digitais. Política Hoje. Denisson Silva; Fernando Meireles  PDF  Cite    \nThesis  A Política Distributiva da Coalizão. PhD Thesis. Federal University of Minas Gerais. Fernando Meireles   \nOther Writings  Latin American presidents and their oversized government coalitions. Presidential-Power (blog). Fernando Meireles    Brazil votes on Sunday for the first time since Rousseff was ousted. What will happen to her party? The Washington Post (Monkey Cage). Fernando Meireles; Ryan Lloyd   \n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":-62135596800,"objectID":"40ea366a28f9524de71378c3212c5489","permalink":"https://www.femeireles.com/publication/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/publication/","section":"","summary":"Working Papers  The Distributive Politics of Cabinet Ministers Fernando Meireles  \n\n Legislative Representation in a Multilevel System: The Case of Brazil Royce Carroll; Fernando Meireles","tags":null,"title":"Publications","type":"page"},{"authors":null,"categories":null,"content":"R Packages  electionsBR R Functions to Download and Clean Brazilian Electoral Data (w/ Denisson Silva and Beatriz Costa)  CRAN  GitHub  Project website     genderBR Predict gender from Brazilian first names  CRAN  GitHub     deflateBR Simple functions to deflate nominal Brazilian Reais  CRAN  GitHub     rScielo An R package to scrape meta-data from scientific articles hosted on Scielo  GitHub     codesBR Add Brazilian municipal identifiers to a table  GitHub    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":-62135596800,"objectID":"6fcae98d7df3b6c44952e7b5fed181e3","permalink":"https://www.femeireles.com/software/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/software/","section":"","summary":"R Packages  electionsBR R Functions to Download and Clean Brazilian Electoral Data (w/ Denisson Silva and Beatriz Costa)  CRAN  GitHub  Project website     genderBR Predict gender from Brazilian first names  CRAN  GitHub     deflateBR Simple functions to deflate nominal Brazilian Reais  CRAN  GitHub     rScielo An R package to scrape meta-data from scientific articles hosted on Scielo  GitHub     codesBR Add Brazilian municipal identifiers to a table  GitHub    ","tags":null,"title":"Software","type":"page"},{"authors":null,"categories":null,"content":"Classes  Instituições Políticas: Teoria e Método Ciência Política (graduate level), State University of Rio de Janeiro, IESP-UERJ (2/2019)  Syllabus     Metodologia Científica Geologia (undergraduate), State University of Rio de Janeiro, UERJ (2/2019)    Introdução à Sociologia Filosofia (undergraduate), State University of Rio de Janeiro, UERJ (1/2019)    Análise de Big Data usando R Ciências Sociais (undergraduate), Federal University of Minas Gerais, UFMG (1/2017)  Syllabus     Avaliação de Políticas Públicas Gestão Pública (undergraduate), Federal University of Minas Gerais, UFMG (1/2017)    Gestão no Âmbito Legislativo Gestão Pública (undergraduate), Federal University of Minas Gerais, UFMG (2/2015)   \nShort Courses  Introdução ao R (Modus) MODUS, Federal University of Minas Gerais, UFMG (2/2019)  Syllabus     R Para Análise e Extração de Dados Federal University of Minas Gerais, Faculdade de Direito (1/2017)    Introdução ao R MODUS, Federal University of Minas Gerais, UFMG (2/2017)\nFederal University of Viçosa, UFV (1/2017)\nMestrado Profissional em Políticas Públicas, Federal University of Pernambuco, UFPE (2/2016)\nFederal University of Minas Gerais, UFMG (2/2016)\n  Syllabus     Construção de indicadores nas Ciências Sociais Federal University of Rio Grande do Sul, UFRGS (2/2016)  Syllabus    \nResources  R: Um Guia Prático An introduction to the R programming environment (in Portuguese)  Website     Introdução ao R em 30 minutos A very short introduction to R (in Portuguese)  Slides     Mínimos Quadrados Ordinários An interactive introduction to OLS (in Portuguese)  Website    \n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"pt","lastmod":-62135596800,"objectID":"322dbaccf72a6d71f827fdb2866be935","permalink":"https://www.femeireles.com/teaching/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/teaching/","section":"","summary":"Classes  Instituições Políticas: Teoria e Método Ciência Política (graduate level), State University of Rio de Janeiro, IESP-UERJ (2/2019)  Syllabus     Metodologia Científica Geologia (undergraduate), State University of Rio de Janeiro, UERJ (2/2019)    Introdução à Sociologia Filosofia (undergraduate), State University of Rio de Janeiro, UERJ (1/2019)    Análise de Big Data usando R Ciências Sociais (undergraduate), Federal University of Minas Gerais, UFMG (1/2017)  Syllabus     Avaliação de Políticas Públicas Gestão Pública (undergraduate), Federal University of Minas Gerais, UFMG (1/2017)    Gestão no Âmbito Legislativo Gestão Pública (undergraduate), Federal University of Minas Gerais, UFMG (2/2015)","tags":null,"title":"Teaching","type":"page"}]