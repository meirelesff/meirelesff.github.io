[
  {
    "objectID": "recursos.html",
    "href": "recursos.html",
    "title": "Recursos",
    "section": "",
    "text": "Consultar fontes complementares é uma boa maneira de aprofundar o conteúdo que veremos. Nesse sentido, esses três livros podem funcionar como complementos:\n\nR for Data Science (o livro essencial sobre tidyverse e R, no geral);\nHands-On Programming with R (o meu favorito);\nUsando R: Um Guia para Cientistas Políticos (autopromoção).\n\nTodos têm versões online gratuitas."
  },
  {
    "objectID": "recursos.html#livros",
    "href": "recursos.html#livros",
    "title": "Recursos",
    "section": "",
    "text": "Consultar fontes complementares é uma boa maneira de aprofundar o conteúdo que veremos. Nesse sentido, esses três livros podem funcionar como complementos:\n\nR for Data Science (o livro essencial sobre tidyverse e R, no geral);\nHands-On Programming with R (o meu favorito);\nUsando R: Um Guia para Cientistas Políticos (autopromoção).\n\nTodos têm versões online gratuitas."
  },
  {
    "objectID": "recursos.html#outros-recursos",
    "href": "recursos.html#outros-recursos",
    "title": "Recursos",
    "section": "Outros recursos",
    "text": "Outros recursos\nA comunidade por detrás do R é imensa e, por isso mesmo, existem várias outras formas de encontrar exemplos, tutoriais e materiais de aprendizado. Abaixo, segue uma lista livre de algumas coisas que acho interessantes. Sem ordem necessária:\n\nRBloggers: Um agregador de blogs sobre R no mundo todo;\nRWeekly: Uma espécie de jornal mensal com links relevantes no mundo do R na semana (a curadoria é feita pela própria comunidade);\nR-podcast: Para quem ouve podcasts e realmente está aficcionado pelo R;\nDataCamp: Escola online com cursos sobre R;\nRStudio cheatsheets: Coleção de PDFs que resumem, em uma ou duas páginas, tudo o que é preciso saber sobre determinada ferramenta ou pacote;\nRview: Blog do RStudio que mensalmente compila um post chamado “Top 40”, com os 40 melhores pacotes lançados no mês anterior."
  },
  {
    "objectID": "exercicios/exercicios1.html",
    "href": "exercicios/exercicios1.html",
    "title": "Exercícios I",
    "section": "",
    "text": "Todo o conteúdo do curso pode estar parecendo muito simples até aqui, mas, na prática, é preciso prestar bastante atenção às noções básicas que vimos. Para exemplificar esse ponto, nesses exercícios temos alguns códigos, todos com erros, e o seu objetivo será arrumá-los usando o que vimos até aqui.\n\n\nArrume as seguintes operações para que compilem sem erros:\n\n\"2\" + \"2\"\n(10 + (10)) \\ 10\nsum[2, 2]\n\"3^3\"\n3 x 3\n\n\n\n\nArrume (ou não) essas atribuições de objetos. Tente entender o que o operador atribuidor faz.\n\ntexto &lt; - \"um texto qualquer\"\noutro texto &lt; - \"mais um texto\"\nx &lt; 2\ny = 0\nz &lt;- \"1\" \n\n\n\n\nO que está errado no código abaixo (o objetivo é criar um objeto x que armazene o número 100)?\n\ndez &lt;- 10\ncinco &lt;- dez - 5\ny &lt;- dez &lt;- cinco\nx &lt;- 10 * dez\n\n\n\n\nDe novo, arrume o código (e, de quebra, aprenda o que cada algumas das seguintes funções faz):\n\nprint(uma frase qualquer)\nseq(1 5)\nsum(log(-2), sum(2 + 2))\nabs(\"-dez\")\npaste(\"um\", \"exemplo\", \"de\", \"texto')\nplot(10, ?)\n\n\n\n\nO que há de errado com os exemplos abaixo?\n\nc(\"1\", 0)\n\nmeu_vetor &lt;- c(\"texto\", \"do,\" \"vetor\")\n\nc(c(1, 2), c(3, 4), 5:6\n  \nc(-1.3, \n  -0.3, \n  -0.6, \n  -0.6 \n  -0.2)"
  },
  {
    "objectID": "exercicios/exercicios1.html#arrumando-códigos-com-erro",
    "href": "exercicios/exercicios1.html#arrumando-códigos-com-erro",
    "title": "Exercícios I",
    "section": "",
    "text": "Todo o conteúdo do curso pode estar parecendo muito simples até aqui, mas, na prática, é preciso prestar bastante atenção às noções básicas que vimos. Para exemplificar esse ponto, nesses exercícios temos alguns códigos, todos com erros, e o seu objetivo será arrumá-los usando o que vimos até aqui.\n\n\nArrume as seguintes operações para que compilem sem erros:\n\n\"2\" + \"2\"\n(10 + (10)) \\ 10\nsum[2, 2]\n\"3^3\"\n3 x 3\n\n\n\n\nArrume (ou não) essas atribuições de objetos. Tente entender o que o operador atribuidor faz.\n\ntexto &lt; - \"um texto qualquer\"\noutro texto &lt; - \"mais um texto\"\nx &lt; 2\ny = 0\nz &lt;- \"1\" \n\n\n\n\nO que está errado no código abaixo (o objetivo é criar um objeto x que armazene o número 100)?\n\ndez &lt;- 10\ncinco &lt;- dez - 5\ny &lt;- dez &lt;- cinco\nx &lt;- 10 * dez\n\n\n\n\nDe novo, arrume o código (e, de quebra, aprenda o que cada algumas das seguintes funções faz):\n\nprint(uma frase qualquer)\nseq(1 5)\nsum(log(-2), sum(2 + 2))\nabs(\"-dez\")\npaste(\"um\", \"exemplo\", \"de\", \"texto')\nplot(10, ?)\n\n\n\n\nO que há de errado com os exemplos abaixo?\n\nc(\"1\", 0)\n\nmeu_vetor &lt;- c(\"texto\", \"do,\" \"vetor\")\n\nc(c(1, 2), c(3, 4), 5:6\n  \nc(-1.3, \n  -0.3, \n  -0.6, \n  -0.6 \n  -0.2)"
  },
  {
    "objectID": "exercicios/exercicios1.html#manipulação-de-objetos",
    "href": "exercicios/exercicios1.html#manipulação-de-objetos",
    "title": "Exercícios I",
    "section": "Manipulação de objetos",
    "text": "Manipulação de objetos\nVimos muito conteúdo, precisamos praticá-lo antes de passarmos para a próxima aula.\n\nVetores numéricos I\nQual é a média e a mediana dos vetores abaixo?\n\nc(1, 45, 67, 2.35, 5.6)\n\n[1]  1.00 45.00 67.00  2.35  5.60\n\nc(0.275, -0.883, 1.69, -0.589, -0.778, 1.318, -0.235, -2.166)\n\n[1]  0.275 -0.883  1.690 -0.589 -0.778  1.318 -0.235 -2.166\n\nc(0.3, 0, 0)\n\n[1] 0.3 0.0 0.0\n\nc(0, -1, 0, -1, 1, NA, -2, 1, 1, -2)\n\n [1]  0 -1  0 -1  1 NA -2  1  1 -2\n\n\n\n\nVetores numéricos II\nQual é a somatória (i.e., o valor da soma de todos os elementos) do vetor abaixo? (Dica: use uma função)\n\nx &lt;- c(232, 129, 125, 84, 157, 119, 196, 174, 202, 104)\n\n\n\nVetores numéricos III\nCrie um vetor x com 10 elementos, de 1 a 10. Depois, multiplique esse vetor por 5 e salve seu resultado. Qual é a média dele?\n\n\nVetores numéricos IV\nO que o seguinte código faz (use comentários para escrever sua explicação)?\n\ny &lt;- seq(5, 25, by = 5)\nx &lt;- seq(10, 50, by = 10)\ny * x\n\n[1]   50  200  450  800 1250\n\n\n\n\nManipulação I\nO R vem por padrão com um data.frame chamado mtcars que contém informações sobre 32 modelos de carros extraídos da revista Motor Trend US de 1974 – basta digitar mtcars no console pra vê-lo. Usando tanto tidyverse quanto funções do R-base, descubra:\n\nQuantas variáveis esse banco tem;\nQuantas observações esse banco tem;\nO nome de todas as variáveis."
  },
  {
    "objectID": "exercicios/exercicios1.html#homework",
    "href": "exercicios/exercicios1.html#homework",
    "title": "Exercícios I",
    "section": "Homework",
    "text": "Homework\nPara além dos exercícios dessa página, em cada aula teremos algumas atividade que deverão ser realizadas fora da sala de aula. Essa primeira é simples, mas envolve alguns desafios – coisas que não vimos diretamente e que, portanto, você terá que descobrir por conta própria. Realize essa tarefa em um novo script.\n\nAtividade (Aula I)\nPor padrão, o R vem com um data.frame chamado swiss, que contém dados demográficos e socioeconômicos de 47 províncias francesas da Suíça mensuradas em 1888. Usando o tidyverse, crie um novo data.frame que tenha apenas as variáveis Fertility, Education e Catholic; e apenas as 10 primeiras observações."
  },
  {
    "objectID": "exercicios/exercicios1.html#revisão",
    "href": "exercicios/exercicios1.html#revisão",
    "title": "Exercícios I",
    "section": "Revisão",
    "text": "Revisão\nTambém como tarefa pós-aula, sugiro usar o R: Um Guia Prático para revisar o conteúdo desta aula – na verdade, ele cobre coisas que ainda não abordamos. Ele foi criado para ser um guia básico sobre a programação em R-base e, portanto, pode funcionar como um complemento para quem não entendeu alguma coisa do material de hoje."
  },
  {
    "objectID": "aulas/aula2.html",
    "href": "aulas/aula2.html",
    "title": "Aula 2",
    "section": "",
    "text": "Na última aula, começamos a manipular alguns data.frames simples. Nesta, não só avançaremos nessa tarefa como também aprenderemos a carregar dados de inúmeros formatos. Além disso, usaremos notebooks para combinar códigos e texto."
  },
  {
    "objectID": "aulas/aula2.html#introdução",
    "href": "aulas/aula2.html#introdução",
    "title": "Aula 2",
    "section": "",
    "text": "Na última aula, começamos a manipular alguns data.frames simples. Nesta, não só avançaremos nessa tarefa como também aprenderemos a carregar dados de inúmeros formatos. Além disso, usaremos notebooks para combinar códigos e texto."
  },
  {
    "objectID": "aulas/aula2.html#carregando-dados",
    "href": "aulas/aula2.html#carregando-dados",
    "title": "Aula 2",
    "section": "Carregando dados",
    "text": "Carregando dados\nUma das grandes vantagens de se usar uma linguagem de programação como o R é que, com ela, é possível carregar inúmeros tipos de dado: planilhas do Excel, bases em SQL, texto de websites, JSON, XML, tabelas em um arquivo PDF, e muito mais.\nEm alguns casos, carregar dados demanda mais tempo e trabalho, mas, para a imensa maioria dos outros, tudo se resume a uma ou duas linhas de código.\nPrecisaremos instalar três pacotes:\n\ninstall.packages(\"readxl\") # Para abrir e exportar planilhas de Excel\ninstall.packages(\"haven\") # Para abrir e exportar SPSS e stata\ninstall.packages(\"rio\") # Para abrir e exportar outros formatos\n\nTambém vamos carregar o tidyverse. Usaremos ele bastante hoje.\n\nlibrary(tidyverse)\n\n\nFunções de carregamento\nPara carregar arquivos com dados, como planilhas e similares, normalmente o procedimento é simples: utilizamos alguma função apropriada, passamos para ela o caminho do arquivo (e.g., algo como “C:/pasta/arquivo.xlsx”) e, quando necessário, alguns argumentos adicionais, que especificam como o arquivo deve ser lido (e.g., se o nome das variáveis está na primeira linha da tabela ou não, se é necessário pular algumas linhas, etc.).\nA etapa essencial para carregar dados é identificar a função que deve ser usada para cada formato de arquivo. A tabela abaixo, retirada do Capítulo 3 do Usando R, relaciona alguns desses formatos com as funções que usaremos para carregá-los.\n\nFunções mais comuns para leitura de arquivos no R\n\n\n\n\n\n\n\n\nArquivo\nExtensão\nPacote\nFunção\n\n\n\n\nTexto delimitado\n.txt\nreadr\nread_delim\n\n\nTexto delimitado\n.csv\nreadr\nread_delim, read_csv\n\n\nPlanilha do Excel\nxls, xlsx, .ods\nreadxl, readODS\nread_excel, read.ods\n\n\nBanco de dados do SPSS\n.sav, .por\nhaven\nread_sav, read_por\n\n\nBanco de dados do Stata\n.dta\nhaven\nread_dta\n\n\nBanco de dados do SAS\n.sas7bdat\nhaven\nread_sas\n\n\nJSON\n.json\nrio\nimport\n\n\nR Data\n.Rda\n-\nload\n\n\n\n\n\nTexto delimitado\nComo dá para ver na pasta desta aula, temos vários arquivos denominados municipios_mg.XXX, cada um deles com uma extensão distinta. Estes contêm informações sobre as despesas orçamentarias de 808 municipios mineiros em 2012, retirados do website do Tesouro Nacional (Finbra). Especificamente, temos:\n\nUma versão do arquivo em .csv;\nUma versão do arquivo em .txt;\nUma versão do arquivo em .xlsx (Excel);\nUma versão do arquivo em .dta (Stata);\nUma versão do arquivo em .sav (SPSS);\nE uma versão do arquivo em .Rda (formato nativo do R).\n\nVamos aprender a carregar cada um deles, usando, para isso, alguns dos pacotes que instalamos. Por ser o formato mais simples (basicamente texto separado por vírgula ou outro caractere), vamos pelos delimitado por caracteres. Exemplos (consulte o help de cada função e tente alterar os argumentos de cada uma delas):\n\n# .csv e' um tipo de arquivo delimitado por texto; usamos read_csv ou read_delim para abrilo\n# (mas, se usamos read_delim, precisamos especificar o argumento 'delim')\nbanco1 &lt;- read_csv(\"municipios_mg.csv\")\nbanco2 &lt;- read_delim(\"municipios_mg.csv\", delim = \",\")\n\nAlém do .csv, existem outros formatos que armazenam texto delimitado. .txt é o mais comum dele:\n\n# Le um arquivo .txt separado por TAB (tres espacos):\nbanco3 &lt;- read_delim(\"municipios_mg.txt\", delim = \"   \")\n\n# Se o arquivo for separado por outro caractere (;, ex.), declaramos 'sep =':\nbanco4 &lt;- read_delim(\"municipios_mg2.txt\", delim = \";\") # Sem delim, o arquivo nao abre\n\n\n\n\n\n\n\nCuidado\n\n\n\nArquivos delimitados por texto podem ter diferentes extensões, isto é, apenas abrindo o arquivo com editor de texto (como o bloco de notas) para conseguir identificar com certeza como ele é delimitado.\n\n\nAntes de prosseguir, lembre-se de alguns dos argumentos mais importantes dessas duas funções:\n\ndelim: especifica o caractere delimitador (só na função read_delim);\nlocale: serve para especificar o encoding, evitando caracteres ilegíveis (e.g., locale = locale(encoding = \"latin1\"));\nskip: especifica quantas linhas pular antes de começar a ler os dados.\n\n\n\nStata e SPSS\nÉ bem provável que você já tenha trabalhado, ou conhecido alguém que trabalha, com SPSS ou Stata para fazer análises quantitativas. Há pouco tempo, esses ainda eram os formatos mais comuns para se salvar dados em inúmeras áreas de pesquisa (em algumas, como na Economia, Stata ainda é muito usado). Inevitavelmente, teremos que abrir esse tipo de arquivo vez ou outra.\nDiferentemente dos arquivos delimitados por texto, precisamos apenas usar a função correta para ler esses arquivos .sav e .dta.1 Essas duas, que estão no pacote haven, são: read_spss e read_dta.\nCarregamos o haven (que é parte do tidyverse, embora não seja carregado por ele quando executamos library(tidyverse)):\n\nlibrary(haven)\n\nE carregamos os arquivos passando apenas seus endereços para as funções:\n\n# Para carregarmos um arquivo do SPSS\nbanco6 &lt;- read_spss(\"municipios_mg.sav\")\n\n# Para carregarmos um arquivo do Stata\nbanco7 &lt;- read_dta(\"municipios_mg.dta\")\n\n\n\nExcel\nvamos agora carregar um tipo de arquivo bastante comum: .xlsx ou .xls, do Excel. Para tanto, precisamos carregar o pacote readxl:\n\nlibrary(readxl)\n\nO resto é direto:\n\nbanco8 &lt;- read_excel(\"municipios_mg.xlsx\")\n\nPor padrão, essa função carrega apenas a primeira planilha do arquivo. Caso ele contenha mais de uma, basta especificar ela por meio do argumento sheet:\n\nbanco9 &lt;- read_excel(\"municipios_mg.xlsx\", sheet = 1) # caso fosse a segunda, alterariamos para 2\n\n\n\nRdata\nNo R, a forma mais eficiente de se armazenar e carregar dados é por meio das funções save e load. Isso cria um arquivo no formato .Rda (Rdata), que economiza espaço e é muito mais rápido para ser lido ou gerado.\nAo longo dessa nota, criamos muitos objetos (é possível vê-los na aba Environment do RStudio). Para evitar confusões, vamos apagá-los da memória:\n\nrm(list = ls()) # apaga tudo na memoria\n\nAgora, vamos aprender a criar um data.frame para fazer um teste. Para isso, usaremos a função data.frame (é isso mesmo) da seguinte forma:\n\nteste &lt;- data.frame(nome = c(\"Ana\", \"João\", \"Maria\"), idade = c(42, 32, 28))\n\nÉ fácil entender como essa função funciona apenas pelo código. Para deixar claro, data.frame pode receber diversos argumentos, e cada um dele é o nome que queremos dar para nossas variáveis (.e.g, nome). Assim, criamos uma variável chamada nome cujo conteúdo é um vetor com três nomes em texto; e, a outra, uma numérica chamada idade. O único detalhe é que todas precisam ter o mesmo número de elementos.\nPodemos inspecionar nosso data.frame com glimpse:\n\nglimpse(teste)\n\nRows: 3\nColumns: 2\n$ nome  &lt;chr&gt; \"Ana\", \"João\", \"Maria\"\n$ idade &lt;dbl&gt; 42, 32, 28\n\n\nPara salvá-lo no formato .Rda, apenas usamos:\n\nsave(teste, file = \"teste.Rda\") # \"teste.Rda\" sera' o nome do arquivo\n\nVamos testar para ver se funcionou?\n\nrm(teste) # apaga banco da memoria\nload(\"teste.Rda\") # carrega banco novamente na memoria\n\nEsse é formato que usaremos, e que normalmente é usado em materiais de replicação, para salvar dados.\n\n\nOutros formatos\nExistem inúmeros outros formatos para armazenar arquivos, mas nós não cobriremos todos eles. Os que vimos são os principais e, por isso mesmo, são suficientes para abarcar a imensa maioria dos problemas reais de leitura de dados (para quem deseja se aprofundar no R, certamente será necessário aprender sobre como ingerir outros tipos de dados).\nDe qualquer forma, existe uma maneira de carregar diversos formatos – mesmo alguns que você não conhece – no R: por meio do pacote rio, que funciona como uma espécie de canivete suíço para a importação e exportação de dados. Basta usar sua função import para carregar um arquivo qualquer:\n\nbanco &lt;- import(\"municipios_mg.xlsx\")\n\nPara facilitar a consulta, segue uma lista com todos os tipos de arquivo atualmente suportados pelo pacote rio:\n\nArquivos que podem ser carregados com o pacote rio\n\n\nFormato\nExtensão do arquivo\n\n\n\n\nDados separados por vírgula\n.csv\n\n\nDados separados por pipe\n.psv\n\n\nDados separados por tabulação\n.tsv\n\n\nCSVY (CSV + cabeçalho de metadados YAML)\n.csvy\n\n\nSAS\n.sas7bdat\n\n\nSPSS\n.sav\n\n\nSPSS (comprimido)\n.zsav\n\n\nStata\n.dta\n\n\nSAS XPORT\n.xpt\n\n\nSPSS Portable\n.por\n\n\nExcel\n.xls\n\n\nExcel\n.xlsx\n\n\nSintaxe R\n.R\n\n\nObjetos R salvos\n.RData, .rda\n\n\nObjetos R serializados\n.rds\n\n\nEpiinfo\n.rec\n\n\nMinitab\n.mtp\n\n\nSystat\n.syd\n\n\nArquivos de banco de dados “XBASE”\n.dbf\n\n\nFormato de arquivo de relação de atributos Weka\n.arff\n\n\nFormato de intercâmbio de dados\n.dif\n\n\nDados Fortran\nsem extensão reconhecida\n\n\nDados de formato de largura fixa\n.fwf\n\n\nDados separados por vírgula gzip\n.csv.gz\n\n\nApache Arrow (Parquet)\n.parquet\n\n\nEViews\n.wf1\n\n\nFormato de intercâmbio R/Python Feather\n.feather\n\n\nArmazenamento rápido\n.fst\n\n\nJSON\n.json\n\n\nMatlab\n.mat\n\n\nPlanilha OpenDocument\n.ods\n\n\nTabelas HTML\n.html\n\n\nDocumentos XML superficiais\n.xml\n\n\nYAML\n.yml\n\n\nÁrea de transferência\ntsv\n\n\nGoogle Sheets\ncomo dados separados por vírgula\n\n\nGraphpad Prism\n.pzfx\n\n\n\n\n\n\n\n\n\nAviso\n\n\n\nAlguns formatos suportados pelo rio requerem que algum outro pacote seja instalado (mas o rio avisa quando isso acontece)."
  },
  {
    "objectID": "aulas/aula2.html#exportação",
    "href": "aulas/aula2.html#exportação",
    "title": "Aula 2",
    "section": "Exportação",
    "text": "Exportação\nA maioria das funções que usamos para ler arquivos têm suas equivalentes de exportação. write_delim cria arquivos de texto delimitados, enquanto que write_dta exporta um data.frame para o formato proprietário do Stata. De forma geral, essas e outras funções funcionam da seguinte maneira: primeiro, passe a elas o nome do objeto com o data.frame (e.g., banco); e, depois, passe o nome, ou o endereço e nome, do arquivo a ser gerado (e.g., meu_banco.dta).\nJá vimos como exportar dados para o formato do R. Para os demais, use:\n\nwrite_delim(banco, \"meu_banco.txt\", delim = \";\") # cria um .txt separado por ;\nwrite_delim(banco, \"meu_banco.csv\", delim = \";\") # cria um .csv separado por ;\nwrite_spss(banco, \"meu_banco.sav\",) # cria um .sav\nwrite_dta(banco, \"meu_banco.sav\",) # cria um .dta\n\nTambém podemos usar a função export do rio. Com ela, basta passar o nome do arquivo e de sua extensão que o rio cuida de exportar os dados no formato correto:\n\nexport(banco, \"meu_banco.xlsx\")\nexport(banco, \"meu_banco.csv\")\n\n\n\n\n\n\n\nAviso\n\n\n\nNo R, endereços de arquivos são compostos por /, e não por \\."
  },
  {
    "objectID": "aulas/aula2.html#manipulação",
    "href": "aulas/aula2.html#manipulação",
    "title": "Aula 2",
    "section": "Manipulação",
    "text": "Manipulação\nNa aula passada, começamos a manipular alguns data.frames. Usamos select para selecionar variáveis e slice para observações. Agora, vamos desenvolver um pouco mais essa habilidade.\nEm particular, nessa e na próxima aula veremos quatro tipos de operação, ou verbos, que irão expandir nossa caixa de ferramentas:\n\n\nFatiar (filter e slice, operações horizontais);\n\n\nSelecionar (select, operações verticais);\n\n\nModificar (mutate e summarise, para criar e modificar variáveis e observações);\n\n\nAgrupar (group_by e ungroup, para trabalhar com agrupamentos de dados).\n\n\nTendo este conteúdo dominado, saberemos como realizar uns 90% de todas as tarefas mais comuns em uma análise de dados.\n\nFatiar\nJá vimos uma das funções de fatiar, slice. O que não vimos, talvez, foi como usá-la em bancos maiores. Vamos carregar o data.frame de municípios mineiros novamente para fazer isso.\n\nbanco &lt;- read_csv(\"municipios_mg.csv\")\n\nUsando um pouco do que vimos sobre vetores, podemos filtrar as 5 primeiras observações assim:\n\nslice(banco, 1:5) # 5 primeiras observacoes\n\n# A tibble: 5 × 10\n   ...1 uf    municipio           populacao total_despesas despesas_legislativas\n  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;                   &lt;dbl&gt;          &lt;dbl&gt;                 &lt;dbl&gt;\n1     1 MG    Abadia dos Dourados      6743      14556417.               674132.\n2     2 MG    Abaete                  22740      32239908.              1096878.\n3     3 MG    Abre Campo              13306      21666788                516725.\n4     4 MG    Acaiaca                  3925      10470382.               389075.\n5     5 MG    Acucena                 10093      13689330.               776842.\n# ℹ 4 more variables: despesas_administrativas &lt;dbl&gt;, despesas_seguranca &lt;dbl&gt;,\n#   despesas_assis_social &lt;dbl&gt;, despesas_saude &lt;dbl&gt;\n\n\nOu a primeira e a décima:\n\nslice(banco, c(1, 10))\n\n# A tibble: 2 × 10\n   ...1 uf    municipio           populacao total_despesas despesas_legislativas\n  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;                   &lt;dbl&gt;          &lt;dbl&gt;                 &lt;dbl&gt;\n1     1 MG    Abadia dos Dourados      6743      14556417.               674132.\n2    10 MG    Aguas Vermelhas         12850      16591827.               664422.\n# ℹ 4 more variables: despesas_administrativas &lt;dbl&gt;, despesas_seguranca &lt;dbl&gt;,\n#   despesas_assis_social &lt;dbl&gt;, despesas_saude &lt;dbl&gt;\n\n\nE quanto às últimas? No R, podemos saber o número total de observações de um banco com a função ncol. Basta usar essa informação para obter o que queremos (repita esse código mais de uma vez se precisar):\n\nultima &lt;- ncol(banco)\nantepenultima &lt;- ultima - 2\nslice(banco, antepenultima:ultima)\n\n# A tibble: 3 × 10\n   ...1 uf    municipio       populacao total_despesas despesas_legislativas\n  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;               &lt;dbl&gt;          &lt;dbl&gt;                 &lt;dbl&gt;\n1     8 MG    Aguanil              4129      11269795                376652 \n2     9 MG    Aguas Formosas      18575      23760572.              1104696.\n3    10 MG    Aguas Vermelhas     12850      16591827.               664422.\n# ℹ 4 more variables: despesas_administrativas &lt;dbl&gt;, despesas_seguranca &lt;dbl&gt;,\n#   despesas_assis_social &lt;dbl&gt;, despesas_saude &lt;dbl&gt;\n\n\nOutro uso útil de slice é fatiar observações extremas – os 10 mais populosos municípios, ou os 15 que menos gastaram em saúde. Para isso, precisamos usar slice junto de outra função, arrange, que serve para ordenar as observações de um banco pelos valores de uma ou mais variáveis. Se quisermos ordenar os municípios mineiros do menos ao mais populoso, por exemplo, usamos:\n\narrange(banco, populacao)\n\n# A tibble: 808 × 10\n    ...1 uf    municipio          populacao total_despesas despesas_legislativas\n   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;                  &lt;dbl&gt;          &lt;dbl&gt;                 &lt;dbl&gt;\n 1   740 MG    Serra da Saudade         807       8633423.               351802.\n 2   163 MG    Cedro do Abaete         1199       7684621.               348019.\n 3   296 MG    Grupiara                1373      11917026.               542470.\n 4   247 MG    Doresopolis             1454       9965495.               625317.\n 5   516 MG    Paiva                   1549       7911283.               496032.\n 6    33 MG    Antonio Prado de …      1653       7995453.               336517.\n 7   195 MG    Consolacao              1732       8730656.               396476.\n 8   527 MG    Passabem                1739       7974304.               477376.\n 9   666 MG    Santo Antonio do …      1771       8207188.               350303.\n10   544 MG    Pedro Teixeira          1785       7384735.               398428.\n# ℹ 798 more rows\n# ℹ 4 more variables: despesas_administrativas &lt;dbl&gt;, despesas_seguranca &lt;dbl&gt;,\n#   despesas_assis_social &lt;dbl&gt;, despesas_saude &lt;dbl&gt;\n\n\nPara ordená-los do mais ao menos populoso basta incluir um sinal - na frente do nome da variável (isso será lido como o inverso):\n\narrange(banco, -populacao)\n\n# A tibble: 808 × 10\n    ...1 uf    municipio          populacao total_despesas despesas_legislativas\n   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;                  &lt;dbl&gt;          &lt;dbl&gt;                 &lt;dbl&gt;\n 1    61 MG    Belo Horizonte       2395785    6917817946.            117191852.\n 2   781 MG    Uberlandia            619536    1308373532              24731905 \n 3   196 MG    Contagem              613815    1092061842.             29570662.\n 4   391 MG    Juiz de Fora          525225    1052445814.             15507234.\n 5    65 MG    Betim                 388873    1190141919.             43695221.\n 6   471 MG    Montes Claros         370216     545723569.             10919003.\n 7   603 MG    Ribeirao das Neves    303029     306671476.              7734594.\n 8   780 MG    Uberaba               302623     666251559.             19135916.\n 9   294 MG    Governador Valada…    266190     559832791.              8896911.\n10   336 MG    Ipatinga              243541     531322648.             19045016.\n# ℹ 798 more rows\n# ℹ 4 more variables: despesas_administrativas &lt;dbl&gt;, despesas_seguranca &lt;dbl&gt;,\n#   despesas_assis_social &lt;dbl&gt;, despesas_saude &lt;dbl&gt;\n\n\nAgora, selecionar os 10 maiores é fácil:\n\ndez_maiores &lt;- arrange(banco, -populacao)\ndez_maiores &lt;- slice(dez_maiores, 1:10) # passamos o objeto 'dez_maiores'\ndez_maiores\n\n# A tibble: 10 × 10\n    ...1 uf    municipio          populacao total_despesas despesas_legislativas\n   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;                  &lt;dbl&gt;          &lt;dbl&gt;                 &lt;dbl&gt;\n 1    61 MG    Belo Horizonte       2395785    6917817946.            117191852.\n 2   781 MG    Uberlandia            619536    1308373532              24731905 \n 3   196 MG    Contagem              613815    1092061842.             29570662.\n 4   391 MG    Juiz de Fora          525225    1052445814.             15507234.\n 5    65 MG    Betim                 388873    1190141919.             43695221.\n 6   471 MG    Montes Claros         370216     545723569.             10919003.\n 7   603 MG    Ribeirao das Neves    303029     306671476.              7734594.\n 8   780 MG    Uberaba               302623     666251559.             19135916.\n 9   294 MG    Governador Valada…    266190     559832791.              8896911.\n10   336 MG    Ipatinga              243541     531322648.             19045016.\n# ℹ 4 more variables: despesas_administrativas &lt;dbl&gt;, despesas_seguranca &lt;dbl&gt;,\n#   despesas_assis_social &lt;dbl&gt;, despesas_saude &lt;dbl&gt;\n\n\n\n\nClasses e vetores\nPrecisamos recuar um pouco para entendermos outras operações de fatiamento. Até agora, trabalhos com números, textos e data.frames, e vimos que cada um desses objetos serve para coisas diferentes no R. O que não vimos é que chamamos esses tipos de types (alguns chamam de classes), e que elas são basicamente essas2:\n\nClasses no R\n\n\nTipo\nArmazena\nExemplo\n\n\n\n\nnumeric\nNúmeros reais ou decimais\n2.51\n\n\ninteger\nNúmeros inteiros\n2\n\n\ncharacter\nTexto\n“Meu texto”\n\n\nlogical\nValores lógicos\nTRUE, FALSE\n\n\n\nPara sabermos o tipo ou classe de um objeto3, podemos usar a função class:\n\nclass(1) # numeric\n\n[1] \"numeric\"\n\nclass(1L) # adicionar um L forca o numero a ser integer\n\n[1] \"integer\"\n\nclass(\"texto\") # character\n\n[1] \"character\"\n\nclass(TRUE) # logical\n\n[1] \"logical\"\n\n\nO único que não vimos até agora foi o logical, que serve para fazer testes lógicos no R. Para tanto, usamos operadores lógicos (e.g., \\(&gt;\\), \\(&lt;\\), \\(==\\), \\(!=\\), etc.):\n\n1 &gt; 2 # 1 e' maior que 2?\n\n[1] FALSE\n\n5 &lt; 10 # 5 e' menor que 10?\n\n[1] TRUE\n\n3 == 1:10 # 3 e' igual a algum dos ementos de 1:10?\n\n [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\n\n\nFilter\nMas por que isso é útil? Entre outras coisas, podemos usar testes lógicos para filtrar observações. Vamos manter no banco apenas municípios mineiros com mais de 500 mil habitantes:\n\nfilter(banco, populacao &gt; 500000)\n\n# A tibble: 4 × 10\n   ...1 uf    municipio      populacao total_despesas despesas_legislativas\n  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;              &lt;dbl&gt;          &lt;dbl&gt;                 &lt;dbl&gt;\n1    61 MG    Belo Horizonte   2395785    6917817946.            117191852.\n2   196 MG    Contagem          613815    1092061842.             29570662.\n3   391 MG    Juiz de Fora      525225    1052445814.             15507234.\n4   781 MG    Uberlandia        619536    1308373532              24731905 \n# ℹ 4 more variables: despesas_administrativas &lt;dbl&gt;, despesas_seguranca &lt;dbl&gt;,\n#   despesas_assis_social &lt;dbl&gt;, despesas_saude &lt;dbl&gt;\n\n\nPronto. Quer municípios com mais de 300 e menos de 500 mil? Basta combinar dois operadores lógicos:\n\nfilter(banco, populacao &gt; 300000, populacao &lt; 500000)\n\n# A tibble: 4 × 10\n   ...1 uf    municipio          populacao total_despesas despesas_legislativas\n  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;                  &lt;dbl&gt;          &lt;dbl&gt;                 &lt;dbl&gt;\n1    65 MG    Betim                 388873    1190141919.             43695221.\n2   471 MG    Montes Claros         370216     545723569.             10919003.\n3   603 MG    Ribeirao das Neves    303029     306671476.              7734594.\n4   780 MG    Uberaba               302623     666251559.             19135916.\n# ℹ 4 more variables: despesas_administrativas &lt;dbl&gt;, despesas_seguranca &lt;dbl&gt;,\n#   despesas_assis_social &lt;dbl&gt;, despesas_saude &lt;dbl&gt;\n\n\nMunicípios que não gastaram nenhum real em segurança:\n\nfilter(banco, despesas_seguranca == 0)\n\n# A tibble: 249 × 10\n    ...1 uf    municipio          populacao total_despesas despesas_legislativas\n   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;                  &lt;dbl&gt;          &lt;dbl&gt;                 &lt;dbl&gt;\n 1     1 MG    Abadia dos Dourad…      6743      14556417.               674132.\n 2    14 MG    Albertina               2924       9124485.               435056.\n 3    25 MG    Alvinopolis            15212      19635797.               591043.\n 4    26 MG    Alvorada de Minas       3549      20424866.               507389.\n 5    27 MG    Amparo do Serra         4910      10007480                343099 \n 6    29 MG    Andrelandia            12153      17353942.               498864.\n 7    31 MG    Antonio Carlos         11151      15179265.               470044.\n 8    32 MG    Antonio Dias            9493      19399738.               890663.\n 9    33 MG    Antonio Prado de …      1653       7995453.               336517.\n10    37 MG    Araponga                8188      11839859.               441492.\n# ℹ 239 more rows\n# ℹ 4 more variables: despesas_administrativas &lt;dbl&gt;, despesas_seguranca &lt;dbl&gt;,\n#   despesas_assis_social &lt;dbl&gt;, despesas_saude &lt;dbl&gt;\n\n\n\n\nSelecionar\nTambém já vimos como selecionar variáveis usando select. No geral, funciona assim:\n\nselect(banco, populacao) # seleciona a variavel populacao\n\n# A tibble: 808 × 1\n   populacao\n       &lt;dbl&gt;\n 1      6743\n 2     22740\n 3     13306\n 4      3925\n 5     10093\n 6     14803\n 7      2015\n 8      4129\n 9     18575\n10     12850\n# ℹ 798 more rows\n\n\nMas podemos combiná-la com algumas funções auxiliares. Basicamente, essas funções procuram por alguma palavra no nome das variáveis e, se as encontra (TRUE) em algum caso, as seleciona. Por exemplo, para selecionar todas as variáveis que tenham a palavra “despesa” no nome, basta usar:\n\nselect(banco, contains(\"despesa\"))\n\n# A tibble: 808 × 6\n   total_despesas despesas_legislativas despesas_administrativas\n            &lt;dbl&gt;                 &lt;dbl&gt;                    &lt;dbl&gt;\n 1      14556417.               674132.                 2038985.\n 2      32239908.              1096878.                 4444877.\n 3      21666788                516725.                 1928409.\n 4      10470382.               389075.                 1009928.\n 5      13689330.               776842.                 2165173.\n 6      17321215.               726095.                 2347659.\n 7      12535291.               685995.                 3047432.\n 8      11269795                376652                  1696887 \n 9      23760572.              1104696.                 2034345.\n10      16591827.               664422.                 1481967.\n# ℹ 798 more rows\n# ℹ 3 more variables: despesas_seguranca &lt;dbl&gt;, despesas_assis_social &lt;dbl&gt;,\n#   despesas_saude &lt;dbl&gt;\n\n\nPara uma lista dessas funções, execute help(contains).\nPor fim, note que podemos combinar filter, slice e select se quisermos, basta salvar os resultados de cada operação toda vez.\n\n# Primeiro, selecionamos as 100 primeiras observacoes\nbanco &lt;- slice(banco, 1:100)\n\n# Depois descartamos aqueles com gasto em seguranca igual a 0\nbanco &lt;- filter(banco, despesas_seguranca != 0)\n\n# Por fim, selecionamos apenas algumas variaveis\nbanco &lt;- select(banco, municipio, populacao, total_despesas)\n\nExperimente usar View(banco) para ver como ficou a base após essas transformações.\n\n\nTransformar\nClaro, apenas fatiar e selecionar partes de um data.frame não esgota o que precisamos fazer em uma análise – embora seja algo útil. No mais das vezes, precisamos criar novas variáveis, alterar algumas que já temos, combiná-las. Para essas e outras tarefas, usamos a função mutate. Melhor do que explicar o que ela faz, vejamos um exemplo (se quiser, user View depois):\n\nbanco &lt;- mutate(banco, nova_var = 1)\nglimpse(banco)\n\nRows: 69\nColumns: 4\n$ municipio      &lt;chr&gt; \"Abaete\", \"Abre Campo\", \"Acaiaca\", \"Acucena\", \"Agua Boa…\n$ populacao      &lt;dbl&gt; 22740, 13306, 3925, 10093, 14803, 2015, 4129, 18575, 12…\n$ total_despesas &lt;dbl&gt; 32239908, 21666788, 10470382, 13689330, 17321215, 12535…\n$ nova_var       &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n\n\nBasicamente, o código acima criou uma nova variável no banco chamada nova_var com todos os seus valores iguais a 1. Podemos modificá-la com:\n\nbanco &lt;- mutate(banco, nova_var = \"texto\") # agora ela e' character\nglimpse(banco)\n\nRows: 69\nColumns: 4\n$ municipio      &lt;chr&gt; \"Abaete\", \"Abre Campo\", \"Acaiaca\", \"Acucena\", \"Agua Boa…\n$ populacao      &lt;dbl&gt; 22740, 13306, 3925, 10093, 14803, 2015, 4129, 18575, 12…\n$ total_despesas &lt;dbl&gt; 32239908, 21666788, 10470382, 13689330, 17321215, 12535…\n$ nova_var       &lt;chr&gt; \"texto\", \"texto\", \"texto\", \"texto\", \"texto\", \"texto\", \"…\n\n\nE, o que é mais útil, podemos usar variáveis que já temos no banco para criar outra. Usando populacao e total_despesas, por exemplo, podemos calcular os gastos per capita de cada um dos municípios no nosso data.frame:\n\n# Gasto per capita e' igual o total gasto divido pela populacao\nbanco &lt;- mutate(banco, gasto_per_capita = total_despesas / populacao)\n\nIndo além, podemos criar uma versão dessa variável em logaritmo e em logaritmo de base 10 (o que é útil em alguns modelos estatísticos):\n\n# Quebramos as linhas para facilitar a leitura\nbanco &lt;- mutate(banco, \n                gasto_per_capita_log = log(gasto_per_capita),\n                gasto_per_capita_log10 = log10(gasto_per_capita))\n\nUsando operadores lógicos, também podemos criar variáveis condicionalmente. Como exemplo, vamos criar uma variável categórica que assume dois valores: “Mais ricos”, para municípios com gasto per capita maior que R$ 2000,00, e “Mais pobres” para o resto; e, para isso, vamos usar a função ifelse, que serve para atribuir valores condicionalmente.\n\nbanco &lt;- mutate(banco, \n                nova_var = ifelse(gasto_per_capita &gt; 2000, \"Mais ricos\", \"Mais pobres\"))\n\nComo dá para perceber, ifelse realiza um teste lógico em cima de cada observação da variável gasto_per_capita; quando o resultado é positivo (TRUE), ela retorna o primeiro valor após a vírgula, “Mais ricos”; caso contrário, retorna “Mais pobres”. Teste isso com esses códigos:\n\nx &lt;- 1\ny &lt;- 2\nifelse(x &gt; y, \"x e' maior que y\", \"y e' maior ou igual a x\")\n\n[1] \"y e' maior ou igual a x\"\n\nx &lt;- 3\ny &lt;- 2\nifelse(x &gt; y, \"x e' maior que y\", \"y e' maior ou igual a x\")\n\n[1] \"x e' maior que y\"\n\n\nPraticar essas habilidades é essencial para poder limpar dados com fluência. Uma vez que você domine essas ferramentas, arrumar qualquer banco torna-se questão de poucos minutos.\n\n\nAgrupar\nAlém de manipular variáveis diretamente, muitas vezes precisamos realizar operações agrupadas – calcular a média do gasto per capita por porte do município, por exemplo. A função group_by serve exatamente para isso. A título de exemplo, suponha que queremos calcular o gasto per capito médio de municípios ricos e pobres (variável que criamos anteriormente):\n\ngroup_by(banco, nova_var) %&gt;%\n  mutate(gasto_pc_medio = mean(gasto_per_capita))\n\n# A tibble: 69 × 8\n# Groups:   nova_var [2]\n   municipio       populacao total_despesas nova_var    gasto_per_capita\n   &lt;chr&gt;               &lt;dbl&gt;          &lt;dbl&gt; &lt;chr&gt;                  &lt;dbl&gt;\n 1 Abaete              22740      32239908. Mais pobres            1418.\n 2 Abre Campo          13306      21666788  Mais pobres            1628.\n 3 Acaiaca              3925      10470382. Mais ricos             2668.\n 4 Acucena             10093      13689330. Mais pobres            1356.\n 5 Agua Boa            14803      17321215. Mais pobres            1170.\n 6 Agua Comprida        2015      12535291. Mais ricos             6221.\n 7 Aguanil              4129      11269795  Mais ricos             2729.\n 8 Aguas Formosas      18575      23760572. Mais pobres            1279.\n 9 Aguas Vermelhas     12850      16591827. Mais pobres            1291.\n10 Aimores             24937      42297659. Mais pobres            1696.\n# ℹ 59 more rows\n# ℹ 3 more variables: gasto_per_capita_log &lt;dbl&gt;, gasto_per_capita_log10 &lt;dbl&gt;,\n#   gasto_pc_medio &lt;dbl&gt;\n\n\nComo dá para ver, depois de usar group_by todas as operações que realizamos com mutate são aplicadas dentro de cada grupo. Isso nos permite calcular medidas de resumo como média, ou soma, por exemplo.\nFinalmente, também podemos usar group_by com outra função, summarise, para criar novos data.frames com resumos por grupo – a diferença é que, em vez de criar novas colunas, criamos bases menores. Um exemplo:\n\ngroup_by(banco, nova_var) %&gt;%\n  summarise(gasto_pc_medio = mean(gasto_per_capita))\n\n# A tibble: 2 × 2\n  nova_var    gasto_pc_medio\n  &lt;chr&gt;                &lt;dbl&gt;\n1 Mais pobres          1483.\n2 Mais ricos           2768."
  },
  {
    "objectID": "aulas/aula2.html#utilizando-pipes",
    "href": "aulas/aula2.html#utilizando-pipes",
    "title": "Aula 2",
    "section": "Utilizando pipes",
    "text": "Utilizando pipes\nNesta aula, usamos bastante o operador pipe (%&gt;%), que serve basicamente para simplificar código. No lugar de aninhar uma função dentro da outra (o que pode tornar um código confuso), o pipe cria uma espécie de cadeia de código:\n\n# Sem pipe\nbanco_agrupado &lt;- group_by(banco, nova_var)\nbanco_resumido &lt;- summarise(banco_agrupado, gasto_pc_medio = mean(gasto_per_capita))\nbanco_final &lt;- arrange(banco_resumido, gasto_pc_medio)\n\n# Com pipe\nbanco_final &lt;- banco %&gt;%\n  group_by(nova_var) %&gt;%\n  summarise(gasto_pc_medio = mean(gasto_per_capita)) %&gt;%\n  arrange(gasto_pc_medio)\n\nO pipe é uma funcionalidade do pacote magrittr, parte do tidyverse. Desde a sua versão 4.1.0, o R agora inclui outra versão do pipe que não depende de carregarmos nenhum pacote – o |&gt;. Adaptando o exemplo anterior:\n\n# Novo pipe\nbanco_final &lt;- banco |&gt;\n  group_by(nova_var) |&gt;\n  summarise(gasto_pc_medio = mean(gasto_per_capita)) |&gt;\n  arrange(gasto_pc_medio)\n\nQual dos dois usar? Há várias razões para preferir um ou outro, mas, até por uma questão de disponibilidade de materiais sobre, usar %&gt;% é uma escolha mais fácil, ao menos no início. É a que adotamos aqui."
  },
  {
    "objectID": "aulas/aula2.html#footnotes",
    "href": "aulas/aula2.html#footnotes",
    "title": "Aula 2",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nArquivos do Stata dependem da versão do software na qual ele foi criado, o que às vezes gera problemas de incompatibilidade ao carregá-los no R. Se isso acontecer, tente usar essa outra função: read.dta do pacote feoreign (é preciso carregá-lo).↩︎\nNão abordaremos algumas, como complex e raw.↩︎\nAs duas coisas, tipo e classe, se referem a coisas ligeiramente diferentes. Por ser comum usar os dois termos de forma equivalente por aí, também farei isso nessas notas.↩︎"
  },
  {
    "objectID": "aulas/aula3.html",
    "href": "aulas/aula3.html",
    "title": "Aula 3",
    "section": "",
    "text": "A última aula introduziu diversas ferramentas. Entre outras coisas, aprendemos a carregar dados dos formatos mais comuns, e também vimos alguns meios para carregar outros formatos usando o pacote rio; também aprendemos a usar os principais verbos em uma análise dados com o tidyverse, cobrindo o principal que normalmente é necessário para transformar variáveis e organizar linhas e colunas.\nEsta aula dá um passo adiante e introduz noções básicas de visualização de dados em R. Especificamente, estudaremos como compor visualizões, de simples a complexas, usando a gramática implementada pelo pacote ggplot2. Também veremos operações por grupos – o último verbo que não cobrimos ontem – e como cruzar, unir e comparar data.frames, o que nos permitirá resumir mesmo grandes bases de dados."
  },
  {
    "objectID": "aulas/aula3.html#introdução",
    "href": "aulas/aula3.html#introdução",
    "title": "Aula 3",
    "section": "",
    "text": "A última aula introduziu diversas ferramentas. Entre outras coisas, aprendemos a carregar dados dos formatos mais comuns, e também vimos alguns meios para carregar outros formatos usando o pacote rio; também aprendemos a usar os principais verbos em uma análise dados com o tidyverse, cobrindo o principal que normalmente é necessário para transformar variáveis e organizar linhas e colunas.\nEsta aula dá um passo adiante e introduz noções básicas de visualização de dados em R. Especificamente, estudaremos como compor visualizões, de simples a complexas, usando a gramática implementada pelo pacote ggplot2. Também veremos operações por grupos – o último verbo que não cobrimos ontem – e como cruzar, unir e comparar data.frames, o que nos permitirá resumir mesmo grandes bases de dados."
  },
  {
    "objectID": "aulas/aula3.html#uma-gramática-de-gráficos",
    "href": "aulas/aula3.html#uma-gramática-de-gráficos",
    "title": "Aula 3",
    "section": "Uma gramática de gráficos",
    "text": "Uma gramática de gráficos\nPraticamente qualquer gráfico imaginável pode ser criado com o R: mapas, diagramas, gráficos comentados, gráficos interpolados, entre inúmeros outros. Mas, em meio a tantas possibilidades, estruturar o que queremos pode ser muito complicado – imagine, por exemplo, ter que lidar com uma função para cada tipo de específico de gráfico.\nFelizmente, existe uma alternativa simples que, com poucas funções, nos permite criar uma ampla gama de visualizações totalmente customizáveis: o ggplot2.\nComo o ggplot2 faz parte do tidyverse e, portanto, podemos carregá-lo com (note nas mensagens que aparece ggplot2):\n\n# Carrega o tidyverse\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nParticularmente, o ggplot2 implementa uma forma de se criar gráficos que segue uma espécie de gramática1 que estrutura visualizações em diferentes camadas. A ideia central dessa gramática é simples: um gráfico pode ser descrito como um conjunto de elementos, ou camadas (layers), que se relacionam de uma forma específica. Na terminologia do ggplot2, essas camadas são:\n\nDados: os dados que queremos visualizar\nMapeamento estético (aes): as variáveis desses dados e como elas serão traduzidas em representação visual\nGeometrias (geom): os elementos visuais que representam os dados (e.g., pontos, linhas, barras, etc)\nEscala: as métricas utilizadas pra representar valores de forma visual\nCoordenadas: a posição dos elementos nos gráficos\nFacets: a forma com que os gráficos serão exibidos quando houver grupos nos dados\nTema: a aparência do gráfico (e.g., cores, formas, traçados, textos, etc.)\n\nDescrevendo assim, a gramática do ggplot2 parece complexa, mas ela é tão simples quanto esse código aqui, que faz um gráfico de pontos (scatterplot):\n\nggplot(mtcars, aes(x = mpg, y = disp)) +\n  geom_point()\n\n\n\n\nVale notar: com duas linhas fizemos um gráfico com qualidade visual suficiente para ser usada em uma publicação científica, ou em um relatório comercial, por exemplo.\n\nMontando as camadas de um gráfico\nPara aprendermos a usar o ggplot2 para criar gráficos, usaremos uma base de dados com informacoes de 853 municipios brasileiros auditados pela CGU, usados por Carnes e Lupu (2016) em artigo publicado no Journal of Politics. O artigo examina se o grau de escolaridade de uma(o) política(o) afeta o seu desempenho no cargo, e esta base, em particular, contém diversas variaveis úteis para explorar a questão, tais como:\n\nPartido da prefeita de cada município na base;\nIdade;\nEscolaridade;\nIndicadores sociais e demográficos do município;\nQuantia detectada como corrupção pela CGU no municipio.\n\nComo a base está em formato .dta (carnes_lupu_2015_audits.dta), usaremos o pacote rio para carregá-la:\n\nlibrary(rio)\ndados &lt;- import(\"carnes_lupu_2015_audits.dta\")\n\nPodemos checar alguns detalhes do banco com funcções que já vimos:\n\nglimpse(dados)\n\nRows: 1,199\nColumns: 18\n$ party_name      &lt;chr&gt; \"PARTIDO DA SOCIAL DEMOCRACIA BRASILEIRA\", \"PARTIDO PR…\n$ age             &lt;dbl&gt; 47, 38, 52, 37, 45, 46, 47, 47, 58, 66, 49, 49, 60, 37…\n$ college         &lt;dbl&gt; 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, …\n$ female          &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, …\n$ term            &lt;dbl&gt; 2001, 2001, 2001, 2001, 2001, 2001, 2001, 2001, 2001, …\n$ id_city         &lt;dbl&gt; 1200013, 1200252, 1200336, 1200351, 1200385, 1200708, …\n$ broad           &lt;dbl&gt; 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ narrow          &lt;dbl&gt; 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, …\n$ fraction_broad  &lt;dbl&gt; 0.9530503, 0.0000000, 22.4163132, 0.0000000, 0.0000000…\n$ fraction_narrow &lt;dbl&gt; 0.0000000, 0.0000000, 20.9131775, 0.0000000, 0.0000000…\n$ pop             &lt;dbl&gt; 7935.333, 13461.333, 10902.333, 9958.000, 31561.666, 1…\n$ literacy        &lt;dbl&gt; 0.4504872, 0.6651523, 0.3881470, 0.3844586, 0.3607250,…\n$ urb             &lt;dbl&gt; 0.4418400, 0.6642475, 0.5222172, 0.5620765, 0.3691961,…\n$ income          &lt;dbl&gt; 116.92143, 255.72360, 77.32038, 45.72415, 33.86393, 60…\n$ regions         &lt;dbl&gt; 0.83114183, 0.83216941, 0.83114183, 0.46778899, 0.0963…\n$ close           &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, …\n$ closenocollege  &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, …\n$ closecollege    &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …\n\n\nVale recapitular um pouco da mecânica do ggplot. Em um primeiro nivel, todo gráfico feito com ele começa com uma declaração explícita dos dados e das variáveis que serão usadas nos eixos. Declaramos isto por meio da função ggplot().\n\nggplot(dados, aes(x = urb, y = income))\n\n\n\n\nComo dá para ver, temos duas camadas já declaradas: passados os dados que usaremos para a função ggplot e, também, as variáveis que usaremos para a função aes, que gerencia a tradução delas em componentes estéticos. Rodando o código, dá para ver também que essa primeira camada cria um painel em branco, já indicando qual variável ficará no eixo X (urb) e no eixo Y (income).\nNosso próximo passo é indicar como iremos visualizar essa informação. Aqui entra, especificamente, a seleção de tipo de gráfico que queremos criar, isto é, a sua geometria. Usaremos um scatterplot.\n\nggplot(dados, aes(x = urb, y = income)) + \n  geom_point()\n\n\n\n\nComo vimos, bastou adicionar uma nova função, antecedida por + (operador de união de layers no ggplot2), para indicar como a informação (os dados) deve ser exibidos. Essa é a chave de como o ggplot2 funciona: ele adiciona camadas sobre camadas para criar gráficos, e isso é um processo relativamente flexível porque nos permite adicionar, ou controlar, diversos aspectos de um gráfico, dos mais aos menos gerais.\nPodemos adicionar uma curva sobre os pontos que já criamos usando a função geom_smooth:\n\nggplot(dados, aes(x = urb, y = income)) + \n  geom_point() + \n  geom_smooth()\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\nNo exemplo anterior, temos 4 camadas: dados, variáveis a serem traduzidas esteticamente, uma geometria de pontos e outra geometria de curva (um modelo).\nPodemos agrupar pontos comuns, criando um gráfico com pontos de diferentes tamanhos:\n\nggplot(dados, aes(x = urb, y = income)) + \n  geom_count()\n\n\n\n\nO que precisa ficar claro, aqui, é que cada camada de um gráfico deve seguir uma ordem mínima:\n\nPrimeiro, usamos ggplot() para passar dados e aes para indicar as variáveis de cada eixo;\nSegundo, indicamos os geoms (e.g., geom_point) para criar as visualizações;\nPor fim, adicionamos outros elementos, como o título dos eixos ou o tema do gráfico;\n\nAlem disso, tambem é preciso notar que determinados gráficos requerem diferentes tipos de variáveis. Por exemplo, um scatterplot requer duas variáveis, com eixos X e Y. Um histograma, por sua vez, requer apeanas uma, a do eixo X.\n\nggplot(dados, aes(x = urb)) + \n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nOutros gráficos ainda requerem variáveis adicionais. Por exemplo, vamos criar o gráfico de pontos com urb vs. income novamente.\n\nggplot(dados, aes(x = urb, y = income)) + \n  geom_point()\n\n\n\n\nEle indica a relação entre urb e income de um município. Mas vamos dizer que queremos adicionar uma terceira dimensão no gráfico, como literacy. Para isso, passamos mais uma variável para a função aes():\n\nggplot(dados, aes(x = urb, y = income, color = literacy)) + \n  geom_point()\n\n\n\n\nEm resumo, todos os gráficos que fizemos seguem um padrão: adicionamos elementos a ele em camadas, somando funções: isto() + aquilo() + etc()\nDentro outros, também vimos que:\n\nTodo gráfico começa com uma chamada de ggplot, que recebe uma base de dados (primeira camada);\naes() (de aesthetics) é usada para as variáveis (segunda camada);\nas funcoes geom_ (de geometry) são usadas para plotar as informações (terceira camada);\ne que outras funções podem ser combinadas (quarta, quinta, sexta, etc, camadas)."
  },
  {
    "objectID": "aulas/aula3.html#footnotes",
    "href": "aulas/aula3.html#footnotes",
    "title": "Aula 3",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nFoge um pouco do tema da aula, mas essa ideia originalmente foi introduzida por um estatístico chamado Leland Wilkinson; pra quem quiser se aprofundar nessa gramática e na sua implementação em R, o melhor lugar é esse livro de outro estatístico, Hadley Wickham.↩︎"
  },
  {
    "objectID": "aulas/aula1.html",
    "href": "aulas/aula1.html",
    "title": "Aula 1",
    "section": "",
    "text": "É bem provável que você já tenha alguma ideia sobre o que o R é e o que ele faz. Também assumo que você já tem o R e o RStudio instalados. Se isso não for o caso, clique nos links anteriores e faça isso – ou peça ajuda em sala de aula.\nAntes de prosseguir, vamos preparar o terreno: o R é um ambiente de programação, o que significa que não abriremos um banco de dados utilizando um menu de tarefas, nem calcularemos estatísticas clicando em um botão. Em vez disso, precisaremos programar, isto é, escrever código de forma ordenada que será executado sequencialmente pelo computador. Aprender a programar, especialmente no início, pode ser um pouco difícil, mas acho que não preciso reforçar o quanto todo o esforço envolvido valerá à pena.\n\n\nEsta e as demais notas do curso devem ser usadas da seguinte forma:\n\nLeia o texto;\nTudo o que estiver em uma caixa cinza, com texto destacado por diferentes cores, é código e pode ser executado (copie e cole no R);\nTudo o que estiver em branco, antecedido por [1] ou algo assim, e sem destaque no texto, é output do R;\nAlguns códigos dependem de códigos anteriores; caso encontre algum erro ao rodar um exemplo, tente voltar atrás e rodar o código anterior."
  },
  {
    "objectID": "aulas/aula1.html#introdução",
    "href": "aulas/aula1.html#introdução",
    "title": "Aula 1",
    "section": "",
    "text": "É bem provável que você já tenha alguma ideia sobre o que o R é e o que ele faz. Também assumo que você já tem o R e o RStudio instalados. Se isso não for o caso, clique nos links anteriores e faça isso – ou peça ajuda em sala de aula.\nAntes de prosseguir, vamos preparar o terreno: o R é um ambiente de programação, o que significa que não abriremos um banco de dados utilizando um menu de tarefas, nem calcularemos estatísticas clicando em um botão. Em vez disso, precisaremos programar, isto é, escrever código de forma ordenada que será executado sequencialmente pelo computador. Aprender a programar, especialmente no início, pode ser um pouco difícil, mas acho que não preciso reforçar o quanto todo o esforço envolvido valerá à pena.\n\n\nEsta e as demais notas do curso devem ser usadas da seguinte forma:\n\nLeia o texto;\nTudo o que estiver em uma caixa cinza, com texto destacado por diferentes cores, é código e pode ser executado (copie e cole no R);\nTudo o que estiver em branco, antecedido por [1] ou algo assim, e sem destaque no texto, é output do R;\nAlguns códigos dependem de códigos anteriores; caso encontre algum erro ao rodar um exemplo, tente voltar atrás e rodar o código anterior."
  },
  {
    "objectID": "aulas/aula1.html#escrevendo-código",
    "href": "aulas/aula1.html#escrevendo-código",
    "title": "Aula 1",
    "section": "Escrevendo código",
    "text": "Escrevendo código\nCom o RStudio aberto, é possível ver que temos uma janela chamada console.1 Podemos digitar código nela. Experimente digitar o número 2 e teclar Enter:\n\n2\n\n[1] 2\n\n\nO R reproduzirá o 2 seguido de [], geralmente com algum número dentro. Aproveitando a deixa, # indica um comentário: tudo o que vem sucedido de # o R não executará.\n\n# 2\n\nNada acontece. Comentários são úteis para documentar nossos códigos, algo que veremos em seguida. Por enquanto, experimente usar o console como uma calculadora (logo veremos usos mais interessantes do R):\n\n1 + 1\n\n[1] 2\n\n2 * 3\n\n[1] 6\n\n(1 + 1) * 3\n\n[1] 6\n\n\n\nOperadores\nNote que estamos usando operadores aritméticos: \\(+\\), \\(-\\), \\(*\\), etc. No R, existem outros (tente adaptar os exemplos):\n\n3^2\n\n[1] 9\n\n11 / 5\n\n[1] 2.2\n\n11 %/% 5\n\n[1] 2\n\n11 %% 5\n\n[1] 1\n\n\nPara quem teve dificuldades em entender algum dos operadores, são eles (perceba como estou usando os comentários para explicar meu código, e perceba também que não estou usando acentos ou cedilhas):\n\n2 + 2 # adicao\n\n[1] 4\n\n2 - 2 # subtracao\n\n[1] 0\n\n2 / 2 # divisao\n\n[1] 1\n\n2 * 2 # multiplicacao\n\n[1] 4\n\n2^2 # exponenciacao\n\n[1] 4\n\n3 %/% 2 # divisao sem resto\n\n[1] 1\n\n3 %% 2 # resto da divisao\n\n[1] 1\n\n\nTodos esses operadores são úteis – mas certamente não é por causa deles que o R é tão utilizado."
  },
  {
    "objectID": "aulas/aula1.html#funções",
    "href": "aulas/aula1.html#funções",
    "title": "Aula 1",
    "section": "Funções",
    "text": "Funções\nParte da potencialidade do R advém do fato dele conter uma série de funções nativas para realizar as mais diversas tarefas de pesquisa. É por isso que ele é considerado um ambiente, e não apenas uma linguagem de programação.2\nAlgumas funções úteis para operações aritméticas são:\n\nsqrt(4) # raiz quadrado de 4\n\n[1] 2\n\nlog(4) # logaritmo natural de 4\n\n[1] 1.386294\n\nsum(3, 3) # soma dois numeros\n\n[1] 6\n\n\nVale relembrar: uma função nada mais é do que uma espécie de ferramenta que recebe uma determinada informação e transforma ela em outra. sum(2, 2) recebe dois números (e.g., 2 e 2) e nos devolve outro, 4.\nDe forma esquemática, vale memorizar o seguinte: funções em R (e em outras linguagens de programação) seguem a fórmula nome da função ( input ), ou nome_da_funcao(input).\n\nUsando funções\nNo R, as informações que passamos para determinada função vão dentro de parêntesis. sum, por exemplo, pode receber mais de uma, todas separadas por vírgula.\n\nsum(2 2) # retorna erro \n\nError: &lt;text&gt;:1:7: unexpected numeric constant\n1: sum(2 2\n          ^\n\n\n\nsum(2, 2) # nao retorna erro\n\n[1] 4\n\n\nCada função normalmente aceita tipos específicos de informação. sum, por exemplo, não recebe texto (afinal, não é possível fazer operações aritméticas com texto).\n\nsum(\"texto\") # nao funciona\n\nError in sum(\"texto\"): 'type' inválido (character) do argumento\n\n\nVeja também que a mensagem de erro é bem informativa: \"texto\" é um invalid ‘type’ of argument.\n\n\nAjuda\nPara saber quais informações – argumentos ou inputs, como passaremos a chamá-las – cada função recebe, basta usar a função help.\n\nhelp(sum)\n\nIsso abrirá uma página de ajuda (em inglês) que, entre outras coisas, documenta quais argumentos uma função deve receber e o que ela faz. Não posso deixar de mencionar: buscar no Google, ou pedir ajuda ao ChatGPT, às vezes é muito mais simples e rápido (tente buscar por “como calcular logaritmo no R”, por exemplo, ou perguntar diretamente ao ChatGPT)."
  },
  {
    "objectID": "aulas/aula1.html#objetos",
    "href": "aulas/aula1.html#objetos",
    "title": "Aula 1",
    "section": "Objetos",
    "text": "Objetos\nTudo no R é um objeto, algo que é armazenado na memória. Criamos objetos com outro operador, o &lt;-, chamado operador de atribuição3:\n\nx &lt;- 10\nx + x\n\n[1] 20\n\nx * 5.5\n\n[1] 55\n\n\nComeçamos a tocar em algo importante: salvando números em um objeto, podemos acessá-lo fazendo apenas referência ao nome dele.\n\nx\n\n[1] 10\n\n\nMais ainda, se fizermos alguma operação usando x, ele preservará seu valor original:\n\nx + 10 # adiciono 10 ao valor original de x\n\n[1] 20\n\nx # mas x permanece com o mesmo valor\n\n[1] 10\n\n\nComo fazer, então, para salvar o resultado de uma operação? Criando um novo objeto.\n\nnovo_x &lt;- x + 10\nnovo_x # agora sim\n\n[1] 20\n\n\nObjetos no R também podem armazenar texto.\n\nx &lt;- \"texto\"\nx\n\n[1] \"texto\"\n\n\nAo fazer isso, x é sobrescrito (perdemos o valor antigo dele).\nE, como seria de se esperar, podemos passar objetos para funções. Suponha que eu tenha salvo o valor 10 dentro do objeto chamado meu_objeto e queira calcular a raiz quadrada dele. Em código:\n\nmeu_objeto &lt;- 10\nsqrt(meu_objeto)\n\n[1] 3.162278\n\n\nSó algumas poucas regras quando criamos objetos: os nomes deles não podem começar por números ou caracteres especiais (e.g., 1objeto); não podem ter espaço (e.g., meu objeto); e, embora não dê erros na hora, não devem ter nomes de funções do R (e.g., sum). Também é uma boa prática evitar letras maiúsculas e usar _ para separar palavras (e.g., meu_objeto)."
  },
  {
    "objectID": "aulas/aula1.html#vetores",
    "href": "aulas/aula1.html#vetores",
    "title": "Aula 1",
    "section": "Vetores",
    "text": "Vetores\nVimos que podemos salvar números e texto em objetos no R. O que não vimos é que existe uma estrutura em comum por detrás desses exemplos de objetos: os vetores.\nVetores nada mais são do que conjuntos de elementos do mesmo tipo, que são armazenados na memória como tal pelo R. Uma variável em um banco de dados, por exemplo, pode servir para armazenar a idade de várias pessoas, ou seus nomes. Para o R, mesmo um único dígito, como o número 2, é um vetor – um vetor com apenas um elemento, obviamente.\nCriamos vetores com a função c (acrônimo de concatenate ou combine):\n\nc(1, 2, 3) # Cria um vetor com tres elementos\n\n[1] 1 2 3\n\n\nPodemos fazer o mesmo com texto.\n\nc(\"Cachorro\", \"Gato\", \"Peixe\", \"Rinoceronte\") # um vetor com texto\n\n[1] \"Cachorro\"    \"Gato\"        \"Peixe\"       \"Rinoceronte\"\n\n\nPara sequências numéricas, também é possível usar o operador : da seguinte forma:\n\n1:10 # produz um vetor numerico com 10 elementos\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n10:5\n\n[1] 10  9  8  7  6  5\n\n\nOu, ainda, também podemos usar a função seq:\n\nseq(1, 10) # uma sequencia de 1 a 10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(10, 5) # uma sequencia de 10 a 5\n\n[1] 10  9  8  7  6  5\n\n\nUma das maiores utilidades de trabalhar com vetores (além de combiná-los em bancos de dados) é poder usar vetorização. Melhor do que explicar, veja um exemplo de operação vetorizada:\n\nc(2, 2, 2, 2) * 10 # todos os numeros do vetor sao multiplicados por 10\n\n[1] 20 20 20 20\n\n\nOperações vetorizadas no R são muito rápidas – justamente uma das coisas que fazem o R uma linguagem de programação útil para o desenvolvimento de modelos ou algoritmos que usam operações com vetores e matrizes."
  },
  {
    "objectID": "aulas/aula1.html#funções-e-vetores",
    "href": "aulas/aula1.html#funções-e-vetores",
    "title": "Aula 1",
    "section": "Funções e vetores",
    "text": "Funções e vetores\nMais interessante do que criar vetores, entretanto, é usá-los. Como exemplo, vou criar um vetor com 5 elementos e calcular sua média com a função mean:\n\nmeu_vetor &lt;- c(1.01, 0.56, 0.53, 0.63, -2.17)\nmean(meu_vetor)\n\n[1] 0.112\n\n\nOu seu desvio-padrão e mediana:\n\nsd(meu_vetor) # desvio-padrao\n\n[1] 1.290124\n\nmedian(meu_vetor) # mediana\n\n[1] 0.56\n\n\nSe tivermos mais um vetor numérico com o mesmo número de elementos (use length() para saber o número de elementos de um vetor), podemos inclusive regredir um em outro.\n\n# Criamos um novo vetor\ny &lt;- c(-1.17, 0.61, -0.01, -0.12, -2.21)\n\n# E usamos a funcao lm, que estima uma regressao linar\n# (nao se preocupe com os detalhes de como usa-la)\nlm(y ~ meu_vetor) \n\n\nCall:\nlm(formula = y ~ meu_vetor)\n\nCoefficients:\n(Intercept)    meu_vetor  \n    -0.6506       0.6308"
  },
  {
    "objectID": "aulas/aula1.html#tidyverse",
    "href": "aulas/aula1.html#tidyverse",
    "title": "Aula 1",
    "section": "tidyverse",
    "text": "tidyverse\nO conteúdo que cobrimos até aqui é um fundamento sólido para avançarmos. Em um curso convencional, continuaríamos a ver mais noções de programação propriamente dita: classes, outros operadores, controle de fluxo. Neste, não.\nDaqui até o final, usaremos o R para fazer o tipo de coisas em que ele é bom: abrir e manipular bases de dados, fazer gráficos, transformar variáveis. Para isso, usaremos uma ferramenta que não nativa do R: um conjunto de pacotes chamado tidyverse.\nEsses pacotes fornecem inúmeras funções e operadores que nos permitem realizar de forma muito, muito simples tarefas complexas no R. O lado negativo de usar essas ferramenas, claro, é que deixamos o R-base um pouco de lado. Esse é um trade-off que compensa, no entanto. Acredito que isso ficará evidente na próxima aula."
  },
  {
    "objectID": "aulas/aula1.html#instalando-pacotes",
    "href": "aulas/aula1.html#instalando-pacotes",
    "title": "Aula 1",
    "section": "Instalando pacotes",
    "text": "Instalando pacotes\nO R é continuamente reformulado por uma grande comunidade de desenvolvedores que disponibilizam novos códigos por meio de pacotes, ou libraries. O tidyverse é um desses pacotes e, por isso, não está disponível por padrão no R. Para instalá-lo, usamos a seguinte função4:\n\ninstall.packages(\"tidyverse\")\n\nTudo o que precisamos passar para essa função install.packages é o nome do pacote que queremos instalar entre aspas (um texto). Após algum tempo, o R deve baixar os arquivos necessários e o pacote é instalado.5 Feito isso, não precisamos mais rodar esse código (o pacote estará permanentemente no seu computador).\nDepois, usamos a função library para carregar o nosso pacote, isto é, para deixar suas funções acessíveis a nossa sessão do R6:\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nEsse código produzirá algumas mensagens, algo normal. O que realmente importa: sempre que quisermos usar funções de algum pacote que instalamos (e que não é parte do R-base), precisamos carregá-lo; uma vez carregado, podemos usar suas funções normalmente.\n\ndata.frames\nNo R, bancos de dados, ou planilhas, formam um tipo específico de objetos. Já vimos números, texto, e agora veremos esse outro tipo: o data.frame.\nO pacote tidyverse contém um data.frame bem simples que serve como exemplo. Execute:\n\nband_members\n\n# A tibble: 3 × 2\n  name  band   \n  &lt;chr&gt; &lt;chr&gt;  \n1 Mick  Stones \n2 John  Beatles\n3 Paul  Beatles\n\n\nIsso retornará algo muito próximo ao que vocês estão acostumados: temos colunas (i.e., variáveis) e linhas (i.e., observações). No nosso caso, temos uma coluna chamada name, que contém os nomes de alguns músicos (Mick, John, Paul); e, a outra, os nomes de suas respectivas bandas (Stones, Beatles, Beatles). Talvez isso ajude a mostrar que estamos falando de algo como uma planilha:\n\nView(band_members)\n\nA função View, como deve ter ficado claro, abre uma janela (no RStudio, acima da aba console) que nos permite visualizar os dados como se estivéssemos usando Excel ou no SPSS. Normalmente isso é útil para entendermos um data.frame, quais são suas variáveis, quais são suas entradas mais comuns.\nPodemos, também, salvar esse data.frame em um objeto para podermos trabalhar com ele.\n\nmeu_df &lt;- band_members\n\nÉ possível ver que, agora, o RStudio mostra esse objeto na aba Environment, mostrando algumas informações úteis sobre ele.\nHá algumas funções que geralmente usamos para inspecionar data.frames como esses, especialmente quando são grandes (o que pode tornar View(meu_df) lento e ineficiente). O tidyverse contém uma delas, chamada glimpse, que exibe várias informações de uma vez:\n\nglimpse(meu_df)\n\nRows: 3\nColumns: 2\n$ name &lt;chr&gt; \"Mick\", \"John\", \"Paul\"\n$ band &lt;chr&gt; \"Stones\", \"Beatles\", \"Beatles\""
  },
  {
    "objectID": "aulas/aula1.html#manipulações-simples",
    "href": "aulas/aula1.html#manipulações-simples",
    "title": "Aula 1",
    "section": "Manipulações simples",
    "text": "Manipulações simples\nO tidyverse tem algumas funções que são fundamentais para trabalharmos com data.frames. Digamos que eu queira manter apenas a variável name no df salvo em meu meu_df, por exemplo. A função, nesse caso, é select:\n\nselect(meu_df, name)\n\n# A tibble: 3 × 1\n  name \n  &lt;chr&gt;\n1 Mick \n2 John \n3 Paul \n\n\nEssa função recebe dois argumentos, um data.frame7 e o nome sem aspas da variável que queremos selecionar. Podemos selecionar apenas band também.\n\nselect(meu_df, band)\n\n# A tibble: 3 × 1\n  band   \n  &lt;chr&gt;  \n1 Stones \n2 Beatles\n3 Beatles\n\n\nE para selecionar algumas linhas? Usamos slice:\n\nslice(meu_df, 1)\n\n# A tibble: 1 × 2\n  name  band  \n  &lt;chr&gt; &lt;chr&gt; \n1 Mick  Stones\n\n\nPrecisamos apenas indicar o número da linha que queremos. Para preservar apenas a segunda:\n\nslice(meu_df, 2)\n\n# A tibble: 1 × 2\n  name  band   \n  &lt;chr&gt; &lt;chr&gt;  \n1 John  Beatles\n\n\nComo não estamos salvando em um novo objeto os resultados de slice, o meu_df permanece com seu conteúdo original (pode checar digitando e executando meu_df no console). Para salvar essas operações, podemos criar um novo objeto:\n\nnovo_df &lt;- slice(meu_df, 2)\n\nNão se preocupe se parecer muita coisa para memorizar agora. Veremos data.frames e manipulação nas próximas aulas."
  },
  {
    "objectID": "aulas/aula1.html#scripts",
    "href": "aulas/aula1.html#scripts",
    "title": "Aula 1",
    "section": "Scripts",
    "text": "Scripts\nAntes de terminarmos as notas dessa aula, lembre-se: salve seus códigos em um arquivo com extensão .R. Isso é extremamente útil para documentar tudo o que você fizer. É possível criar um novo arquivo pelo caminho File &gt; New File &gt; R Script; ou usando o atalho de teclado Ctrl + Shift + N. É uma boa prática não usar acentos, letras maiúsculas e espaço no nome de arquivos. Sempre prefira minha_analise.R em vez de Minha Análise.R."
  },
  {
    "objectID": "aulas/aula1.html#footnotes",
    "href": "aulas/aula1.html#footnotes",
    "title": "Aula 1",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nEssa janela normalmente fica embaixo, na esquerda, em uma aba chamada Console↩︎\nEmbora ele também seja uma linguagem de programação.↩︎\nTambém é possível usar =, mas evitaremos esse uso para não criar confusões.↩︎\nExistem pacotes não oficiais (i.e., que não estão hospedados pelo CRAN), que não são instalados dessa forma. Por enquanto, não vamos nos deter nisso.↩︎\nCom alguma frequência a instalação de um pacote dá erro e, no mais das vezes, isso ocorre porque alguns pacotes dependem de outros softwares instalados no seu computador – por exemplo, o pacote sf, muito usado em análises espaciais, em sistemas operacionais como MacOS ou Linux depende de um software chamado GDAL. Como saber quando isso é o caso? Não há resposta final sobre isso, e mesmo pessoas experientes sofrem com esses problemas; buscar no Google ou ChatGPT, no entanto, sempre são boas opções.↩︎\nBasicamente, isso envolve carregar uma coisa chamada namespace do pacote que estamos carregando, algo que não cobriremos nesse curso. Para saber mais: http://r-pkgs.had.co.nz/namespace.html↩︎\nOu tibble, como veremos nas próximas aulas.↩︎"
  },
  {
    "objectID": "exercicios/exercicios2.html",
    "href": "exercicios/exercicios2.html",
    "title": "Exercícios II",
    "section": "",
    "text": "Dentro da pasta do curso há vários arquivos. Usando as funções que vimos, tente carregar e visualizar todos os arquivos nomeados como municipios_mg – há mais de um deles com diferentes extensões.\n\n\n\nNo link a seguir, há uma planilha com dados da população dos municípios do Brasil. Tente descobrir como esse arquivo está estruturado e como carregá-lo no R (dica: é possível usar o link):\n\nhttps://raw.githubusercontent.com/rdsilva/BrazilPopulation/master/brazil-population-1992-2017.csv\n\n\n\n\nCom a base que você carregou no exercício anterior, a exporte para os seguintes formatos: .csv, .txt, .sav e .Rda."
  },
  {
    "objectID": "exercicios/exercicios2.html#importação-e-exportação",
    "href": "exercicios/exercicios2.html#importação-e-exportação",
    "title": "Exercícios II",
    "section": "",
    "text": "Dentro da pasta do curso há vários arquivos. Usando as funções que vimos, tente carregar e visualizar todos os arquivos nomeados como municipios_mg – há mais de um deles com diferentes extensões.\n\n\n\nNo link a seguir, há uma planilha com dados da população dos municípios do Brasil. Tente descobrir como esse arquivo está estruturado e como carregá-lo no R (dica: é possível usar o link):\n\nhttps://raw.githubusercontent.com/rdsilva/BrazilPopulation/master/brazil-population-1992-2017.csv\n\n\n\n\nCom a base que você carregou no exercício anterior, a exporte para os seguintes formatos: .csv, .txt, .sav e .Rda."
  },
  {
    "objectID": "exercicios/exercicios2.html#manipulação",
    "href": "exercicios/exercicios2.html#manipulação",
    "title": "Exercícios II",
    "section": "Manipulação",
    "text": "Manipulação\n\nTeste I\nA base de dados nos arquivos municipios_mg que estamos usando contém alguns dados sobre os gastos orçamentários de 808 municipios mineiros em 2012 (em reais). Carregue esse banco usando qualquer função, calcule os gastos per capita em saúde desses municípios e descubra os 10 que mais gastaram.\n\n\nTeste II\nCom a municipios_mg original (carregue-a de novo se precisar), calcule o percentual gasto por todos os municípios em saúde e em segurança. Descubra os 10 mais que gastaram relativamente em cada área – isto é, os 10 que mais gastaram em saúde e os 10 que mais gastaram em segurança.\n\n\nTeste III\nCom a municipios_mg original (carregue-a de novo se precisar), calcule a diferença entre o que cada município gastou assistência social e segurança (i.e., assistência \\(-\\) segurança). Mantenha em uma nova base apenas as variáveis indicando essa diferença e nome do município.\n\n\nTeste IV\nCom essa base anterior recém criada, adicione uma variável que indica se a diferença entre assistência e saúde é negativa ou positiva. Quais são os municípios em que essa diferença é negativa?\n\n\nTeste V\nCarregue novamente essa base a seguir:\nhttps://raw.githubusercontent.com/rdsilva/BrazilPopulation/master/brazil-population-1992-2017.csv\nCom ela, faça o seguinte:\n\nFiltre apenas observações do ano de 2002;\nAgrupe a base resultante por região do país;\nCalcule o número de municípios por região (use a solução que achar mais adequada)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução ao R",
    "section": "",
    "text": "Este website contém os materiais e exercícios do curso de Introdução ao R da Escola de Inverno do IESP-UERJ. O material é estruturado na sequência de cada uma de nossas aulas, indicadas no menu superior, e cobrem desde noções básicas até soluções para gerir projetos de pesquisa replicáveis. O material disponível aqui foi feito para ser consumido, idealmente, de forma auto-orientada: leia explicações; reproduza e altere os exemplos, especialmente os mais complexos; realize os exercícios e atividades.\nO curso tem como público-alvo cientistas sociais sem conhecimentos prévios sobre R, embora também seja útil para pessoas de outras áreas.\nA ementa do curso está disponível neste link."
  },
  {
    "objectID": "index.html#sobre",
    "href": "index.html#sobre",
    "title": "Introdução ao R",
    "section": "",
    "text": "Este website contém os materiais e exercícios do curso de Introdução ao R da Escola de Inverno do IESP-UERJ. O material é estruturado na sequência de cada uma de nossas aulas, indicadas no menu superior, e cobrem desde noções básicas até soluções para gerir projetos de pesquisa replicáveis. O material disponível aqui foi feito para ser consumido, idealmente, de forma auto-orientada: leia explicações; reproduza e altere os exemplos, especialmente os mais complexos; realize os exercícios e atividades.\nO curso tem como público-alvo cientistas sociais sem conhecimentos prévios sobre R, embora também seja útil para pessoas de outras áreas.\nA ementa do curso está disponível neste link."
  },
  {
    "objectID": "index.html#plano-das-aulas",
    "href": "index.html#plano-das-aulas",
    "title": "Introdução ao R",
    "section": "Plano das aulas",
    "text": "Plano das aulas\n\n\n\nAula\nTópico\n\n\n\n\n1\nBásico\n\n\n2\nManipulação de dados\n\n\n3\nVisualização\n\n\n4\nExportação"
  }
]